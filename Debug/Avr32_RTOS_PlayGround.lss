
Avr32_RTOS_PlayGround.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000802a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  0000802a  000080be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000066c  008000a8  008000a8  00008106  2**0
                  ALLOC
  3 .stab         0000a86c  00000000  00000000  00008108  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006d99  00000000  00000000  00012974  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001970d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0001984d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  000199bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0001b606  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001c4f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001d2a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001d400  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001d68d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001de5b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 63 19 	jmp	0x32c6	; 0x32c6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e2       	ldi	r30, 0x2A	; 42
      68:	f0 e8       	ldi	r31, 0x80	; 128
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3a       	cpi	r26, 0xA8	; 168
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 ea       	ldi	r26, 0xA8	; 168
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 31       	cpi	r26, 0x14	; 20
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 53 3f 	call	0x7ea6	; 0x7ea6 <main>
      8a:	0c 94 13 40 	jmp	0x8026	; 0x8026 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 cc 3f 	jmp	0x7f98	; 0x7f98 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ac e9       	ldi	r26, 0x9C	; 156
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e8 3f 	jmp	0x7fd0	; 0x7fd0 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d8 3f 	jmp	0x7fb0	; 0x7fb0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f4 3f 	jmp	0x7fe8	; 0x7fe8 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d8 3f 	jmp	0x7fb0	; 0x7fb0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f4 3f 	jmp	0x7fe8	; 0x7fe8 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 cc 3f 	jmp	0x7f98	; 0x7f98 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8c e9       	ldi	r24, 0x9C	; 156
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e8 3f 	jmp	0x7fd0	; 0x7fd0 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d8 3f 	jmp	0x7fb0	; 0x7fb0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 f4 3f 	jmp	0x7fe8	; 0x7fe8 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 d8 3f 	jmp	0x7fb0	; 0x7fb0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 f4 3f 	jmp	0x7fe8	; 0x7fe8 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 d8 3f 	jmp	0x7fb0	; 0x7fb0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 f4 3f 	jmp	0x7fe8	; 0x7fe8 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 dc 3f 	jmp	0x7fb8	; 0x7fb8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 f8 3f 	jmp	0x7ff0	; 0x7ff0 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <DIO_enuInit>:



///********************************** Module intialization **********************************/
ErrorStatus_t DIO_enuInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	0f 92       	push	r0
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
    ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
     b50:	19 82       	std	Y+1, r1	; 0x01

	/***************** Group A *****************/
	DDRA = CONC(DIO_u8PA0_DIR, DIO_u8PA1_DIR,
     b52:	ea e3       	ldi	r30, 0x3A	; 58
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 ef       	ldi	r24, 0xF0	; 240
     b58:	80 83       	st	Z, r24
				DIO_u8PA2_DIR, DIO_u8PA3_DIR,
				DIO_u8PA4_DIR, DIO_u8PA5_DIR,
				DIO_u8PA6_DIR, DIO_u8PA7_DIR);

	PORTA = CONC(DIO_u8PA0_VALUE, DIO_u8PA1_VALUE,
     b5a:	eb e3       	ldi	r30, 0x3B	; 59
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	83 ec       	ldi	r24, 0xC3	; 195
     b60:	80 83       	st	Z, r24
				DIO_u8PA6_VALUE, DIO_u8PA7_VALUE);
	/******************************************/


	/***************** Group B *****************/
	DDRB = CONC(DIO_u8PB0_DIR, DIO_u8PB1_DIR,
     b62:	e7 e3       	ldi	r30, 0x37	; 55
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	80 ef       	ldi	r24, 0xF0	; 240
     b68:	80 83       	st	Z, r24
				DIO_u8PB2_DIR, DIO_u8PB3_DIR,
				DIO_u8PB4_DIR, DIO_u8PB5_DIR,
				DIO_u8PB6_DIR, DIO_u8PB7_DIR);

	PORTB = CONC(DIO_u8PB0_VALUE, DIO_u8PB1_VALUE,
     b6a:	e8 e3       	ldi	r30, 0x38	; 56
     b6c:	f0 e0       	ldi	r31, 0x00	; 0
     b6e:	83 ec       	ldi	r24, 0xC3	; 195
     b70:	80 83       	st	Z, r24
				DIO_u8PB6_VALUE, DIO_u8PB7_VALUE);
	/******************************************/


	/***************** Group C *****************/
	DDRC = CONC(DIO_u8PC0_DIR, DIO_u8PC1_DIR,
     b72:	e4 e3       	ldi	r30, 0x34	; 52
     b74:	f0 e0       	ldi	r31, 0x00	; 0
     b76:	80 ef       	ldi	r24, 0xF0	; 240
     b78:	80 83       	st	Z, r24
				DIO_u8PC2_DIR, DIO_u8PC3_DIR,
				DIO_u8PC4_DIR, DIO_u8PC5_DIR,
				DIO_u8PC6_DIR, DIO_u8PC7_DIR);

	PORTC = CONC(DIO_u8PC0_VALUE, DIO_u8PC1_VALUE,
     b7a:	e5 e3       	ldi	r30, 0x35	; 53
     b7c:	f0 e0       	ldi	r31, 0x00	; 0
     b7e:	83 ec       	ldi	r24, 0xC3	; 195
     b80:	80 83       	st	Z, r24
				DIO_u8PC6_VALUE, DIO_u8PC7_VALUE);
	/******************************************/


	/***************** Group D *****************/
	DDRD = CONC(DIO_u8PD0_DIR, DIO_u8PD1_DIR,
     b82:	e1 e3       	ldi	r30, 0x31	; 49
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	80 ef       	ldi	r24, 0xF0	; 240
     b88:	80 83       	st	Z, r24
				DIO_u8PD2_DIR, DIO_u8PD3_DIR,
				DIO_u8PD4_DIR, DIO_u8PD5_DIR,
				DIO_u8PD6_DIR, DIO_u8PD7_DIR);

	PORTD = CONC(DIO_u8PD0_VALUE, DIO_u8PD1_VALUE,
     b8a:	e2 e3       	ldi	r30, 0x32	; 50
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	83 ec       	ldi	r24, 0xC3	; 195
     b90:	80 83       	st	Z, r24
	/******************************************/
	
	//! (Now we either check if values are set or not ) 


    return Local_enu_ErrorState;
     b92:	89 81       	ldd	r24, Y+1	; 0x01
}
     b94:	0f 90       	pop	r0
     b96:	cf 91       	pop	r28
     b98:	df 91       	pop	r29
     b9a:	08 95       	ret

00000b9c <DIO_enuSetPinDirection>:
///********************************** Control Pin by Pin **********************************/
// 1. set pin as output or output
ErrorStatus_t DIO_enuSetPinDirection(
	uint8_t Copy_u8PortID,
	uint8_t Copy_u8PinID,
	uint8_t Copy_u8Direction){
     b9c:	df 93       	push	r29
     b9e:	cf 93       	push	r28
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	27 97       	sbiw	r28, 0x07	; 7
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	f8 94       	cli
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	cd bf       	out	0x3d, r28	; 61
     bb0:	8a 83       	std	Y+2, r24	; 0x02
     bb2:	6b 83       	std	Y+3, r22	; 0x03
     bb4:	4c 83       	std	Y+4, r20	; 0x04

	
	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
     bb6:	19 82       	std	Y+1, r1	; 0x01


	if(Copy_u8PortID <= DIO_u8PortD && Copy_u8PinID <= DIO_u8PIN7 && Copy_u8Direction <= DIO_u8OUTPUT){
     bb8:	8a 81       	ldd	r24, Y+2	; 0x02
     bba:	84 30       	cpi	r24, 0x04	; 4
     bbc:	08 f0       	brcs	.+2      	; 0xbc0 <DIO_enuSetPinDirection+0x24>
     bbe:	de c0       	rjmp	.+444    	; 0xd7c <DIO_enuSetPinDirection+0x1e0>
     bc0:	8b 81       	ldd	r24, Y+3	; 0x03
     bc2:	88 30       	cpi	r24, 0x08	; 8
     bc4:	08 f0       	brcs	.+2      	; 0xbc8 <DIO_enuSetPinDirection+0x2c>
     bc6:	da c0       	rjmp	.+436    	; 0xd7c <DIO_enuSetPinDirection+0x1e0>
     bc8:	8c 81       	ldd	r24, Y+4	; 0x04
     bca:	82 30       	cpi	r24, 0x02	; 2
     bcc:	08 f0       	brcs	.+2      	; 0xbd0 <DIO_enuSetPinDirection+0x34>
     bce:	d6 c0       	rjmp	.+428    	; 0xd7c <DIO_enuSetPinDirection+0x1e0>

		switch(Copy_u8PortID){
     bd0:	8a 81       	ldd	r24, Y+2	; 0x02
     bd2:	28 2f       	mov	r18, r24
     bd4:	30 e0       	ldi	r19, 0x00	; 0
     bd6:	3f 83       	std	Y+7, r19	; 0x07
     bd8:	2e 83       	std	Y+6, r18	; 0x06
     bda:	8e 81       	ldd	r24, Y+6	; 0x06
     bdc:	9f 81       	ldd	r25, Y+7	; 0x07
     bde:	81 30       	cpi	r24, 0x01	; 1
     be0:	91 05       	cpc	r25, r1
     be2:	09 f4       	brne	.+2      	; 0xbe6 <DIO_enuSetPinDirection+0x4a>
     be4:	43 c0       	rjmp	.+134    	; 0xc6c <DIO_enuSetPinDirection+0xd0>
     be6:	2e 81       	ldd	r18, Y+6	; 0x06
     be8:	3f 81       	ldd	r19, Y+7	; 0x07
     bea:	22 30       	cpi	r18, 0x02	; 2
     bec:	31 05       	cpc	r19, r1
     bee:	2c f4       	brge	.+10     	; 0xbfa <DIO_enuSetPinDirection+0x5e>
     bf0:	8e 81       	ldd	r24, Y+6	; 0x06
     bf2:	9f 81       	ldd	r25, Y+7	; 0x07
     bf4:	00 97       	sbiw	r24, 0x00	; 0
     bf6:	71 f0       	breq	.+28     	; 0xc14 <DIO_enuSetPinDirection+0x78>
     bf8:	bc c0       	rjmp	.+376    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>
     bfa:	2e 81       	ldd	r18, Y+6	; 0x06
     bfc:	3f 81       	ldd	r19, Y+7	; 0x07
     bfe:	22 30       	cpi	r18, 0x02	; 2
     c00:	31 05       	cpc	r19, r1
     c02:	09 f4       	brne	.+2      	; 0xc06 <DIO_enuSetPinDirection+0x6a>
     c04:	5f c0       	rjmp	.+190    	; 0xcc4 <DIO_enuSetPinDirection+0x128>
     c06:	8e 81       	ldd	r24, Y+6	; 0x06
     c08:	9f 81       	ldd	r25, Y+7	; 0x07
     c0a:	83 30       	cpi	r24, 0x03	; 3
     c0c:	91 05       	cpc	r25, r1
     c0e:	09 f4       	brne	.+2      	; 0xc12 <DIO_enuSetPinDirection+0x76>
     c10:	85 c0       	rjmp	.+266    	; 0xd1c <DIO_enuSetPinDirection+0x180>
     c12:	af c0       	rjmp	.+350    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>
			case DIO_u8PortA:
				
				if(Copy_u8Direction == DIO_u8OUTPUT){
     c14:	8c 81       	ldd	r24, Y+4	; 0x04
     c16:	81 30       	cpi	r24, 0x01	; 1
     c18:	a1 f4       	brne	.+40     	; 0xc42 <DIO_enuSetPinDirection+0xa6>
					SET_BIT(DDRA, Copy_u8PinID);
     c1a:	aa e3       	ldi	r26, 0x3A	; 58
     c1c:	b0 e0       	ldi	r27, 0x00	; 0
     c1e:	ea e3       	ldi	r30, 0x3A	; 58
     c20:	f0 e0       	ldi	r31, 0x00	; 0
     c22:	80 81       	ld	r24, Z
     c24:	48 2f       	mov	r20, r24
     c26:	8b 81       	ldd	r24, Y+3	; 0x03
     c28:	28 2f       	mov	r18, r24
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	90 e0       	ldi	r25, 0x00	; 0
     c30:	02 2e       	mov	r0, r18
     c32:	02 c0       	rjmp	.+4      	; 0xc38 <DIO_enuSetPinDirection+0x9c>
     c34:	88 0f       	add	r24, r24
     c36:	99 1f       	adc	r25, r25
     c38:	0a 94       	dec	r0
     c3a:	e2 f7       	brpl	.-8      	; 0xc34 <DIO_enuSetPinDirection+0x98>
     c3c:	84 2b       	or	r24, r20
     c3e:	8c 93       	st	X, r24
     c40:	98 c0       	rjmp	.+304    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>
				}else{
					
					/* setting pin as input */

					//! input pullup-float is not cacluated
					CLR_BIT(DDRA, Copy_u8PinID);
     c42:	aa e3       	ldi	r26, 0x3A	; 58
     c44:	b0 e0       	ldi	r27, 0x00	; 0
     c46:	ea e3       	ldi	r30, 0x3A	; 58
     c48:	f0 e0       	ldi	r31, 0x00	; 0
     c4a:	80 81       	ld	r24, Z
     c4c:	48 2f       	mov	r20, r24
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	28 2f       	mov	r18, r24
     c52:	30 e0       	ldi	r19, 0x00	; 0
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	02 2e       	mov	r0, r18
     c5a:	02 c0       	rjmp	.+4      	; 0xc60 <DIO_enuSetPinDirection+0xc4>
     c5c:	88 0f       	add	r24, r24
     c5e:	99 1f       	adc	r25, r25
     c60:	0a 94       	dec	r0
     c62:	e2 f7       	brpl	.-8      	; 0xc5c <DIO_enuSetPinDirection+0xc0>
     c64:	80 95       	com	r24
     c66:	84 23       	and	r24, r20
     c68:	8c 93       	st	X, r24
     c6a:	83 c0       	rjmp	.+262    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>

			break;

			case DIO_u8PortB:
			
				if(Copy_u8Direction == DIO_u8OUTPUT){
     c6c:	8c 81       	ldd	r24, Y+4	; 0x04
     c6e:	81 30       	cpi	r24, 0x01	; 1
     c70:	a1 f4       	brne	.+40     	; 0xc9a <DIO_enuSetPinDirection+0xfe>
					SET_BIT(DDRB, Copy_u8PinID);
     c72:	a7 e3       	ldi	r26, 0x37	; 55
     c74:	b0 e0       	ldi	r27, 0x00	; 0
     c76:	e7 e3       	ldi	r30, 0x37	; 55
     c78:	f0 e0       	ldi	r31, 0x00	; 0
     c7a:	80 81       	ld	r24, Z
     c7c:	48 2f       	mov	r20, r24
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	28 2f       	mov	r18, r24
     c82:	30 e0       	ldi	r19, 0x00	; 0
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	02 2e       	mov	r0, r18
     c8a:	02 c0       	rjmp	.+4      	; 0xc90 <DIO_enuSetPinDirection+0xf4>
     c8c:	88 0f       	add	r24, r24
     c8e:	99 1f       	adc	r25, r25
     c90:	0a 94       	dec	r0
     c92:	e2 f7       	brpl	.-8      	; 0xc8c <DIO_enuSetPinDirection+0xf0>
     c94:	84 2b       	or	r24, r20
     c96:	8c 93       	st	X, r24
     c98:	6c c0       	rjmp	.+216    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>
				}else{
					
					/* setting pin as input */

					//! input pullup-float is not cacluated
					CLR_BIT(DDRB, Copy_u8PinID);
     c9a:	a7 e3       	ldi	r26, 0x37	; 55
     c9c:	b0 e0       	ldi	r27, 0x00	; 0
     c9e:	e7 e3       	ldi	r30, 0x37	; 55
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	80 81       	ld	r24, Z
     ca4:	48 2f       	mov	r20, r24
     ca6:	8b 81       	ldd	r24, Y+3	; 0x03
     ca8:	28 2f       	mov	r18, r24
     caa:	30 e0       	ldi	r19, 0x00	; 0
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	02 2e       	mov	r0, r18
     cb2:	02 c0       	rjmp	.+4      	; 0xcb8 <DIO_enuSetPinDirection+0x11c>
     cb4:	88 0f       	add	r24, r24
     cb6:	99 1f       	adc	r25, r25
     cb8:	0a 94       	dec	r0
     cba:	e2 f7       	brpl	.-8      	; 0xcb4 <DIO_enuSetPinDirection+0x118>
     cbc:	80 95       	com	r24
     cbe:	84 23       	and	r24, r20
     cc0:	8c 93       	st	X, r24
     cc2:	57 c0       	rjmp	.+174    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>

			break;

			case DIO_u8PortC:

				if(Copy_u8Direction == DIO_u8OUTPUT){
     cc4:	8c 81       	ldd	r24, Y+4	; 0x04
     cc6:	81 30       	cpi	r24, 0x01	; 1
     cc8:	a1 f4       	brne	.+40     	; 0xcf2 <DIO_enuSetPinDirection+0x156>
					SET_BIT(DDRC, Copy_u8PinID);
     cca:	a4 e3       	ldi	r26, 0x34	; 52
     ccc:	b0 e0       	ldi	r27, 0x00	; 0
     cce:	e4 e3       	ldi	r30, 0x34	; 52
     cd0:	f0 e0       	ldi	r31, 0x00	; 0
     cd2:	80 81       	ld	r24, Z
     cd4:	48 2f       	mov	r20, r24
     cd6:	8b 81       	ldd	r24, Y+3	; 0x03
     cd8:	28 2f       	mov	r18, r24
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	02 2e       	mov	r0, r18
     ce2:	02 c0       	rjmp	.+4      	; 0xce8 <DIO_enuSetPinDirection+0x14c>
     ce4:	88 0f       	add	r24, r24
     ce6:	99 1f       	adc	r25, r25
     ce8:	0a 94       	dec	r0
     cea:	e2 f7       	brpl	.-8      	; 0xce4 <DIO_enuSetPinDirection+0x148>
     cec:	84 2b       	or	r24, r20
     cee:	8c 93       	st	X, r24
     cf0:	40 c0       	rjmp	.+128    	; 0xd72 <DIO_enuSetPinDirection+0x1d6>
				}else{
					
					/* setting pin as input */

					//! input pullup-float is not cacluated
					CLR_BIT(DDRC, Copy_u8PinID);
     cf2:	a4 e3       	ldi	r26, 0x34	; 52
     cf4:	b0 e0       	ldi	r27, 0x00	; 0
     cf6:	e4 e3       	ldi	r30, 0x34	; 52
     cf8:	f0 e0       	ldi	r31, 0x00	; 0
     cfa:	80 81       	ld	r24, Z
     cfc:	48 2f       	mov	r20, r24
     cfe:	8b 81       	ldd	r24, Y+3	; 0x03
     d00:	28 2f       	mov	r18, r24
     d02:	30 e0       	ldi	r19, 0x00	; 0
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	02 2e       	mov	r0, r18
     d0a:	02 c0       	rjmp	.+4      	; 0xd10 <DIO_enuSetPinDirection+0x174>
     d0c:	88 0f       	add	r24, r24
     d0e:	99 1f       	adc	r25, r25
     d10:	0a 94       	dec	r0
     d12:	e2 f7       	brpl	.-8      	; 0xd0c <DIO_enuSetPinDirection+0x170>
     d14:	80 95       	com	r24
     d16:	84 23       	and	r24, r20
     d18:	8c 93       	st	X, r24
     d1a:	2b c0       	rjmp	.+86     	; 0xd72 <DIO_enuSetPinDirection+0x1d6>

			break;

			case DIO_u8PortD:
		
				if(Copy_u8Direction == DIO_u8OUTPUT){
     d1c:	8c 81       	ldd	r24, Y+4	; 0x04
     d1e:	81 30       	cpi	r24, 0x01	; 1
     d20:	a1 f4       	brne	.+40     	; 0xd4a <DIO_enuSetPinDirection+0x1ae>
					SET_BIT(DDRD, Copy_u8PinID);
     d22:	a1 e3       	ldi	r26, 0x31	; 49
     d24:	b0 e0       	ldi	r27, 0x00	; 0
     d26:	e1 e3       	ldi	r30, 0x31	; 49
     d28:	f0 e0       	ldi	r31, 0x00	; 0
     d2a:	80 81       	ld	r24, Z
     d2c:	48 2f       	mov	r20, r24
     d2e:	8b 81       	ldd	r24, Y+3	; 0x03
     d30:	28 2f       	mov	r18, r24
     d32:	30 e0       	ldi	r19, 0x00	; 0
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	90 e0       	ldi	r25, 0x00	; 0
     d38:	02 2e       	mov	r0, r18
     d3a:	02 c0       	rjmp	.+4      	; 0xd40 <DIO_enuSetPinDirection+0x1a4>
     d3c:	88 0f       	add	r24, r24
     d3e:	99 1f       	adc	r25, r25
     d40:	0a 94       	dec	r0
     d42:	e2 f7       	brpl	.-8      	; 0xd3c <DIO_enuSetPinDirection+0x1a0>
     d44:	84 2b       	or	r24, r20
     d46:	8c 93       	st	X, r24
     d48:	14 c0       	rjmp	.+40     	; 0xd72 <DIO_enuSetPinDirection+0x1d6>
				}else{
					
					/* setting pin as input */

					//! input pullup-float is not cacluated
					CLR_BIT(DDRD, Copy_u8PinID);
     d4a:	a1 e3       	ldi	r26, 0x31	; 49
     d4c:	b0 e0       	ldi	r27, 0x00	; 0
     d4e:	e1 e3       	ldi	r30, 0x31	; 49
     d50:	f0 e0       	ldi	r31, 0x00	; 0
     d52:	80 81       	ld	r24, Z
     d54:	48 2f       	mov	r20, r24
     d56:	8b 81       	ldd	r24, Y+3	; 0x03
     d58:	28 2f       	mov	r18, r24
     d5a:	30 e0       	ldi	r19, 0x00	; 0
     d5c:	81 e0       	ldi	r24, 0x01	; 1
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	02 2e       	mov	r0, r18
     d62:	02 c0       	rjmp	.+4      	; 0xd68 <DIO_enuSetPinDirection+0x1cc>
     d64:	88 0f       	add	r24, r24
     d66:	99 1f       	adc	r25, r25
     d68:	0a 94       	dec	r0
     d6a:	e2 f7       	brpl	.-8      	; 0xd64 <DIO_enuSetPinDirection+0x1c8>
     d6c:	80 95       	com	r24
     d6e:	84 23       	and	r24, r20
     d70:	8c 93       	st	X, r24
				}

		}

		Local_enu_ErrorState = ERROR_STATUS_OK;
     d72:	81 e0       	ldi	r24, 0x01	; 1
     d74:	89 83       	std	Y+1, r24	; 0x01
	}else{
		// one of arguments are not valid
		return Local_enu_ErrorState;
	}
	
	return Local_enu_ErrorState;
     d76:	99 81       	ldd	r25, Y+1	; 0x01
     d78:	9d 83       	std	Y+5, r25	; 0x05
     d7a:	02 c0       	rjmp	.+4      	; 0xd80 <DIO_enuSetPinDirection+0x1e4>

		Local_enu_ErrorState = ERROR_STATUS_OK;

	}else{
		// one of arguments are not valid
		return Local_enu_ErrorState;
     d7c:	29 81       	ldd	r18, Y+1	; 0x01
     d7e:	2d 83       	std	Y+5, r18	; 0x05
     d80:	8d 81       	ldd	r24, Y+5	; 0x05
	}
	
	return Local_enu_ErrorState;
   }
     d82:	27 96       	adiw	r28, 0x07	; 7
     d84:	0f b6       	in	r0, 0x3f	; 63
     d86:	f8 94       	cli
     d88:	de bf       	out	0x3e, r29	; 62
     d8a:	0f be       	out	0x3f, r0	; 63
     d8c:	cd bf       	out	0x3d, r28	; 61
     d8e:	cf 91       	pop	r28
     d90:	df 91       	pop	r29
     d92:	08 95       	ret

00000d94 <DIO_enuSetPinValue>:

// 2. set value for pin as high or low 
ErrorStatus_t DIO_enuSetPinValue(
   uint8_t Copy_u8PortID,
   uint8_t Copy_u8PinID,
   uint8_t Copy_u8Value){
     d94:	df 93       	push	r29
     d96:	cf 93       	push	r28
     d98:	cd b7       	in	r28, 0x3d	; 61
     d9a:	de b7       	in	r29, 0x3e	; 62
     d9c:	27 97       	sbiw	r28, 0x07	; 7
     d9e:	0f b6       	in	r0, 0x3f	; 63
     da0:	f8 94       	cli
     da2:	de bf       	out	0x3e, r29	; 62
     da4:	0f be       	out	0x3f, r0	; 63
     da6:	cd bf       	out	0x3d, r28	; 61
     da8:	8a 83       	std	Y+2, r24	; 0x02
     daa:	6b 83       	std	Y+3, r22	; 0x03
     dac:	4c 83       	std	Y+4, r20	; 0x04


	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
     dae:	19 82       	std	Y+1, r1	; 0x01


	// DIO_u8PULLUP - 1
	if(Copy_u8PortID <= DIO_u8PortD && Copy_u8PinID <= DIO_u8PIN7 && Copy_u8Value <= DIO_u8PULLUP){
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	84 30       	cpi	r24, 0x04	; 4
     db4:	08 f0       	brcs	.+2      	; 0xdb8 <DIO_enuSetPinValue+0x24>
     db6:	de c0       	rjmp	.+444    	; 0xf74 <DIO_enuSetPinValue+0x1e0>
     db8:	8b 81       	ldd	r24, Y+3	; 0x03
     dba:	88 30       	cpi	r24, 0x08	; 8
     dbc:	08 f0       	brcs	.+2      	; 0xdc0 <DIO_enuSetPinValue+0x2c>
     dbe:	da c0       	rjmp	.+436    	; 0xf74 <DIO_enuSetPinValue+0x1e0>
     dc0:	8c 81       	ldd	r24, Y+4	; 0x04
     dc2:	82 30       	cpi	r24, 0x02	; 2
     dc4:	08 f0       	brcs	.+2      	; 0xdc8 <DIO_enuSetPinValue+0x34>
     dc6:	d6 c0       	rjmp	.+428    	; 0xf74 <DIO_enuSetPinValue+0x1e0>
		
		switch (Copy_u8PortID){
     dc8:	8a 81       	ldd	r24, Y+2	; 0x02
     dca:	28 2f       	mov	r18, r24
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	3f 83       	std	Y+7, r19	; 0x07
     dd0:	2e 83       	std	Y+6, r18	; 0x06
     dd2:	8e 81       	ldd	r24, Y+6	; 0x06
     dd4:	9f 81       	ldd	r25, Y+7	; 0x07
     dd6:	81 30       	cpi	r24, 0x01	; 1
     dd8:	91 05       	cpc	r25, r1
     dda:	09 f4       	brne	.+2      	; 0xdde <DIO_enuSetPinValue+0x4a>
     ddc:	43 c0       	rjmp	.+134    	; 0xe64 <DIO_enuSetPinValue+0xd0>
     dde:	2e 81       	ldd	r18, Y+6	; 0x06
     de0:	3f 81       	ldd	r19, Y+7	; 0x07
     de2:	22 30       	cpi	r18, 0x02	; 2
     de4:	31 05       	cpc	r19, r1
     de6:	2c f4       	brge	.+10     	; 0xdf2 <DIO_enuSetPinValue+0x5e>
     de8:	8e 81       	ldd	r24, Y+6	; 0x06
     dea:	9f 81       	ldd	r25, Y+7	; 0x07
     dec:	00 97       	sbiw	r24, 0x00	; 0
     dee:	71 f0       	breq	.+28     	; 0xe0c <DIO_enuSetPinValue+0x78>
     df0:	bc c0       	rjmp	.+376    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
     df2:	2e 81       	ldd	r18, Y+6	; 0x06
     df4:	3f 81       	ldd	r19, Y+7	; 0x07
     df6:	22 30       	cpi	r18, 0x02	; 2
     df8:	31 05       	cpc	r19, r1
     dfa:	09 f4       	brne	.+2      	; 0xdfe <DIO_enuSetPinValue+0x6a>
     dfc:	5f c0       	rjmp	.+190    	; 0xebc <DIO_enuSetPinValue+0x128>
     dfe:	8e 81       	ldd	r24, Y+6	; 0x06
     e00:	9f 81       	ldd	r25, Y+7	; 0x07
     e02:	83 30       	cpi	r24, 0x03	; 3
     e04:	91 05       	cpc	r25, r1
     e06:	09 f4       	brne	.+2      	; 0xe0a <DIO_enuSetPinValue+0x76>
     e08:	85 c0       	rjmp	.+266    	; 0xf14 <DIO_enuSetPinValue+0x180>
     e0a:	af c0       	rjmp	.+350    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
		
			case DIO_u8PortA:
				if(Copy_u8Value){
     e0c:	8c 81       	ldd	r24, Y+4	; 0x04
     e0e:	88 23       	and	r24, r24
     e10:	a1 f0       	breq	.+40     	; 0xe3a <DIO_enuSetPinValue+0xa6>

					// if the value is set to HIGH
					SET_BIT(PORTA, Copy_u8PinID);
     e12:	ab e3       	ldi	r26, 0x3B	; 59
     e14:	b0 e0       	ldi	r27, 0x00	; 0
     e16:	eb e3       	ldi	r30, 0x3B	; 59
     e18:	f0 e0       	ldi	r31, 0x00	; 0
     e1a:	80 81       	ld	r24, Z
     e1c:	48 2f       	mov	r20, r24
     e1e:	8b 81       	ldd	r24, Y+3	; 0x03
     e20:	28 2f       	mov	r18, r24
     e22:	30 e0       	ldi	r19, 0x00	; 0
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	02 2e       	mov	r0, r18
     e2a:	02 c0       	rjmp	.+4      	; 0xe30 <DIO_enuSetPinValue+0x9c>
     e2c:	88 0f       	add	r24, r24
     e2e:	99 1f       	adc	r25, r25
     e30:	0a 94       	dec	r0
     e32:	e2 f7       	brpl	.-8      	; 0xe2c <DIO_enuSetPinValue+0x98>
     e34:	84 2b       	or	r24, r20
     e36:	8c 93       	st	X, r24
     e38:	98 c0       	rjmp	.+304    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}else{
					CLR_BIT(PORTA, Copy_u8PinID);
     e3a:	ab e3       	ldi	r26, 0x3B	; 59
     e3c:	b0 e0       	ldi	r27, 0x00	; 0
     e3e:	eb e3       	ldi	r30, 0x3B	; 59
     e40:	f0 e0       	ldi	r31, 0x00	; 0
     e42:	80 81       	ld	r24, Z
     e44:	48 2f       	mov	r20, r24
     e46:	8b 81       	ldd	r24, Y+3	; 0x03
     e48:	28 2f       	mov	r18, r24
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	02 2e       	mov	r0, r18
     e52:	02 c0       	rjmp	.+4      	; 0xe58 <DIO_enuSetPinValue+0xc4>
     e54:	88 0f       	add	r24, r24
     e56:	99 1f       	adc	r25, r25
     e58:	0a 94       	dec	r0
     e5a:	e2 f7       	brpl	.-8      	; 0xe54 <DIO_enuSetPinValue+0xc0>
     e5c:	80 95       	com	r24
     e5e:	84 23       	and	r24, r20
     e60:	8c 93       	st	X, r24
     e62:	83 c0       	rjmp	.+262    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}	

			break;
			
			case DIO_u8PortB:
				if(Copy_u8Value){
     e64:	8c 81       	ldd	r24, Y+4	; 0x04
     e66:	88 23       	and	r24, r24
     e68:	a1 f0       	breq	.+40     	; 0xe92 <DIO_enuSetPinValue+0xfe>

					// if the value is set to HIGH
					SET_BIT(PORTB, Copy_u8PinID);
     e6a:	a8 e3       	ldi	r26, 0x38	; 56
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	e8 e3       	ldi	r30, 0x38	; 56
     e70:	f0 e0       	ldi	r31, 0x00	; 0
     e72:	80 81       	ld	r24, Z
     e74:	48 2f       	mov	r20, r24
     e76:	8b 81       	ldd	r24, Y+3	; 0x03
     e78:	28 2f       	mov	r18, r24
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	02 2e       	mov	r0, r18
     e82:	02 c0       	rjmp	.+4      	; 0xe88 <DIO_enuSetPinValue+0xf4>
     e84:	88 0f       	add	r24, r24
     e86:	99 1f       	adc	r25, r25
     e88:	0a 94       	dec	r0
     e8a:	e2 f7       	brpl	.-8      	; 0xe84 <DIO_enuSetPinValue+0xf0>
     e8c:	84 2b       	or	r24, r20
     e8e:	8c 93       	st	X, r24
     e90:	6c c0       	rjmp	.+216    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}else{
					CLR_BIT(PORTB, Copy_u8PinID);
     e92:	a8 e3       	ldi	r26, 0x38	; 56
     e94:	b0 e0       	ldi	r27, 0x00	; 0
     e96:	e8 e3       	ldi	r30, 0x38	; 56
     e98:	f0 e0       	ldi	r31, 0x00	; 0
     e9a:	80 81       	ld	r24, Z
     e9c:	48 2f       	mov	r20, r24
     e9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ea0:	28 2f       	mov	r18, r24
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	02 2e       	mov	r0, r18
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <DIO_enuSetPinValue+0x11c>
     eac:	88 0f       	add	r24, r24
     eae:	99 1f       	adc	r25, r25
     eb0:	0a 94       	dec	r0
     eb2:	e2 f7       	brpl	.-8      	; 0xeac <DIO_enuSetPinValue+0x118>
     eb4:	80 95       	com	r24
     eb6:	84 23       	and	r24, r20
     eb8:	8c 93       	st	X, r24
     eba:	57 c0       	rjmp	.+174    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}	
			
			break;

			case DIO_u8PortC:
				if(Copy_u8Value){
     ebc:	8c 81       	ldd	r24, Y+4	; 0x04
     ebe:	88 23       	and	r24, r24
     ec0:	a1 f0       	breq	.+40     	; 0xeea <DIO_enuSetPinValue+0x156>

					// if the value is set to HIGH
					SET_BIT(PORTC, Copy_u8PinID);
     ec2:	a5 e3       	ldi	r26, 0x35	; 53
     ec4:	b0 e0       	ldi	r27, 0x00	; 0
     ec6:	e5 e3       	ldi	r30, 0x35	; 53
     ec8:	f0 e0       	ldi	r31, 0x00	; 0
     eca:	80 81       	ld	r24, Z
     ecc:	48 2f       	mov	r20, r24
     ece:	8b 81       	ldd	r24, Y+3	; 0x03
     ed0:	28 2f       	mov	r18, r24
     ed2:	30 e0       	ldi	r19, 0x00	; 0
     ed4:	81 e0       	ldi	r24, 0x01	; 1
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	02 2e       	mov	r0, r18
     eda:	02 c0       	rjmp	.+4      	; 0xee0 <DIO_enuSetPinValue+0x14c>
     edc:	88 0f       	add	r24, r24
     ede:	99 1f       	adc	r25, r25
     ee0:	0a 94       	dec	r0
     ee2:	e2 f7       	brpl	.-8      	; 0xedc <DIO_enuSetPinValue+0x148>
     ee4:	84 2b       	or	r24, r20
     ee6:	8c 93       	st	X, r24
     ee8:	40 c0       	rjmp	.+128    	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}else{
					CLR_BIT(PORTC, Copy_u8PinID);
     eea:	a5 e3       	ldi	r26, 0x35	; 53
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	e5 e3       	ldi	r30, 0x35	; 53
     ef0:	f0 e0       	ldi	r31, 0x00	; 0
     ef2:	80 81       	ld	r24, Z
     ef4:	48 2f       	mov	r20, r24
     ef6:	8b 81       	ldd	r24, Y+3	; 0x03
     ef8:	28 2f       	mov	r18, r24
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	81 e0       	ldi	r24, 0x01	; 1
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	02 2e       	mov	r0, r18
     f02:	02 c0       	rjmp	.+4      	; 0xf08 <DIO_enuSetPinValue+0x174>
     f04:	88 0f       	add	r24, r24
     f06:	99 1f       	adc	r25, r25
     f08:	0a 94       	dec	r0
     f0a:	e2 f7       	brpl	.-8      	; 0xf04 <DIO_enuSetPinValue+0x170>
     f0c:	80 95       	com	r24
     f0e:	84 23       	and	r24, r20
     f10:	8c 93       	st	X, r24
     f12:	2b c0       	rjmp	.+86     	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}	

			break;
			case DIO_u8PortD:
				if(Copy_u8Value){
     f14:	8c 81       	ldd	r24, Y+4	; 0x04
     f16:	88 23       	and	r24, r24
     f18:	a1 f0       	breq	.+40     	; 0xf42 <DIO_enuSetPinValue+0x1ae>

					// if the value is set to HIGH
					SET_BIT(PORTD, Copy_u8PinID);
     f1a:	a2 e3       	ldi	r26, 0x32	; 50
     f1c:	b0 e0       	ldi	r27, 0x00	; 0
     f1e:	e2 e3       	ldi	r30, 0x32	; 50
     f20:	f0 e0       	ldi	r31, 0x00	; 0
     f22:	80 81       	ld	r24, Z
     f24:	48 2f       	mov	r20, r24
     f26:	8b 81       	ldd	r24, Y+3	; 0x03
     f28:	28 2f       	mov	r18, r24
     f2a:	30 e0       	ldi	r19, 0x00	; 0
     f2c:	81 e0       	ldi	r24, 0x01	; 1
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	02 2e       	mov	r0, r18
     f32:	02 c0       	rjmp	.+4      	; 0xf38 <DIO_enuSetPinValue+0x1a4>
     f34:	88 0f       	add	r24, r24
     f36:	99 1f       	adc	r25, r25
     f38:	0a 94       	dec	r0
     f3a:	e2 f7       	brpl	.-8      	; 0xf34 <DIO_enuSetPinValue+0x1a0>
     f3c:	84 2b       	or	r24, r20
     f3e:	8c 93       	st	X, r24
     f40:	14 c0       	rjmp	.+40     	; 0xf6a <DIO_enuSetPinValue+0x1d6>
				}else{
					CLR_BIT(PORTD, Copy_u8PinID);
     f42:	a2 e3       	ldi	r26, 0x32	; 50
     f44:	b0 e0       	ldi	r27, 0x00	; 0
     f46:	e2 e3       	ldi	r30, 0x32	; 50
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	80 81       	ld	r24, Z
     f4c:	48 2f       	mov	r20, r24
     f4e:	8b 81       	ldd	r24, Y+3	; 0x03
     f50:	28 2f       	mov	r18, r24
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	02 2e       	mov	r0, r18
     f5a:	02 c0       	rjmp	.+4      	; 0xf60 <DIO_enuSetPinValue+0x1cc>
     f5c:	88 0f       	add	r24, r24
     f5e:	99 1f       	adc	r25, r25
     f60:	0a 94       	dec	r0
     f62:	e2 f7       	brpl	.-8      	; 0xf5c <DIO_enuSetPinValue+0x1c8>
     f64:	80 95       	com	r24
     f66:	84 23       	and	r24, r20
     f68:	8c 93       	st	X, r24
				}
		}
		Local_enu_ErrorState = ERROR_STATUS_OK;
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	89 83       	std	Y+1, r24	; 0x01

    }else{
		return Local_enu_ErrorState;
	}

	return Local_enu_ErrorState;
     f6e:	99 81       	ldd	r25, Y+1	; 0x01
     f70:	9d 83       	std	Y+5, r25	; 0x05
     f72:	02 c0       	rjmp	.+4      	; 0xf78 <DIO_enuSetPinValue+0x1e4>
				}
		}
		Local_enu_ErrorState = ERROR_STATUS_OK;

    }else{
		return Local_enu_ErrorState;
     f74:	29 81       	ldd	r18, Y+1	; 0x01
     f76:	2d 83       	std	Y+5, r18	; 0x05
     f78:	8d 81       	ldd	r24, Y+5	; 0x05
	}

	return Local_enu_ErrorState;
   }
     f7a:	27 96       	adiw	r28, 0x07	; 7
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	f8 94       	cli
     f80:	de bf       	out	0x3e, r29	; 62
     f82:	0f be       	out	0x3f, r0	; 63
     f84:	cd bf       	out	0x3d, r28	; 61
     f86:	cf 91       	pop	r28
     f88:	df 91       	pop	r29
     f8a:	08 95       	ret

00000f8c <DIO_enuGetPinValue>:

// 3. read pin value 
ErrorStatus_t DIO_enuGetPinValue(
   uint8_t Copy_u8PortID,
   uint8_t Copy_u8PinID,
   uint8_t *Copy_pu8Value){
     f8c:	df 93       	push	r29
     f8e:	cf 93       	push	r28
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	28 97       	sbiw	r28, 0x08	; 8
     f96:	0f b6       	in	r0, 0x3f	; 63
     f98:	f8 94       	cli
     f9a:	de bf       	out	0x3e, r29	; 62
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	cd bf       	out	0x3d, r28	; 61
     fa0:	8a 83       	std	Y+2, r24	; 0x02
     fa2:	6b 83       	std	Y+3, r22	; 0x03
     fa4:	5d 83       	std	Y+5, r21	; 0x05
     fa6:	4c 83       	std	Y+4, r20	; 0x04

	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
     fa8:	19 82       	std	Y+1, r1	; 0x01


	if(Copy_pu8Value == NULL){
     faa:	8c 81       	ldd	r24, Y+4	; 0x04
     fac:	9d 81       	ldd	r25, Y+5	; 0x05
     fae:	00 97       	sbiw	r24, 0x00	; 0
     fb0:	29 f4       	brne	.+10     	; 0xfbc <DIO_enuGetPinValue+0x30>

		Local_enu_ErrorState = ERROR_STATUS_NULL_POINTER;
     fb2:	83 e0       	ldi	r24, 0x03	; 3
     fb4:	89 83       	std	Y+1, r24	; 0x01
		return Local_enu_ErrorState;
     fb6:	29 81       	ldd	r18, Y+1	; 0x01
     fb8:	28 87       	std	Y+8, r18	; 0x08
     fba:	7f c0       	rjmp	.+254    	; 0x10ba <DIO_enuGetPinValue+0x12e>
	}


	else if(Copy_u8PortID <= DIO_u8PortD && Copy_u8PinID <= DIO_u8PIN7){
     fbc:	8a 81       	ldd	r24, Y+2	; 0x02
     fbe:	84 30       	cpi	r24, 0x04	; 4
     fc0:	08 f0       	brcs	.+2      	; 0xfc4 <DIO_enuGetPinValue+0x38>
     fc2:	79 c0       	rjmp	.+242    	; 0x10b6 <DIO_enuGetPinValue+0x12a>
     fc4:	8b 81       	ldd	r24, Y+3	; 0x03
     fc6:	88 30       	cpi	r24, 0x08	; 8
     fc8:	08 f0       	brcs	.+2      	; 0xfcc <DIO_enuGetPinValue+0x40>
     fca:	75 c0       	rjmp	.+234    	; 0x10b6 <DIO_enuGetPinValue+0x12a>

		switch(Copy_u8PortID){
     fcc:	8a 81       	ldd	r24, Y+2	; 0x02
     fce:	48 2f       	mov	r20, r24
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	5f 83       	std	Y+7, r21	; 0x07
     fd4:	4e 83       	std	Y+6, r20	; 0x06
     fd6:	8e 81       	ldd	r24, Y+6	; 0x06
     fd8:	9f 81       	ldd	r25, Y+7	; 0x07
     fda:	81 30       	cpi	r24, 0x01	; 1
     fdc:	91 05       	cpc	r25, r1
     fde:	59 f1       	breq	.+86     	; 0x1036 <DIO_enuGetPinValue+0xaa>
     fe0:	2e 81       	ldd	r18, Y+6	; 0x06
     fe2:	3f 81       	ldd	r19, Y+7	; 0x07
     fe4:	22 30       	cpi	r18, 0x02	; 2
     fe6:	31 05       	cpc	r19, r1
     fe8:	34 f4       	brge	.+12     	; 0xff6 <DIO_enuGetPinValue+0x6a>
     fea:	4e 81       	ldd	r20, Y+6	; 0x06
     fec:	5f 81       	ldd	r21, Y+7	; 0x07
     fee:	41 15       	cp	r20, r1
     ff0:	51 05       	cpc	r21, r1
     ff2:	69 f0       	breq	.+26     	; 0x100e <DIO_enuGetPinValue+0x82>
     ff4:	5b c0       	rjmp	.+182    	; 0x10ac <DIO_enuGetPinValue+0x120>
     ff6:	8e 81       	ldd	r24, Y+6	; 0x06
     ff8:	9f 81       	ldd	r25, Y+7	; 0x07
     ffa:	82 30       	cpi	r24, 0x02	; 2
     ffc:	91 05       	cpc	r25, r1
     ffe:	79 f1       	breq	.+94     	; 0x105e <DIO_enuGetPinValue+0xd2>
    1000:	2e 81       	ldd	r18, Y+6	; 0x06
    1002:	3f 81       	ldd	r19, Y+7	; 0x07
    1004:	23 30       	cpi	r18, 0x03	; 3
    1006:	31 05       	cpc	r19, r1
    1008:	09 f4       	brne	.+2      	; 0x100c <DIO_enuGetPinValue+0x80>
    100a:	3d c0       	rjmp	.+122    	; 0x1086 <DIO_enuGetPinValue+0xfa>
    100c:	4f c0       	rjmp	.+158    	; 0x10ac <DIO_enuGetPinValue+0x120>
			case DIO_u8PortA:
				*Copy_pu8Value = GET_BIT(PINA, Copy_u8PinID);
    100e:	e9 e3       	ldi	r30, 0x39	; 57
    1010:	f0 e0       	ldi	r31, 0x00	; 0
    1012:	80 81       	ld	r24, Z
    1014:	28 2f       	mov	r18, r24
    1016:	30 e0       	ldi	r19, 0x00	; 0
    1018:	8b 81       	ldd	r24, Y+3	; 0x03
    101a:	88 2f       	mov	r24, r24
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	a9 01       	movw	r20, r18
    1020:	02 c0       	rjmp	.+4      	; 0x1026 <DIO_enuGetPinValue+0x9a>
    1022:	55 95       	asr	r21
    1024:	47 95       	ror	r20
    1026:	8a 95       	dec	r24
    1028:	e2 f7       	brpl	.-8      	; 0x1022 <DIO_enuGetPinValue+0x96>
    102a:	ca 01       	movw	r24, r20
    102c:	81 70       	andi	r24, 0x01	; 1
    102e:	ec 81       	ldd	r30, Y+4	; 0x04
    1030:	fd 81       	ldd	r31, Y+5	; 0x05
    1032:	80 83       	st	Z, r24
    1034:	3b c0       	rjmp	.+118    	; 0x10ac <DIO_enuGetPinValue+0x120>
			break;

			case DIO_u8PortB:
				*Copy_pu8Value = GET_BIT(PINB, Copy_u8PinID);
    1036:	e6 e3       	ldi	r30, 0x36	; 54
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	80 81       	ld	r24, Z
    103c:	28 2f       	mov	r18, r24
    103e:	30 e0       	ldi	r19, 0x00	; 0
    1040:	8b 81       	ldd	r24, Y+3	; 0x03
    1042:	88 2f       	mov	r24, r24
    1044:	90 e0       	ldi	r25, 0x00	; 0
    1046:	a9 01       	movw	r20, r18
    1048:	02 c0       	rjmp	.+4      	; 0x104e <DIO_enuGetPinValue+0xc2>
    104a:	55 95       	asr	r21
    104c:	47 95       	ror	r20
    104e:	8a 95       	dec	r24
    1050:	e2 f7       	brpl	.-8      	; 0x104a <DIO_enuGetPinValue+0xbe>
    1052:	ca 01       	movw	r24, r20
    1054:	81 70       	andi	r24, 0x01	; 1
    1056:	ec 81       	ldd	r30, Y+4	; 0x04
    1058:	fd 81       	ldd	r31, Y+5	; 0x05
    105a:	80 83       	st	Z, r24
    105c:	27 c0       	rjmp	.+78     	; 0x10ac <DIO_enuGetPinValue+0x120>
			break;

			case DIO_u8PortC:
				*Copy_pu8Value = GET_BIT(PINC, Copy_u8PinID);
    105e:	e3 e3       	ldi	r30, 0x33	; 51
    1060:	f0 e0       	ldi	r31, 0x00	; 0
    1062:	80 81       	ld	r24, Z
    1064:	28 2f       	mov	r18, r24
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	8b 81       	ldd	r24, Y+3	; 0x03
    106a:	88 2f       	mov	r24, r24
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	a9 01       	movw	r20, r18
    1070:	02 c0       	rjmp	.+4      	; 0x1076 <DIO_enuGetPinValue+0xea>
    1072:	55 95       	asr	r21
    1074:	47 95       	ror	r20
    1076:	8a 95       	dec	r24
    1078:	e2 f7       	brpl	.-8      	; 0x1072 <DIO_enuGetPinValue+0xe6>
    107a:	ca 01       	movw	r24, r20
    107c:	81 70       	andi	r24, 0x01	; 1
    107e:	ec 81       	ldd	r30, Y+4	; 0x04
    1080:	fd 81       	ldd	r31, Y+5	; 0x05
    1082:	80 83       	st	Z, r24
    1084:	13 c0       	rjmp	.+38     	; 0x10ac <DIO_enuGetPinValue+0x120>
			break;
			
			case DIO_u8PortD:
				*Copy_pu8Value = GET_BIT(PIND, Copy_u8PinID);
    1086:	e0 e3       	ldi	r30, 0x30	; 48
    1088:	f0 e0       	ldi	r31, 0x00	; 0
    108a:	80 81       	ld	r24, Z
    108c:	28 2f       	mov	r18, r24
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	8b 81       	ldd	r24, Y+3	; 0x03
    1092:	88 2f       	mov	r24, r24
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	a9 01       	movw	r20, r18
    1098:	02 c0       	rjmp	.+4      	; 0x109e <DIO_enuGetPinValue+0x112>
    109a:	55 95       	asr	r21
    109c:	47 95       	ror	r20
    109e:	8a 95       	dec	r24
    10a0:	e2 f7       	brpl	.-8      	; 0x109a <DIO_enuGetPinValue+0x10e>
    10a2:	ca 01       	movw	r24, r20
    10a4:	81 70       	andi	r24, 0x01	; 1
    10a6:	ec 81       	ldd	r30, Y+4	; 0x04
    10a8:	fd 81       	ldd	r31, Y+5	; 0x05
    10aa:	80 83       	st	Z, r24
		}
		Local_enu_ErrorState = ERROR_STATUS_OK;
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	89 83       	std	Y+1, r24	; 0x01

	}else{
		return Local_enu_ErrorState;
	}

	return Local_enu_ErrorState;
    10b0:	59 81       	ldd	r21, Y+1	; 0x01
    10b2:	58 87       	std	Y+8, r21	; 0x08
    10b4:	02 c0       	rjmp	.+4      	; 0x10ba <DIO_enuGetPinValue+0x12e>
		}
		Local_enu_ErrorState = ERROR_STATUS_OK;


	}else{
		return Local_enu_ErrorState;
    10b6:	89 81       	ldd	r24, Y+1	; 0x01
    10b8:	88 87       	std	Y+8, r24	; 0x08
    10ba:	88 85       	ldd	r24, Y+8	; 0x08
	}

	return Local_enu_ErrorState;
   }
    10bc:	28 96       	adiw	r28, 0x08	; 8
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	de bf       	out	0x3e, r29	; 62
    10c4:	0f be       	out	0x3f, r0	; 63
    10c6:	cd bf       	out	0x3d, r28	; 61
    10c8:	cf 91       	pop	r28
    10ca:	df 91       	pop	r29
    10cc:	08 95       	ret

000010ce <DIO_enuTogglePinValue>:




// 4. if it (1) change it to (0) and vice versa
ErrorStatus_t DIO_enuTogglePinValue(uint8_t Copy_u8PortID, uint8_t Copy_u8PinID){
    10ce:	df 93       	push	r29
    10d0:	cf 93       	push	r28
    10d2:	00 d0       	rcall	.+0      	; 0x10d4 <DIO_enuTogglePinValue+0x6>
    10d4:	00 d0       	rcall	.+0      	; 0x10d6 <DIO_enuTogglePinValue+0x8>
    10d6:	00 d0       	rcall	.+0      	; 0x10d8 <DIO_enuTogglePinValue+0xa>
    10d8:	cd b7       	in	r28, 0x3d	; 61
    10da:	de b7       	in	r29, 0x3e	; 62
    10dc:	8a 83       	std	Y+2, r24	; 0x02
    10de:	6b 83       	std	Y+3, r22	; 0x03

	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
    10e0:	19 82       	std	Y+1, r1	; 0x01


	if(Copy_u8PortID <= DIO_u8PortD && Copy_u8PinID <= DIO_u8PIN7){
    10e2:	8a 81       	ldd	r24, Y+2	; 0x02
    10e4:	84 30       	cpi	r24, 0x04	; 4
    10e6:	08 f0       	brcs	.+2      	; 0x10ea <DIO_enuTogglePinValue+0x1c>
    10e8:	77 c0       	rjmp	.+238    	; 0x11d8 <DIO_enuTogglePinValue+0x10a>
    10ea:	8b 81       	ldd	r24, Y+3	; 0x03
    10ec:	88 30       	cpi	r24, 0x08	; 8
    10ee:	08 f0       	brcs	.+2      	; 0x10f2 <DIO_enuTogglePinValue+0x24>
    10f0:	73 c0       	rjmp	.+230    	; 0x11d8 <DIO_enuTogglePinValue+0x10a>

		switch(Copy_u8PortID){
    10f2:	8a 81       	ldd	r24, Y+2	; 0x02
    10f4:	28 2f       	mov	r18, r24
    10f6:	30 e0       	ldi	r19, 0x00	; 0
    10f8:	3e 83       	std	Y+6, r19	; 0x06
    10fa:	2d 83       	std	Y+5, r18	; 0x05
    10fc:	8d 81       	ldd	r24, Y+5	; 0x05
    10fe:	9e 81       	ldd	r25, Y+6	; 0x06
    1100:	81 30       	cpi	r24, 0x01	; 1
    1102:	91 05       	cpc	r25, r1
    1104:	49 f1       	breq	.+82     	; 0x1158 <DIO_enuTogglePinValue+0x8a>
    1106:	2d 81       	ldd	r18, Y+5	; 0x05
    1108:	3e 81       	ldd	r19, Y+6	; 0x06
    110a:	22 30       	cpi	r18, 0x02	; 2
    110c:	31 05       	cpc	r19, r1
    110e:	2c f4       	brge	.+10     	; 0x111a <DIO_enuTogglePinValue+0x4c>
    1110:	8d 81       	ldd	r24, Y+5	; 0x05
    1112:	9e 81       	ldd	r25, Y+6	; 0x06
    1114:	00 97       	sbiw	r24, 0x00	; 0
    1116:	61 f0       	breq	.+24     	; 0x1130 <DIO_enuTogglePinValue+0x62>
    1118:	5a c0       	rjmp	.+180    	; 0x11ce <DIO_enuTogglePinValue+0x100>
    111a:	2d 81       	ldd	r18, Y+5	; 0x05
    111c:	3e 81       	ldd	r19, Y+6	; 0x06
    111e:	22 30       	cpi	r18, 0x02	; 2
    1120:	31 05       	cpc	r19, r1
    1122:	71 f1       	breq	.+92     	; 0x1180 <DIO_enuTogglePinValue+0xb2>
    1124:	8d 81       	ldd	r24, Y+5	; 0x05
    1126:	9e 81       	ldd	r25, Y+6	; 0x06
    1128:	83 30       	cpi	r24, 0x03	; 3
    112a:	91 05       	cpc	r25, r1
    112c:	e9 f1       	breq	.+122    	; 0x11a8 <DIO_enuTogglePinValue+0xda>
    112e:	4f c0       	rjmp	.+158    	; 0x11ce <DIO_enuTogglePinValue+0x100>
			case DIO_u8PortA:
				TOG_BIT(PORTA, Copy_u8PinID);
    1130:	ab e3       	ldi	r26, 0x3B	; 59
    1132:	b0 e0       	ldi	r27, 0x00	; 0
    1134:	eb e3       	ldi	r30, 0x3B	; 59
    1136:	f0 e0       	ldi	r31, 0x00	; 0
    1138:	80 81       	ld	r24, Z
    113a:	48 2f       	mov	r20, r24
    113c:	8b 81       	ldd	r24, Y+3	; 0x03
    113e:	28 2f       	mov	r18, r24
    1140:	30 e0       	ldi	r19, 0x00	; 0
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	02 2e       	mov	r0, r18
    1148:	02 c0       	rjmp	.+4      	; 0x114e <DIO_enuTogglePinValue+0x80>
    114a:	88 0f       	add	r24, r24
    114c:	99 1f       	adc	r25, r25
    114e:	0a 94       	dec	r0
    1150:	e2 f7       	brpl	.-8      	; 0x114a <DIO_enuTogglePinValue+0x7c>
    1152:	84 27       	eor	r24, r20
    1154:	8c 93       	st	X, r24
    1156:	3b c0       	rjmp	.+118    	; 0x11ce <DIO_enuTogglePinValue+0x100>
			break;

			case DIO_u8PortB:
				TOG_BIT(PORTB, Copy_u8PinID);
    1158:	a8 e3       	ldi	r26, 0x38	; 56
    115a:	b0 e0       	ldi	r27, 0x00	; 0
    115c:	e8 e3       	ldi	r30, 0x38	; 56
    115e:	f0 e0       	ldi	r31, 0x00	; 0
    1160:	80 81       	ld	r24, Z
    1162:	48 2f       	mov	r20, r24
    1164:	8b 81       	ldd	r24, Y+3	; 0x03
    1166:	28 2f       	mov	r18, r24
    1168:	30 e0       	ldi	r19, 0x00	; 0
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	02 2e       	mov	r0, r18
    1170:	02 c0       	rjmp	.+4      	; 0x1176 <DIO_enuTogglePinValue+0xa8>
    1172:	88 0f       	add	r24, r24
    1174:	99 1f       	adc	r25, r25
    1176:	0a 94       	dec	r0
    1178:	e2 f7       	brpl	.-8      	; 0x1172 <DIO_enuTogglePinValue+0xa4>
    117a:	84 27       	eor	r24, r20
    117c:	8c 93       	st	X, r24
    117e:	27 c0       	rjmp	.+78     	; 0x11ce <DIO_enuTogglePinValue+0x100>
			break;

			case DIO_u8PortC:
				TOG_BIT(PORTC, Copy_u8PinID);
    1180:	a5 e3       	ldi	r26, 0x35	; 53
    1182:	b0 e0       	ldi	r27, 0x00	; 0
    1184:	e5 e3       	ldi	r30, 0x35	; 53
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	48 2f       	mov	r20, r24
    118c:	8b 81       	ldd	r24, Y+3	; 0x03
    118e:	28 2f       	mov	r18, r24
    1190:	30 e0       	ldi	r19, 0x00	; 0
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	90 e0       	ldi	r25, 0x00	; 0
    1196:	02 2e       	mov	r0, r18
    1198:	02 c0       	rjmp	.+4      	; 0x119e <DIO_enuTogglePinValue+0xd0>
    119a:	88 0f       	add	r24, r24
    119c:	99 1f       	adc	r25, r25
    119e:	0a 94       	dec	r0
    11a0:	e2 f7       	brpl	.-8      	; 0x119a <DIO_enuTogglePinValue+0xcc>
    11a2:	84 27       	eor	r24, r20
    11a4:	8c 93       	st	X, r24
    11a6:	13 c0       	rjmp	.+38     	; 0x11ce <DIO_enuTogglePinValue+0x100>
			break;
			
			case DIO_u8PortD:
				TOG_BIT(PORTD, Copy_u8PinID);
    11a8:	a2 e3       	ldi	r26, 0x32	; 50
    11aa:	b0 e0       	ldi	r27, 0x00	; 0
    11ac:	e2 e3       	ldi	r30, 0x32	; 50
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	80 81       	ld	r24, Z
    11b2:	48 2f       	mov	r20, r24
    11b4:	8b 81       	ldd	r24, Y+3	; 0x03
    11b6:	28 2f       	mov	r18, r24
    11b8:	30 e0       	ldi	r19, 0x00	; 0
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	02 2e       	mov	r0, r18
    11c0:	02 c0       	rjmp	.+4      	; 0x11c6 <DIO_enuTogglePinValue+0xf8>
    11c2:	88 0f       	add	r24, r24
    11c4:	99 1f       	adc	r25, r25
    11c6:	0a 94       	dec	r0
    11c8:	e2 f7       	brpl	.-8      	; 0x11c2 <DIO_enuTogglePinValue+0xf4>
    11ca:	84 27       	eor	r24, r20
    11cc:	8c 93       	st	X, r24
		}

		Local_enu_ErrorState = ERROR_STATUS_OK;
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	89 83       	std	Y+1, r24	; 0x01

		return Local_enu_ErrorState;
	}


	return Local_enu_ErrorState;
    11d2:	99 81       	ldd	r25, Y+1	; 0x01
    11d4:	9c 83       	std	Y+4, r25	; 0x04
    11d6:	02 c0       	rjmp	.+4      	; 0x11dc <DIO_enuTogglePinValue+0x10e>

		Local_enu_ErrorState = ERROR_STATUS_OK;

	}else{

		return Local_enu_ErrorState;
    11d8:	29 81       	ldd	r18, Y+1	; 0x01
    11da:	2c 83       	std	Y+4, r18	; 0x04
    11dc:	8c 81       	ldd	r24, Y+4	; 0x04
	}


	return Local_enu_ErrorState;
}
    11de:	26 96       	adiw	r28, 0x06	; 6
    11e0:	0f b6       	in	r0, 0x3f	; 63
    11e2:	f8 94       	cli
    11e4:	de bf       	out	0x3e, r29	; 62
    11e6:	0f be       	out	0x3f, r0	; 63
    11e8:	cd bf       	out	0x3d, r28	; 61
    11ea:	cf 91       	pop	r28
    11ec:	df 91       	pop	r29
    11ee:	08 95       	ret

000011f0 <DIO_enuSetPortDirection>:
///****************************************************************************************/


///********************************** Control Entire Port **********************************/
// 1. set entire port as OUTPUT
ErrorStatus_t DIO_enuSetPortDirection(uint8_t Copy_u8PortID, uint8_t Copy_u8Direction){
    11f0:	df 93       	push	r29
    11f2:	cf 93       	push	r28
    11f4:	00 d0       	rcall	.+0      	; 0x11f6 <DIO_enuSetPortDirection+0x6>
    11f6:	00 d0       	rcall	.+0      	; 0x11f8 <DIO_enuSetPortDirection+0x8>
    11f8:	00 d0       	rcall	.+0      	; 0x11fa <DIO_enuSetPortDirection+0xa>
    11fa:	cd b7       	in	r28, 0x3d	; 61
    11fc:	de b7       	in	r29, 0x3e	; 62
    11fe:	8a 83       	std	Y+2, r24	; 0x02
    1200:	6b 83       	std	Y+3, r22	; 0x03

	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
    1202:	19 82       	std	Y+1, r1	; 0x01

	if(Copy_u8PortID <= DIO_u8PortD && Copy_u8Direction <= DIO_u8OUTPUT){
    1204:	8a 81       	ldd	r24, Y+2	; 0x02
    1206:	84 30       	cpi	r24, 0x04	; 4
    1208:	08 f0       	brcs	.+2      	; 0x120c <DIO_enuSetPortDirection+0x1c>
    120a:	57 c0       	rjmp	.+174    	; 0x12ba <DIO_enuSetPortDirection+0xca>
    120c:	8b 81       	ldd	r24, Y+3	; 0x03
    120e:	82 30       	cpi	r24, 0x02	; 2
    1210:	08 f0       	brcs	.+2      	; 0x1214 <DIO_enuSetPortDirection+0x24>
    1212:	53 c0       	rjmp	.+166    	; 0x12ba <DIO_enuSetPortDirection+0xca>

		switch (Copy_u8PortID){
    1214:	8a 81       	ldd	r24, Y+2	; 0x02
    1216:	28 2f       	mov	r18, r24
    1218:	30 e0       	ldi	r19, 0x00	; 0
    121a:	3e 83       	std	Y+6, r19	; 0x06
    121c:	2d 83       	std	Y+5, r18	; 0x05
    121e:	8d 81       	ldd	r24, Y+5	; 0x05
    1220:	9e 81       	ldd	r25, Y+6	; 0x06
    1222:	81 30       	cpi	r24, 0x01	; 1
    1224:	91 05       	cpc	r25, r1
    1226:	09 f1       	breq	.+66     	; 0x126a <DIO_enuSetPortDirection+0x7a>
    1228:	2d 81       	ldd	r18, Y+5	; 0x05
    122a:	3e 81       	ldd	r19, Y+6	; 0x06
    122c:	22 30       	cpi	r18, 0x02	; 2
    122e:	31 05       	cpc	r19, r1
    1230:	2c f4       	brge	.+10     	; 0x123c <DIO_enuSetPortDirection+0x4c>
    1232:	8d 81       	ldd	r24, Y+5	; 0x05
    1234:	9e 81       	ldd	r25, Y+6	; 0x06
    1236:	00 97       	sbiw	r24, 0x00	; 0
    1238:	61 f0       	breq	.+24     	; 0x1252 <DIO_enuSetPortDirection+0x62>
    123a:	3a c0       	rjmp	.+116    	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
    123c:	2d 81       	ldd	r18, Y+5	; 0x05
    123e:	3e 81       	ldd	r19, Y+6	; 0x06
    1240:	22 30       	cpi	r18, 0x02	; 2
    1242:	31 05       	cpc	r19, r1
    1244:	f1 f0       	breq	.+60     	; 0x1282 <DIO_enuSetPortDirection+0x92>
    1246:	8d 81       	ldd	r24, Y+5	; 0x05
    1248:	9e 81       	ldd	r25, Y+6	; 0x06
    124a:	83 30       	cpi	r24, 0x03	; 3
    124c:	91 05       	cpc	r25, r1
    124e:	29 f1       	breq	.+74     	; 0x129a <DIO_enuSetPortDirection+0xaa>
    1250:	2f c0       	rjmp	.+94     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>

			case DIO_u8PortA:
				if(Copy_u8Direction == DIO_u8OUTPUT){
    1252:	8b 81       	ldd	r24, Y+3	; 0x03
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	29 f4       	brne	.+10     	; 0x1262 <DIO_enuSetPortDirection+0x72>
					DDRA = 0xFF;
    1258:	ea e3       	ldi	r30, 0x3A	; 58
    125a:	f0 e0       	ldi	r31, 0x00	; 0
    125c:	8f ef       	ldi	r24, 0xFF	; 255
    125e:	80 83       	st	Z, r24
    1260:	27 c0       	rjmp	.+78     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}else{

					// set them as Input
					DDRA = 0x00;
    1262:	ea e3       	ldi	r30, 0x3A	; 58
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	10 82       	st	Z, r1
    1268:	23 c0       	rjmp	.+70     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}
			break;

			case DIO_u8PortB:
				if(Copy_u8Direction == DIO_u8OUTPUT){
    126a:	8b 81       	ldd	r24, Y+3	; 0x03
    126c:	81 30       	cpi	r24, 0x01	; 1
    126e:	29 f4       	brne	.+10     	; 0x127a <DIO_enuSetPortDirection+0x8a>
					DDRB = 0xFF;
    1270:	e7 e3       	ldi	r30, 0x37	; 55
    1272:	f0 e0       	ldi	r31, 0x00	; 0
    1274:	8f ef       	ldi	r24, 0xFF	; 255
    1276:	80 83       	st	Z, r24
    1278:	1b c0       	rjmp	.+54     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}else{

					// set them as Input
					DDRB = 0x00;
    127a:	e7 e3       	ldi	r30, 0x37	; 55
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	10 82       	st	Z, r1
    1280:	17 c0       	rjmp	.+46     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}				

			break;

			case DIO_u8PortC:
				if(Copy_u8Direction == DIO_u8OUTPUT){
    1282:	8b 81       	ldd	r24, Y+3	; 0x03
    1284:	81 30       	cpi	r24, 0x01	; 1
    1286:	29 f4       	brne	.+10     	; 0x1292 <DIO_enuSetPortDirection+0xa2>
					DDRC = 0xFF;
    1288:	e4 e3       	ldi	r30, 0x34	; 52
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	8f ef       	ldi	r24, 0xFF	; 255
    128e:	80 83       	st	Z, r24
    1290:	0f c0       	rjmp	.+30     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}else{

					// set them as Input
					DDRC = 0x00;
    1292:	e4 e3       	ldi	r30, 0x34	; 52
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	10 82       	st	Z, r1
    1298:	0b c0       	rjmp	.+22     	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}
			break;

			case DIO_u8PortD:
				if(Copy_u8Direction == DIO_u8OUTPUT){
    129a:	8b 81       	ldd	r24, Y+3	; 0x03
    129c:	81 30       	cpi	r24, 0x01	; 1
    129e:	29 f4       	brne	.+10     	; 0x12aa <DIO_enuSetPortDirection+0xba>
					DDRD = 0xFF;
    12a0:	e1 e3       	ldi	r30, 0x31	; 49
    12a2:	f0 e0       	ldi	r31, 0x00	; 0
    12a4:	8f ef       	ldi	r24, 0xFF	; 255
    12a6:	80 83       	st	Z, r24
    12a8:	03 c0       	rjmp	.+6      	; 0x12b0 <DIO_enuSetPortDirection+0xc0>
				}else{

					// set them as Input
					DDRD = 0x00;
    12aa:	e1 e3       	ldi	r30, 0x31	; 49
    12ac:	f0 e0       	ldi	r31, 0x00	; 0
    12ae:	10 82       	st	Z, r1
				}
			break;	
		}
		Local_enu_ErrorState = ERROR_STATUS_OK;
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	89 83       	std	Y+1, r24	; 0x01
	}else{
		return Local_enu_ErrorState;
	}


	return Local_enu_ErrorState;
    12b4:	99 81       	ldd	r25, Y+1	; 0x01
    12b6:	9c 83       	std	Y+4, r25	; 0x04
    12b8:	02 c0       	rjmp	.+4      	; 0x12be <DIO_enuSetPortDirection+0xce>
			break;	
		}
		Local_enu_ErrorState = ERROR_STATUS_OK;

	}else{
		return Local_enu_ErrorState;
    12ba:	29 81       	ldd	r18, Y+1	; 0x01
    12bc:	2c 83       	std	Y+4, r18	; 0x04
    12be:	8c 81       	ldd	r24, Y+4	; 0x04
	}


	return Local_enu_ErrorState;
}
    12c0:	26 96       	adiw	r28, 0x06	; 6
    12c2:	0f b6       	in	r0, 0x3f	; 63
    12c4:	f8 94       	cli
    12c6:	de bf       	out	0x3e, r29	; 62
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	cd bf       	out	0x3d, r28	; 61
    12cc:	cf 91       	pop	r28
    12ce:	df 91       	pop	r29
    12d0:	08 95       	ret

000012d2 <DIO_enuSetPortValue>:

//! why ??? would you read entire port ?!
//ErrorStatus_t DIO_enuGetPortValue    (uint8_t Copy_u8PortID, uint8_t *Copy_pu8Value);


ErrorStatus_t DIO_enuSetPortValue(uint8_t Copy_u8PortID, uint8_t Copy_u8Value){
    12d2:	df 93       	push	r29
    12d4:	cf 93       	push	r28
    12d6:	00 d0       	rcall	.+0      	; 0x12d8 <DIO_enuSetPortValue+0x6>
    12d8:	00 d0       	rcall	.+0      	; 0x12da <DIO_enuSetPortValue+0x8>
    12da:	00 d0       	rcall	.+0      	; 0x12dc <DIO_enuSetPortValue+0xa>
    12dc:	cd b7       	in	r28, 0x3d	; 61
    12de:	de b7       	in	r29, 0x3e	; 62
    12e0:	8a 83       	std	Y+2, r24	; 0x02
    12e2:	6b 83       	std	Y+3, r22	; 0x03
	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
    12e4:	19 82       	std	Y+1, r1	; 0x01

	if(Copy_u8PortID <= DIO_u8PortD && Copy_u8Value <= DIO_u8PULLUP){
    12e6:	8a 81       	ldd	r24, Y+2	; 0x02
    12e8:	84 30       	cpi	r24, 0x04	; 4
    12ea:	08 f0       	brcs	.+2      	; 0x12ee <DIO_enuSetPortValue+0x1c>
    12ec:	57 c0       	rjmp	.+174    	; 0x139c <DIO_enuSetPortValue+0xca>
    12ee:	8b 81       	ldd	r24, Y+3	; 0x03
    12f0:	82 30       	cpi	r24, 0x02	; 2
    12f2:	08 f0       	brcs	.+2      	; 0x12f6 <DIO_enuSetPortValue+0x24>
    12f4:	53 c0       	rjmp	.+166    	; 0x139c <DIO_enuSetPortValue+0xca>
		
		switch (Copy_u8PortID){
    12f6:	8a 81       	ldd	r24, Y+2	; 0x02
    12f8:	28 2f       	mov	r18, r24
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	3e 83       	std	Y+6, r19	; 0x06
    12fe:	2d 83       	std	Y+5, r18	; 0x05
    1300:	8d 81       	ldd	r24, Y+5	; 0x05
    1302:	9e 81       	ldd	r25, Y+6	; 0x06
    1304:	81 30       	cpi	r24, 0x01	; 1
    1306:	91 05       	cpc	r25, r1
    1308:	09 f1       	breq	.+66     	; 0x134c <DIO_enuSetPortValue+0x7a>
    130a:	2d 81       	ldd	r18, Y+5	; 0x05
    130c:	3e 81       	ldd	r19, Y+6	; 0x06
    130e:	22 30       	cpi	r18, 0x02	; 2
    1310:	31 05       	cpc	r19, r1
    1312:	2c f4       	brge	.+10     	; 0x131e <DIO_enuSetPortValue+0x4c>
    1314:	8d 81       	ldd	r24, Y+5	; 0x05
    1316:	9e 81       	ldd	r25, Y+6	; 0x06
    1318:	00 97       	sbiw	r24, 0x00	; 0
    131a:	61 f0       	breq	.+24     	; 0x1334 <DIO_enuSetPortValue+0x62>
    131c:	3a c0       	rjmp	.+116    	; 0x1392 <DIO_enuSetPortValue+0xc0>
    131e:	2d 81       	ldd	r18, Y+5	; 0x05
    1320:	3e 81       	ldd	r19, Y+6	; 0x06
    1322:	22 30       	cpi	r18, 0x02	; 2
    1324:	31 05       	cpc	r19, r1
    1326:	f1 f0       	breq	.+60     	; 0x1364 <DIO_enuSetPortValue+0x92>
    1328:	8d 81       	ldd	r24, Y+5	; 0x05
    132a:	9e 81       	ldd	r25, Y+6	; 0x06
    132c:	83 30       	cpi	r24, 0x03	; 3
    132e:	91 05       	cpc	r25, r1
    1330:	29 f1       	breq	.+74     	; 0x137c <DIO_enuSetPortValue+0xaa>
    1332:	2f c0       	rjmp	.+94     	; 0x1392 <DIO_enuSetPortValue+0xc0>
			case DIO_u8PortA:
				if(Copy_u8Value){
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	88 23       	and	r24, r24
    1338:	29 f0       	breq	.+10     	; 0x1344 <DIO_enuSetPortValue+0x72>
					PORTA = 0xFF;
    133a:	eb e3       	ldi	r30, 0x3B	; 59
    133c:	f0 e0       	ldi	r31, 0x00	; 0
    133e:	8f ef       	ldi	r24, 0xFF	; 255
    1340:	80 83       	st	Z, r24
    1342:	27 c0       	rjmp	.+78     	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}else{
					PORTA = 0x00;
    1344:	eb e3       	ldi	r30, 0x3B	; 59
    1346:	f0 e0       	ldi	r31, 0x00	; 0
    1348:	10 82       	st	Z, r1
    134a:	23 c0       	rjmp	.+70     	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}
			break;

			case DIO_u8PortB:
				if(Copy_u8Value){
    134c:	8b 81       	ldd	r24, Y+3	; 0x03
    134e:	88 23       	and	r24, r24
    1350:	29 f0       	breq	.+10     	; 0x135c <DIO_enuSetPortValue+0x8a>
					PORTB = 0xFF;
    1352:	e8 e3       	ldi	r30, 0x38	; 56
    1354:	f0 e0       	ldi	r31, 0x00	; 0
    1356:	8f ef       	ldi	r24, 0xFF	; 255
    1358:	80 83       	st	Z, r24
    135a:	1b c0       	rjmp	.+54     	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}else{
					PORTB = 0x00;
    135c:	e8 e3       	ldi	r30, 0x38	; 56
    135e:	f0 e0       	ldi	r31, 0x00	; 0
    1360:	10 82       	st	Z, r1
    1362:	17 c0       	rjmp	.+46     	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}
			break;

			
			case DIO_u8PortC:
				if(Copy_u8Value){
    1364:	8b 81       	ldd	r24, Y+3	; 0x03
    1366:	88 23       	and	r24, r24
    1368:	29 f0       	breq	.+10     	; 0x1374 <DIO_enuSetPortValue+0xa2>
					PORTC = 0xFF;
    136a:	e5 e3       	ldi	r30, 0x35	; 53
    136c:	f0 e0       	ldi	r31, 0x00	; 0
    136e:	8f ef       	ldi	r24, 0xFF	; 255
    1370:	80 83       	st	Z, r24
    1372:	0f c0       	rjmp	.+30     	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}else{
					PORTC = 0x00;
    1374:	e5 e3       	ldi	r30, 0x35	; 53
    1376:	f0 e0       	ldi	r31, 0x00	; 0
    1378:	10 82       	st	Z, r1
    137a:	0b c0       	rjmp	.+22     	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}
			break;
	
			case DIO_u8PortD:
				if(Copy_u8Value){
    137c:	8b 81       	ldd	r24, Y+3	; 0x03
    137e:	88 23       	and	r24, r24
    1380:	29 f0       	breq	.+10     	; 0x138c <DIO_enuSetPortValue+0xba>
					PORTD = 0xFF;
    1382:	e2 e3       	ldi	r30, 0x32	; 50
    1384:	f0 e0       	ldi	r31, 0x00	; 0
    1386:	8f ef       	ldi	r24, 0xFF	; 255
    1388:	80 83       	st	Z, r24
    138a:	03 c0       	rjmp	.+6      	; 0x1392 <DIO_enuSetPortValue+0xc0>
				}else{
					PORTD = 0x00;
    138c:	e2 e3       	ldi	r30, 0x32	; 50
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	10 82       	st	Z, r1
				}
			break;
		}

		Local_enu_ErrorState = ERROR_STATUS_OK;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	89 83       	std	Y+1, r24	; 0x01
	}else{
		return Local_enu_ErrorState;
	}


	return Local_enu_ErrorState;
    1396:	99 81       	ldd	r25, Y+1	; 0x01
    1398:	9c 83       	std	Y+4, r25	; 0x04
    139a:	02 c0       	rjmp	.+4      	; 0x13a0 <DIO_enuSetPortValue+0xce>
			break;
		}

		Local_enu_ErrorState = ERROR_STATUS_OK;
	}else{
		return Local_enu_ErrorState;
    139c:	29 81       	ldd	r18, Y+1	; 0x01
    139e:	2c 83       	std	Y+4, r18	; 0x04
    13a0:	8c 81       	ldd	r24, Y+4	; 0x04
	}


	return Local_enu_ErrorState;
}
    13a2:	26 96       	adiw	r28, 0x06	; 6
    13a4:	0f b6       	in	r0, 0x3f	; 63
    13a6:	f8 94       	cli
    13a8:	de bf       	out	0x3e, r29	; 62
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	cd bf       	out	0x3d, r28	; 61
    13ae:	cf 91       	pop	r28
    13b0:	df 91       	pop	r29
    13b2:	08 95       	ret

000013b4 <LCD_enuInit>:
static ErrorStatus_t WriteNLatch(uint8_t Copy_u8Data);

/**********************************************************/


ErrorStatus_t LCD_enuInit(void){
    13b4:	df 93       	push	r29
    13b6:	cf 93       	push	r28
    13b8:	cd b7       	in	r28, 0x3d	; 61
    13ba:	de b7       	in	r29, 0x3e	; 62
    13bc:	e9 97       	sbiw	r28, 0x39	; 57
    13be:	0f b6       	in	r0, 0x3f	; 63
    13c0:	f8 94       	cli
    13c2:	de bf       	out	0x3e, r29	; 62
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	cd bf       	out	0x3d, r28	; 61
	ErrorStatus_t Local_enuErrrorState = ERROR_STATUS_FAILURE;
    13c8:	19 ae       	std	Y+57, r1	; 0x39


	/*********************** !Control Pins! ***********************/
	DIO_enuSetPinDirection(RS_PORT, RS_PIN, DIO_u8OUTPUT);
    13ca:	81 e0       	ldi	r24, 0x01	; 1
    13cc:	61 e0       	ldi	r22, 0x01	; 1
    13ce:	41 e0       	ldi	r20, 0x01	; 1
    13d0:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
	DIO_enuSetPinDirection(RS_PORT, RW_PIN, DIO_u8OUTPUT);
    13d4:	81 e0       	ldi	r24, 0x01	; 1
    13d6:	62 e0       	ldi	r22, 0x02	; 2
    13d8:	41 e0       	ldi	r20, 0x01	; 1
    13da:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
	DIO_enuSetPinDirection(RS_PORT, EN_PIN, DIO_u8OUTPUT);
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	63 e0       	ldi	r22, 0x03	; 3
    13e2:	41 e0       	ldi	r20, 0x01	; 1
    13e4:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
	/**************************************************************/


	/************************ !Data  Pins! ************************/
	DIO_enuSetPinDirection(DB7_PORT, DB7_PIN, DIO_u8OUTPUT);
    13e8:	80 e0       	ldi	r24, 0x00	; 0
    13ea:	67 e0       	ldi	r22, 0x07	; 7
    13ec:	41 e0       	ldi	r20, 0x01	; 1
    13ee:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
	DIO_enuSetPinDirection(DB6_PORT, DB6_PIN, DIO_u8OUTPUT);
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	66 e0       	ldi	r22, 0x06	; 6
    13f6:	41 e0       	ldi	r20, 0x01	; 1
    13f8:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
	DIO_enuSetPinDirection(DB5_PORT, DB5_PIN, DIO_u8OUTPUT);
    13fc:	80 e0       	ldi	r24, 0x00	; 0
    13fe:	65 e0       	ldi	r22, 0x05	; 5
    1400:	41 e0       	ldi	r20, 0x01	; 1
    1402:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
	DIO_enuSetPinDirection(DB4_PORT, DB4_PIN, DIO_u8OUTPUT);
    1406:	80 e0       	ldi	r24, 0x00	; 0
    1408:	64 e0       	ldi	r22, 0x04	; 4
    140a:	41 e0       	ldi	r20, 0x01	; 1
    140c:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	90 e0       	ldi	r25, 0x00	; 0
    1414:	ac e0       	ldi	r26, 0x0C	; 12
    1416:	b2 e4       	ldi	r27, 0x42	; 66
    1418:	8d ab       	std	Y+53, r24	; 0x35
    141a:	9e ab       	std	Y+54, r25	; 0x36
    141c:	af ab       	std	Y+55, r26	; 0x37
    141e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1420:	6d a9       	ldd	r22, Y+53	; 0x35
    1422:	7e a9       	ldd	r23, Y+54	; 0x36
    1424:	8f a9       	ldd	r24, Y+55	; 0x37
    1426:	98 ad       	ldd	r25, Y+56	; 0x38
    1428:	20 e0       	ldi	r18, 0x00	; 0
    142a:	30 e0       	ldi	r19, 0x00	; 0
    142c:	4a e7       	ldi	r20, 0x7A	; 122
    142e:	55 e4       	ldi	r21, 0x45	; 69
    1430:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1434:	dc 01       	movw	r26, r24
    1436:	cb 01       	movw	r24, r22
    1438:	89 ab       	std	Y+49, r24	; 0x31
    143a:	9a ab       	std	Y+50, r25	; 0x32
    143c:	ab ab       	std	Y+51, r26	; 0x33
    143e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1440:	69 a9       	ldd	r22, Y+49	; 0x31
    1442:	7a a9       	ldd	r23, Y+50	; 0x32
    1444:	8b a9       	ldd	r24, Y+51	; 0x33
    1446:	9c a9       	ldd	r25, Y+52	; 0x34
    1448:	20 e0       	ldi	r18, 0x00	; 0
    144a:	30 e0       	ldi	r19, 0x00	; 0
    144c:	40 e8       	ldi	r20, 0x80	; 128
    144e:	5f e3       	ldi	r21, 0x3F	; 63
    1450:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1454:	88 23       	and	r24, r24
    1456:	2c f4       	brge	.+10     	; 0x1462 <LCD_enuInit+0xae>
		__ticks = 1;
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	90 e0       	ldi	r25, 0x00	; 0
    145c:	98 ab       	std	Y+48, r25	; 0x30
    145e:	8f a7       	std	Y+47, r24	; 0x2f
    1460:	3f c0       	rjmp	.+126    	; 0x14e0 <LCD_enuInit+0x12c>
	else if (__tmp > 65535)
    1462:	69 a9       	ldd	r22, Y+49	; 0x31
    1464:	7a a9       	ldd	r23, Y+50	; 0x32
    1466:	8b a9       	ldd	r24, Y+51	; 0x33
    1468:	9c a9       	ldd	r25, Y+52	; 0x34
    146a:	20 e0       	ldi	r18, 0x00	; 0
    146c:	3f ef       	ldi	r19, 0xFF	; 255
    146e:	4f e7       	ldi	r20, 0x7F	; 127
    1470:	57 e4       	ldi	r21, 0x47	; 71
    1472:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1476:	18 16       	cp	r1, r24
    1478:	4c f5       	brge	.+82     	; 0x14cc <LCD_enuInit+0x118>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    147a:	6d a9       	ldd	r22, Y+53	; 0x35
    147c:	7e a9       	ldd	r23, Y+54	; 0x36
    147e:	8f a9       	ldd	r24, Y+55	; 0x37
    1480:	98 ad       	ldd	r25, Y+56	; 0x38
    1482:	20 e0       	ldi	r18, 0x00	; 0
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	40 e2       	ldi	r20, 0x20	; 32
    1488:	51 e4       	ldi	r21, 0x41	; 65
    148a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    148e:	dc 01       	movw	r26, r24
    1490:	cb 01       	movw	r24, r22
    1492:	bc 01       	movw	r22, r24
    1494:	cd 01       	movw	r24, r26
    1496:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    149a:	dc 01       	movw	r26, r24
    149c:	cb 01       	movw	r24, r22
    149e:	98 ab       	std	Y+48, r25	; 0x30
    14a0:	8f a7       	std	Y+47, r24	; 0x2f
    14a2:	0f c0       	rjmp	.+30     	; 0x14c2 <LCD_enuInit+0x10e>
    14a4:	80 e9       	ldi	r24, 0x90	; 144
    14a6:	91 e0       	ldi	r25, 0x01	; 1
    14a8:	9e a7       	std	Y+46, r25	; 0x2e
    14aa:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    14ac:	8d a5       	ldd	r24, Y+45	; 0x2d
    14ae:	9e a5       	ldd	r25, Y+46	; 0x2e
    14b0:	01 97       	sbiw	r24, 0x01	; 1
    14b2:	f1 f7       	brne	.-4      	; 0x14b0 <LCD_enuInit+0xfc>
    14b4:	9e a7       	std	Y+46, r25	; 0x2e
    14b6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14b8:	8f a5       	ldd	r24, Y+47	; 0x2f
    14ba:	98 a9       	ldd	r25, Y+48	; 0x30
    14bc:	01 97       	sbiw	r24, 0x01	; 1
    14be:	98 ab       	std	Y+48, r25	; 0x30
    14c0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14c2:	8f a5       	ldd	r24, Y+47	; 0x2f
    14c4:	98 a9       	ldd	r25, Y+48	; 0x30
    14c6:	00 97       	sbiw	r24, 0x00	; 0
    14c8:	69 f7       	brne	.-38     	; 0x14a4 <LCD_enuInit+0xf0>
    14ca:	14 c0       	rjmp	.+40     	; 0x14f4 <LCD_enuInit+0x140>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14cc:	69 a9       	ldd	r22, Y+49	; 0x31
    14ce:	7a a9       	ldd	r23, Y+50	; 0x32
    14d0:	8b a9       	ldd	r24, Y+51	; 0x33
    14d2:	9c a9       	ldd	r25, Y+52	; 0x34
    14d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14d8:	dc 01       	movw	r26, r24
    14da:	cb 01       	movw	r24, r22
    14dc:	98 ab       	std	Y+48, r25	; 0x30
    14de:	8f a7       	std	Y+47, r24	; 0x2f
    14e0:	8f a5       	ldd	r24, Y+47	; 0x2f
    14e2:	98 a9       	ldd	r25, Y+48	; 0x30
    14e4:	9c a7       	std	Y+44, r25	; 0x2c
    14e6:	8b a7       	std	Y+43, r24	; 0x2b
    14e8:	8b a5       	ldd	r24, Y+43	; 0x2b
    14ea:	9c a5       	ldd	r25, Y+44	; 0x2c
    14ec:	01 97       	sbiw	r24, 0x01	; 1
    14ee:	f1 f7       	brne	.-4      	; 0x14ec <LCD_enuInit+0x138>
    14f0:	9c a7       	std	Y+44, r25	; 0x2c
    14f2:	8b a7       	std	Y+43, r24	; 0x2b
		 * 			 (0 - 5x7 dot matrix)
		 * 			 (means 5dot in width and 7dot height)
		 */


			LCD_enuSendCommand(0x20);
    14f4:	80 e2       	ldi	r24, 0x20	; 32
    14f6:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
			LCD_enuSendCommand(0x20);
    14fa:	80 e2       	ldi	r24, 0x20	; 32
    14fc:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
			LCD_enuSendCommand(0x80);
    1500:	80 e8       	ldi	r24, 0x80	; 128
    1502:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
    1506:	80 e0       	ldi	r24, 0x00	; 0
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	a0 e8       	ldi	r26, 0x80	; 128
    150c:	bf e3       	ldi	r27, 0x3F	; 63
    150e:	8f a3       	std	Y+39, r24	; 0x27
    1510:	98 a7       	std	Y+40, r25	; 0x28
    1512:	a9 a7       	std	Y+41, r26	; 0x29
    1514:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1516:	6f a1       	ldd	r22, Y+39	; 0x27
    1518:	78 a5       	ldd	r23, Y+40	; 0x28
    151a:	89 a5       	ldd	r24, Y+41	; 0x29
    151c:	9a a5       	ldd	r25, Y+42	; 0x2a
    151e:	20 e0       	ldi	r18, 0x00	; 0
    1520:	30 e0       	ldi	r19, 0x00	; 0
    1522:	4a e7       	ldi	r20, 0x7A	; 122
    1524:	55 e4       	ldi	r21, 0x45	; 69
    1526:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    152a:	dc 01       	movw	r26, r24
    152c:	cb 01       	movw	r24, r22
    152e:	8b a3       	std	Y+35, r24	; 0x23
    1530:	9c a3       	std	Y+36, r25	; 0x24
    1532:	ad a3       	std	Y+37, r26	; 0x25
    1534:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1536:	6b a1       	ldd	r22, Y+35	; 0x23
    1538:	7c a1       	ldd	r23, Y+36	; 0x24
    153a:	8d a1       	ldd	r24, Y+37	; 0x25
    153c:	9e a1       	ldd	r25, Y+38	; 0x26
    153e:	20 e0       	ldi	r18, 0x00	; 0
    1540:	30 e0       	ldi	r19, 0x00	; 0
    1542:	40 e8       	ldi	r20, 0x80	; 128
    1544:	5f e3       	ldi	r21, 0x3F	; 63
    1546:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    154a:	88 23       	and	r24, r24
    154c:	2c f4       	brge	.+10     	; 0x1558 <LCD_enuInit+0x1a4>
		__ticks = 1;
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	9a a3       	std	Y+34, r25	; 0x22
    1554:	89 a3       	std	Y+33, r24	; 0x21
    1556:	3f c0       	rjmp	.+126    	; 0x15d6 <LCD_enuInit+0x222>
	else if (__tmp > 65535)
    1558:	6b a1       	ldd	r22, Y+35	; 0x23
    155a:	7c a1       	ldd	r23, Y+36	; 0x24
    155c:	8d a1       	ldd	r24, Y+37	; 0x25
    155e:	9e a1       	ldd	r25, Y+38	; 0x26
    1560:	20 e0       	ldi	r18, 0x00	; 0
    1562:	3f ef       	ldi	r19, 0xFF	; 255
    1564:	4f e7       	ldi	r20, 0x7F	; 127
    1566:	57 e4       	ldi	r21, 0x47	; 71
    1568:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    156c:	18 16       	cp	r1, r24
    156e:	4c f5       	brge	.+82     	; 0x15c2 <LCD_enuInit+0x20e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1570:	6f a1       	ldd	r22, Y+39	; 0x27
    1572:	78 a5       	ldd	r23, Y+40	; 0x28
    1574:	89 a5       	ldd	r24, Y+41	; 0x29
    1576:	9a a5       	ldd	r25, Y+42	; 0x2a
    1578:	20 e0       	ldi	r18, 0x00	; 0
    157a:	30 e0       	ldi	r19, 0x00	; 0
    157c:	40 e2       	ldi	r20, 0x20	; 32
    157e:	51 e4       	ldi	r21, 0x41	; 65
    1580:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1584:	dc 01       	movw	r26, r24
    1586:	cb 01       	movw	r24, r22
    1588:	bc 01       	movw	r22, r24
    158a:	cd 01       	movw	r24, r26
    158c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1590:	dc 01       	movw	r26, r24
    1592:	cb 01       	movw	r24, r22
    1594:	9a a3       	std	Y+34, r25	; 0x22
    1596:	89 a3       	std	Y+33, r24	; 0x21
    1598:	0f c0       	rjmp	.+30     	; 0x15b8 <LCD_enuInit+0x204>
    159a:	80 e9       	ldi	r24, 0x90	; 144
    159c:	91 e0       	ldi	r25, 0x01	; 1
    159e:	98 a3       	std	Y+32, r25	; 0x20
    15a0:	8f 8f       	std	Y+31, r24	; 0x1f
    15a2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    15a4:	98 a1       	ldd	r25, Y+32	; 0x20
    15a6:	01 97       	sbiw	r24, 0x01	; 1
    15a8:	f1 f7       	brne	.-4      	; 0x15a6 <LCD_enuInit+0x1f2>
    15aa:	98 a3       	std	Y+32, r25	; 0x20
    15ac:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15ae:	89 a1       	ldd	r24, Y+33	; 0x21
    15b0:	9a a1       	ldd	r25, Y+34	; 0x22
    15b2:	01 97       	sbiw	r24, 0x01	; 1
    15b4:	9a a3       	std	Y+34, r25	; 0x22
    15b6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15b8:	89 a1       	ldd	r24, Y+33	; 0x21
    15ba:	9a a1       	ldd	r25, Y+34	; 0x22
    15bc:	00 97       	sbiw	r24, 0x00	; 0
    15be:	69 f7       	brne	.-38     	; 0x159a <LCD_enuInit+0x1e6>
    15c0:	14 c0       	rjmp	.+40     	; 0x15ea <LCD_enuInit+0x236>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15c2:	6b a1       	ldd	r22, Y+35	; 0x23
    15c4:	7c a1       	ldd	r23, Y+36	; 0x24
    15c6:	8d a1       	ldd	r24, Y+37	; 0x25
    15c8:	9e a1       	ldd	r25, Y+38	; 0x26
    15ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15ce:	dc 01       	movw	r26, r24
    15d0:	cb 01       	movw	r24, r22
    15d2:	9a a3       	std	Y+34, r25	; 0x22
    15d4:	89 a3       	std	Y+33, r24	; 0x21
    15d6:	89 a1       	ldd	r24, Y+33	; 0x21
    15d8:	9a a1       	ldd	r25, Y+34	; 0x22
    15da:	9e 8f       	std	Y+30, r25	; 0x1e
    15dc:	8d 8f       	std	Y+29, r24	; 0x1d
    15de:	8d 8d       	ldd	r24, Y+29	; 0x1d
    15e0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    15e2:	01 97       	sbiw	r24, 0x01	; 1
    15e4:	f1 f7       	brne	.-4      	; 0x15e2 <LCD_enuInit+0x22e>
    15e6:	9e 8f       	std	Y+30, r25	; 0x1e
    15e8:	8d 8f       	std	Y+29, r24	; 0x1d
			 * B - Control Blinking of cursor position
			 * x - don't care
			 */


			  LCD_enuSendCommand(0x00);
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
			  LCD_enuSendCommand(0xF0);
    15f0:	80 ef       	ldi	r24, 0xF0	; 240
    15f2:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	a0 e8       	ldi	r26, 0x80	; 128
    15fc:	bf e3       	ldi	r27, 0x3F	; 63
    15fe:	89 8f       	std	Y+25, r24	; 0x19
    1600:	9a 8f       	std	Y+26, r25	; 0x1a
    1602:	ab 8f       	std	Y+27, r26	; 0x1b
    1604:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1606:	69 8d       	ldd	r22, Y+25	; 0x19
    1608:	7a 8d       	ldd	r23, Y+26	; 0x1a
    160a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    160c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    160e:	20 e0       	ldi	r18, 0x00	; 0
    1610:	30 e0       	ldi	r19, 0x00	; 0
    1612:	4a e7       	ldi	r20, 0x7A	; 122
    1614:	55 e4       	ldi	r21, 0x45	; 69
    1616:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    161a:	dc 01       	movw	r26, r24
    161c:	cb 01       	movw	r24, r22
    161e:	8d 8b       	std	Y+21, r24	; 0x15
    1620:	9e 8b       	std	Y+22, r25	; 0x16
    1622:	af 8b       	std	Y+23, r26	; 0x17
    1624:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1626:	6d 89       	ldd	r22, Y+21	; 0x15
    1628:	7e 89       	ldd	r23, Y+22	; 0x16
    162a:	8f 89       	ldd	r24, Y+23	; 0x17
    162c:	98 8d       	ldd	r25, Y+24	; 0x18
    162e:	20 e0       	ldi	r18, 0x00	; 0
    1630:	30 e0       	ldi	r19, 0x00	; 0
    1632:	40 e8       	ldi	r20, 0x80	; 128
    1634:	5f e3       	ldi	r21, 0x3F	; 63
    1636:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    163a:	88 23       	and	r24, r24
    163c:	2c f4       	brge	.+10     	; 0x1648 <LCD_enuInit+0x294>
		__ticks = 1;
    163e:	81 e0       	ldi	r24, 0x01	; 1
    1640:	90 e0       	ldi	r25, 0x00	; 0
    1642:	9c 8b       	std	Y+20, r25	; 0x14
    1644:	8b 8b       	std	Y+19, r24	; 0x13
    1646:	3f c0       	rjmp	.+126    	; 0x16c6 <LCD_enuInit+0x312>
	else if (__tmp > 65535)
    1648:	6d 89       	ldd	r22, Y+21	; 0x15
    164a:	7e 89       	ldd	r23, Y+22	; 0x16
    164c:	8f 89       	ldd	r24, Y+23	; 0x17
    164e:	98 8d       	ldd	r25, Y+24	; 0x18
    1650:	20 e0       	ldi	r18, 0x00	; 0
    1652:	3f ef       	ldi	r19, 0xFF	; 255
    1654:	4f e7       	ldi	r20, 0x7F	; 127
    1656:	57 e4       	ldi	r21, 0x47	; 71
    1658:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    165c:	18 16       	cp	r1, r24
    165e:	4c f5       	brge	.+82     	; 0x16b2 <LCD_enuInit+0x2fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1660:	69 8d       	ldd	r22, Y+25	; 0x19
    1662:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1664:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1666:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1668:	20 e0       	ldi	r18, 0x00	; 0
    166a:	30 e0       	ldi	r19, 0x00	; 0
    166c:	40 e2       	ldi	r20, 0x20	; 32
    166e:	51 e4       	ldi	r21, 0x41	; 65
    1670:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1674:	dc 01       	movw	r26, r24
    1676:	cb 01       	movw	r24, r22
    1678:	bc 01       	movw	r22, r24
    167a:	cd 01       	movw	r24, r26
    167c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1680:	dc 01       	movw	r26, r24
    1682:	cb 01       	movw	r24, r22
    1684:	9c 8b       	std	Y+20, r25	; 0x14
    1686:	8b 8b       	std	Y+19, r24	; 0x13
    1688:	0f c0       	rjmp	.+30     	; 0x16a8 <LCD_enuInit+0x2f4>
    168a:	80 e9       	ldi	r24, 0x90	; 144
    168c:	91 e0       	ldi	r25, 0x01	; 1
    168e:	9a 8b       	std	Y+18, r25	; 0x12
    1690:	89 8b       	std	Y+17, r24	; 0x11
    1692:	89 89       	ldd	r24, Y+17	; 0x11
    1694:	9a 89       	ldd	r25, Y+18	; 0x12
    1696:	01 97       	sbiw	r24, 0x01	; 1
    1698:	f1 f7       	brne	.-4      	; 0x1696 <LCD_enuInit+0x2e2>
    169a:	9a 8b       	std	Y+18, r25	; 0x12
    169c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    169e:	8b 89       	ldd	r24, Y+19	; 0x13
    16a0:	9c 89       	ldd	r25, Y+20	; 0x14
    16a2:	01 97       	sbiw	r24, 0x01	; 1
    16a4:	9c 8b       	std	Y+20, r25	; 0x14
    16a6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16a8:	8b 89       	ldd	r24, Y+19	; 0x13
    16aa:	9c 89       	ldd	r25, Y+20	; 0x14
    16ac:	00 97       	sbiw	r24, 0x00	; 0
    16ae:	69 f7       	brne	.-38     	; 0x168a <LCD_enuInit+0x2d6>
    16b0:	14 c0       	rjmp	.+40     	; 0x16da <LCD_enuInit+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16b2:	6d 89       	ldd	r22, Y+21	; 0x15
    16b4:	7e 89       	ldd	r23, Y+22	; 0x16
    16b6:	8f 89       	ldd	r24, Y+23	; 0x17
    16b8:	98 8d       	ldd	r25, Y+24	; 0x18
    16ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16be:	dc 01       	movw	r26, r24
    16c0:	cb 01       	movw	r24, r22
    16c2:	9c 8b       	std	Y+20, r25	; 0x14
    16c4:	8b 8b       	std	Y+19, r24	; 0x13
    16c6:	8b 89       	ldd	r24, Y+19	; 0x13
    16c8:	9c 89       	ldd	r25, Y+20	; 0x14
    16ca:	98 8b       	std	Y+16, r25	; 0x10
    16cc:	8f 87       	std	Y+15, r24	; 0x0f
    16ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    16d0:	98 89       	ldd	r25, Y+16	; 0x10
    16d2:	01 97       	sbiw	r24, 0x01	; 1
    16d4:	f1 f7       	brne	.-4      	; 0x16d2 <LCD_enuInit+0x31e>
    16d6:	98 8b       	std	Y+16, r25	; 0x10
    16d8:	8f 87       	std	Y+15, r24	; 0x0f
			  _delay_ms(DISPLAY_ON_OFF_CONTROL);
		/**************************************************************/


		/******************* !Display CLEAR! *******************/
		LCD_enuSendCommand(0x00);
    16da:	80 e0       	ldi	r24, 0x00	; 0
    16dc:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
		LCD_enuSendCommand(CLEAR);
    16e0:	81 e0       	ldi	r24, 0x01	; 1
    16e2:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
    16e6:	80 e0       	ldi	r24, 0x00	; 0
    16e8:	90 e0       	ldi	r25, 0x00	; 0
    16ea:	a0 e0       	ldi	r26, 0x00	; 0
    16ec:	b0 e4       	ldi	r27, 0x40	; 64
    16ee:	8b 87       	std	Y+11, r24	; 0x0b
    16f0:	9c 87       	std	Y+12, r25	; 0x0c
    16f2:	ad 87       	std	Y+13, r26	; 0x0d
    16f4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    16f6:	6b 85       	ldd	r22, Y+11	; 0x0b
    16f8:	7c 85       	ldd	r23, Y+12	; 0x0c
    16fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    16fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    16fe:	20 e0       	ldi	r18, 0x00	; 0
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	4a e7       	ldi	r20, 0x7A	; 122
    1704:	55 e4       	ldi	r21, 0x45	; 69
    1706:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    170a:	dc 01       	movw	r26, r24
    170c:	cb 01       	movw	r24, r22
    170e:	8f 83       	std	Y+7, r24	; 0x07
    1710:	98 87       	std	Y+8, r25	; 0x08
    1712:	a9 87       	std	Y+9, r26	; 0x09
    1714:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1716:	6f 81       	ldd	r22, Y+7	; 0x07
    1718:	78 85       	ldd	r23, Y+8	; 0x08
    171a:	89 85       	ldd	r24, Y+9	; 0x09
    171c:	9a 85       	ldd	r25, Y+10	; 0x0a
    171e:	20 e0       	ldi	r18, 0x00	; 0
    1720:	30 e0       	ldi	r19, 0x00	; 0
    1722:	40 e8       	ldi	r20, 0x80	; 128
    1724:	5f e3       	ldi	r21, 0x3F	; 63
    1726:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    172a:	88 23       	and	r24, r24
    172c:	2c f4       	brge	.+10     	; 0x1738 <LCD_enuInit+0x384>
		__ticks = 1;
    172e:	81 e0       	ldi	r24, 0x01	; 1
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	9e 83       	std	Y+6, r25	; 0x06
    1734:	8d 83       	std	Y+5, r24	; 0x05
    1736:	3f c0       	rjmp	.+126    	; 0x17b6 <LCD_enuInit+0x402>
	else if (__tmp > 65535)
    1738:	6f 81       	ldd	r22, Y+7	; 0x07
    173a:	78 85       	ldd	r23, Y+8	; 0x08
    173c:	89 85       	ldd	r24, Y+9	; 0x09
    173e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1740:	20 e0       	ldi	r18, 0x00	; 0
    1742:	3f ef       	ldi	r19, 0xFF	; 255
    1744:	4f e7       	ldi	r20, 0x7F	; 127
    1746:	57 e4       	ldi	r21, 0x47	; 71
    1748:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    174c:	18 16       	cp	r1, r24
    174e:	4c f5       	brge	.+82     	; 0x17a2 <LCD_enuInit+0x3ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1750:	6b 85       	ldd	r22, Y+11	; 0x0b
    1752:	7c 85       	ldd	r23, Y+12	; 0x0c
    1754:	8d 85       	ldd	r24, Y+13	; 0x0d
    1756:	9e 85       	ldd	r25, Y+14	; 0x0e
    1758:	20 e0       	ldi	r18, 0x00	; 0
    175a:	30 e0       	ldi	r19, 0x00	; 0
    175c:	40 e2       	ldi	r20, 0x20	; 32
    175e:	51 e4       	ldi	r21, 0x41	; 65
    1760:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1764:	dc 01       	movw	r26, r24
    1766:	cb 01       	movw	r24, r22
    1768:	bc 01       	movw	r22, r24
    176a:	cd 01       	movw	r24, r26
    176c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1770:	dc 01       	movw	r26, r24
    1772:	cb 01       	movw	r24, r22
    1774:	9e 83       	std	Y+6, r25	; 0x06
    1776:	8d 83       	std	Y+5, r24	; 0x05
    1778:	0f c0       	rjmp	.+30     	; 0x1798 <LCD_enuInit+0x3e4>
    177a:	80 e9       	ldi	r24, 0x90	; 144
    177c:	91 e0       	ldi	r25, 0x01	; 1
    177e:	9c 83       	std	Y+4, r25	; 0x04
    1780:	8b 83       	std	Y+3, r24	; 0x03
    1782:	8b 81       	ldd	r24, Y+3	; 0x03
    1784:	9c 81       	ldd	r25, Y+4	; 0x04
    1786:	01 97       	sbiw	r24, 0x01	; 1
    1788:	f1 f7       	brne	.-4      	; 0x1786 <LCD_enuInit+0x3d2>
    178a:	9c 83       	std	Y+4, r25	; 0x04
    178c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    178e:	8d 81       	ldd	r24, Y+5	; 0x05
    1790:	9e 81       	ldd	r25, Y+6	; 0x06
    1792:	01 97       	sbiw	r24, 0x01	; 1
    1794:	9e 83       	std	Y+6, r25	; 0x06
    1796:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1798:	8d 81       	ldd	r24, Y+5	; 0x05
    179a:	9e 81       	ldd	r25, Y+6	; 0x06
    179c:	00 97       	sbiw	r24, 0x00	; 0
    179e:	69 f7       	brne	.-38     	; 0x177a <LCD_enuInit+0x3c6>
    17a0:	14 c0       	rjmp	.+40     	; 0x17ca <LCD_enuInit+0x416>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17a2:	6f 81       	ldd	r22, Y+7	; 0x07
    17a4:	78 85       	ldd	r23, Y+8	; 0x08
    17a6:	89 85       	ldd	r24, Y+9	; 0x09
    17a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    17aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17ae:	dc 01       	movw	r26, r24
    17b0:	cb 01       	movw	r24, r22
    17b2:	9e 83       	std	Y+6, r25	; 0x06
    17b4:	8d 83       	std	Y+5, r24	; 0x05
    17b6:	8d 81       	ldd	r24, Y+5	; 0x05
    17b8:	9e 81       	ldd	r25, Y+6	; 0x06
    17ba:	9a 83       	std	Y+2, r25	; 0x02
    17bc:	89 83       	std	Y+1, r24	; 0x01
    17be:	89 81       	ldd	r24, Y+1	; 0x01
    17c0:	9a 81       	ldd	r25, Y+2	; 0x02
    17c2:	01 97       	sbiw	r24, 0x01	; 1
    17c4:	f1 f7       	brne	.-4      	; 0x17c2 <LCD_enuInit+0x40e>
    17c6:	9a 83       	std	Y+2, r25	; 0x02
    17c8:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(DISPLAY_CLEAR_DELAY);
		/*******************************************************/


	    /******************* !Entry Mode Set! *******************/
	    LCD_enuSendCommand(0x00);
    17ca:	80 e0       	ldi	r24, 0x00	; 0
    17cc:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
	    LCD_enuSendCommand(0b00000110);
    17d0:	86 e0       	ldi	r24, 0x06	; 6
    17d2:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
		#warning "LCD_MODE Macro is not defined"
		return Local_enuErrrorState;
	#endif

	#if(LCD_MODE == FOUR_BIT)
		Global_u8FourBitInitFlag=1;
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	80 93 a8 00 	sts	0x00A8, r24





		Local_enuErrrorState = ERROR_STATUS_OK;
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	89 af       	std	Y+57, r24	; 0x39
	return Local_enuErrrorState;
    17e0:	89 ad       	ldd	r24, Y+57	; 0x39
}
    17e2:	e9 96       	adiw	r28, 0x39	; 57
    17e4:	0f b6       	in	r0, 0x3f	; 63
    17e6:	f8 94       	cli
    17e8:	de bf       	out	0x3e, r29	; 62
    17ea:	0f be       	out	0x3f, r0	; 63
    17ec:	cd bf       	out	0x3d, r28	; 61
    17ee:	cf 91       	pop	r28
    17f0:	df 91       	pop	r29
    17f2:	08 95       	ret

000017f4 <WriteNLatch>:





static ErrorStatus_t WriteNLatch(uint8_t Copy_u8Data){
    17f4:	df 93       	push	r29
    17f6:	cf 93       	push	r28
    17f8:	cd b7       	in	r28, 0x3d	; 61
    17fa:	de b7       	in	r29, 0x3e	; 62
    17fc:	6e 97       	sbiw	r28, 0x1e	; 30
    17fe:	0f b6       	in	r0, 0x3f	; 63
    1800:	f8 94       	cli
    1802:	de bf       	out	0x3e, r29	; 62
    1804:	0f be       	out	0x3f, r0	; 63
    1806:	cd bf       	out	0x3d, r28	; 61
    1808:	8e 8f       	std	Y+30, r24	; 0x1e

    ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
    180a:	1d 8e       	std	Y+29, r1	; 0x1d

    #if(LCD_MODE == FOUR_BIT)

        // Send Higher Nibble
        DIO_enuSetPinValue(LCD_DATA_PORT, DB4_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_5));
    180c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    180e:	82 95       	swap	r24
    1810:	8f 70       	andi	r24, 0x0F	; 15
    1812:	98 2f       	mov	r25, r24
    1814:	91 70       	andi	r25, 0x01	; 1
    1816:	80 e0       	ldi	r24, 0x00	; 0
    1818:	64 e0       	ldi	r22, 0x04	; 4
    181a:	49 2f       	mov	r20, r25
    181c:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        DIO_enuSetPinValue(LCD_DATA_PORT, DB5_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_6));
    1820:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1822:	82 95       	swap	r24
    1824:	86 95       	lsr	r24
    1826:	87 70       	andi	r24, 0x07	; 7
    1828:	98 2f       	mov	r25, r24
    182a:	91 70       	andi	r25, 0x01	; 1
    182c:	80 e0       	ldi	r24, 0x00	; 0
    182e:	65 e0       	ldi	r22, 0x05	; 5
    1830:	49 2f       	mov	r20, r25
    1832:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        DIO_enuSetPinValue(LCD_DATA_PORT, DB6_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_7));
    1836:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1838:	82 95       	swap	r24
    183a:	86 95       	lsr	r24
    183c:	86 95       	lsr	r24
    183e:	83 70       	andi	r24, 0x03	; 3
    1840:	98 2f       	mov	r25, r24
    1842:	91 70       	andi	r25, 0x01	; 1
    1844:	80 e0       	ldi	r24, 0x00	; 0
    1846:	66 e0       	ldi	r22, 0x06	; 6
    1848:	49 2f       	mov	r20, r25
    184a:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        DIO_enuSetPinValue(LCD_DATA_PORT, DB7_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_8));
    184e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1850:	98 2f       	mov	r25, r24
    1852:	99 1f       	adc	r25, r25
    1854:	99 27       	eor	r25, r25
    1856:	99 1f       	adc	r25, r25
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	67 e0       	ldi	r22, 0x07	; 7
    185c:	49 2f       	mov	r20, r25
    185e:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>

        SEND_ENABLE_PULSE();
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	63 e0       	ldi	r22, 0x03	; 3
    1866:	41 e0       	ldi	r20, 0x01	; 1
    1868:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
    186c:	80 e0       	ldi	r24, 0x00	; 0
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	a0 e0       	ldi	r26, 0x00	; 0
    1872:	b0 e4       	ldi	r27, 0x40	; 64
    1874:	89 8f       	std	Y+25, r24	; 0x19
    1876:	9a 8f       	std	Y+26, r25	; 0x1a
    1878:	ab 8f       	std	Y+27, r26	; 0x1b
    187a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    187c:	69 8d       	ldd	r22, Y+25	; 0x19
    187e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1880:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1882:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1884:	20 e0       	ldi	r18, 0x00	; 0
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	4a e7       	ldi	r20, 0x7A	; 122
    188a:	55 e4       	ldi	r21, 0x45	; 69
    188c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1890:	dc 01       	movw	r26, r24
    1892:	cb 01       	movw	r24, r22
    1894:	8d 8b       	std	Y+21, r24	; 0x15
    1896:	9e 8b       	std	Y+22, r25	; 0x16
    1898:	af 8b       	std	Y+23, r26	; 0x17
    189a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    189c:	6d 89       	ldd	r22, Y+21	; 0x15
    189e:	7e 89       	ldd	r23, Y+22	; 0x16
    18a0:	8f 89       	ldd	r24, Y+23	; 0x17
    18a2:	98 8d       	ldd	r25, Y+24	; 0x18
    18a4:	20 e0       	ldi	r18, 0x00	; 0
    18a6:	30 e0       	ldi	r19, 0x00	; 0
    18a8:	40 e8       	ldi	r20, 0x80	; 128
    18aa:	5f e3       	ldi	r21, 0x3F	; 63
    18ac:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    18b0:	88 23       	and	r24, r24
    18b2:	2c f4       	brge	.+10     	; 0x18be <WriteNLatch+0xca>
		__ticks = 1;
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	9c 8b       	std	Y+20, r25	; 0x14
    18ba:	8b 8b       	std	Y+19, r24	; 0x13
    18bc:	3f c0       	rjmp	.+126    	; 0x193c <WriteNLatch+0x148>
	else if (__tmp > 65535)
    18be:	6d 89       	ldd	r22, Y+21	; 0x15
    18c0:	7e 89       	ldd	r23, Y+22	; 0x16
    18c2:	8f 89       	ldd	r24, Y+23	; 0x17
    18c4:	98 8d       	ldd	r25, Y+24	; 0x18
    18c6:	20 e0       	ldi	r18, 0x00	; 0
    18c8:	3f ef       	ldi	r19, 0xFF	; 255
    18ca:	4f e7       	ldi	r20, 0x7F	; 127
    18cc:	57 e4       	ldi	r21, 0x47	; 71
    18ce:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    18d2:	18 16       	cp	r1, r24
    18d4:	4c f5       	brge	.+82     	; 0x1928 <WriteNLatch+0x134>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    18d6:	69 8d       	ldd	r22, Y+25	; 0x19
    18d8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    18da:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18dc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18de:	20 e0       	ldi	r18, 0x00	; 0
    18e0:	30 e0       	ldi	r19, 0x00	; 0
    18e2:	40 e2       	ldi	r20, 0x20	; 32
    18e4:	51 e4       	ldi	r21, 0x41	; 65
    18e6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18ea:	dc 01       	movw	r26, r24
    18ec:	cb 01       	movw	r24, r22
    18ee:	bc 01       	movw	r22, r24
    18f0:	cd 01       	movw	r24, r26
    18f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18f6:	dc 01       	movw	r26, r24
    18f8:	cb 01       	movw	r24, r22
    18fa:	9c 8b       	std	Y+20, r25	; 0x14
    18fc:	8b 8b       	std	Y+19, r24	; 0x13
    18fe:	0f c0       	rjmp	.+30     	; 0x191e <WriteNLatch+0x12a>
    1900:	80 e9       	ldi	r24, 0x90	; 144
    1902:	91 e0       	ldi	r25, 0x01	; 1
    1904:	9a 8b       	std	Y+18, r25	; 0x12
    1906:	89 8b       	std	Y+17, r24	; 0x11
    1908:	89 89       	ldd	r24, Y+17	; 0x11
    190a:	9a 89       	ldd	r25, Y+18	; 0x12
    190c:	01 97       	sbiw	r24, 0x01	; 1
    190e:	f1 f7       	brne	.-4      	; 0x190c <WriteNLatch+0x118>
    1910:	9a 8b       	std	Y+18, r25	; 0x12
    1912:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1914:	8b 89       	ldd	r24, Y+19	; 0x13
    1916:	9c 89       	ldd	r25, Y+20	; 0x14
    1918:	01 97       	sbiw	r24, 0x01	; 1
    191a:	9c 8b       	std	Y+20, r25	; 0x14
    191c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    191e:	8b 89       	ldd	r24, Y+19	; 0x13
    1920:	9c 89       	ldd	r25, Y+20	; 0x14
    1922:	00 97       	sbiw	r24, 0x00	; 0
    1924:	69 f7       	brne	.-38     	; 0x1900 <WriteNLatch+0x10c>
    1926:	14 c0       	rjmp	.+40     	; 0x1950 <WriteNLatch+0x15c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1928:	6d 89       	ldd	r22, Y+21	; 0x15
    192a:	7e 89       	ldd	r23, Y+22	; 0x16
    192c:	8f 89       	ldd	r24, Y+23	; 0x17
    192e:	98 8d       	ldd	r25, Y+24	; 0x18
    1930:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1934:	dc 01       	movw	r26, r24
    1936:	cb 01       	movw	r24, r22
    1938:	9c 8b       	std	Y+20, r25	; 0x14
    193a:	8b 8b       	std	Y+19, r24	; 0x13
    193c:	8b 89       	ldd	r24, Y+19	; 0x13
    193e:	9c 89       	ldd	r25, Y+20	; 0x14
    1940:	98 8b       	std	Y+16, r25	; 0x10
    1942:	8f 87       	std	Y+15, r24	; 0x0f
    1944:	8f 85       	ldd	r24, Y+15	; 0x0f
    1946:	98 89       	ldd	r25, Y+16	; 0x10
    1948:	01 97       	sbiw	r24, 0x01	; 1
    194a:	f1 f7       	brne	.-4      	; 0x1948 <WriteNLatch+0x154>
    194c:	98 8b       	std	Y+16, r25	; 0x10
    194e:	8f 87       	std	Y+15, r24	; 0x0f
    1950:	81 e0       	ldi	r24, 0x01	; 1
    1952:	63 e0       	ldi	r22, 0x03	; 3
    1954:	40 e0       	ldi	r20, 0x00	; 0
    1956:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>

        if(Global_u8FourBitInitFlag){
    195a:	80 91 a8 00 	lds	r24, 0x00A8
    195e:	88 23       	and	r24, r24
    1960:	09 f4       	brne	.+2      	; 0x1964 <WriteNLatch+0x170>
    1962:	a2 c0       	rjmp	.+324    	; 0x1aa8 <WriteNLatch+0x2b4>
        // Send Lower Nibble
        	DIO_enuSetPinValue(LCD_DATA_PORT, DB4_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_1));
    1964:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1966:	98 2f       	mov	r25, r24
    1968:	91 70       	andi	r25, 0x01	; 1
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	64 e0       	ldi	r22, 0x04	; 4
    196e:	49 2f       	mov	r20, r25
    1970:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        	DIO_enuSetPinValue(LCD_DATA_PORT, DB5_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_2));
    1974:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1976:	86 95       	lsr	r24
    1978:	98 2f       	mov	r25, r24
    197a:	91 70       	andi	r25, 0x01	; 1
    197c:	80 e0       	ldi	r24, 0x00	; 0
    197e:	65 e0       	ldi	r22, 0x05	; 5
    1980:	49 2f       	mov	r20, r25
    1982:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        	DIO_enuSetPinValue(LCD_DATA_PORT, DB6_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_3));
    1986:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1988:	86 95       	lsr	r24
    198a:	86 95       	lsr	r24
    198c:	98 2f       	mov	r25, r24
    198e:	91 70       	andi	r25, 0x01	; 1
    1990:	80 e0       	ldi	r24, 0x00	; 0
    1992:	66 e0       	ldi	r22, 0x06	; 6
    1994:	49 2f       	mov	r20, r25
    1996:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        	DIO_enuSetPinValue(LCD_DATA_PORT, DB7_PIN, GET_BIT(Copy_u8Data, LCD_DATA_BIT_4));
    199a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    199c:	86 95       	lsr	r24
    199e:	86 95       	lsr	r24
    19a0:	86 95       	lsr	r24
    19a2:	98 2f       	mov	r25, r24
    19a4:	91 70       	andi	r25, 0x01	; 1
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	67 e0       	ldi	r22, 0x07	; 7
    19aa:	49 2f       	mov	r20, r25
    19ac:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>

        	SEND_ENABLE_PULSE();
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	63 e0       	ldi	r22, 0x03	; 3
    19b4:	41 e0       	ldi	r20, 0x01	; 1
    19b6:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	a0 e0       	ldi	r26, 0x00	; 0
    19c0:	b0 e4       	ldi	r27, 0x40	; 64
    19c2:	8b 87       	std	Y+11, r24	; 0x0b
    19c4:	9c 87       	std	Y+12, r25	; 0x0c
    19c6:	ad 87       	std	Y+13, r26	; 0x0d
    19c8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19ca:	6b 85       	ldd	r22, Y+11	; 0x0b
    19cc:	7c 85       	ldd	r23, Y+12	; 0x0c
    19ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    19d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    19d2:	20 e0       	ldi	r18, 0x00	; 0
    19d4:	30 e0       	ldi	r19, 0x00	; 0
    19d6:	4a e7       	ldi	r20, 0x7A	; 122
    19d8:	55 e4       	ldi	r21, 0x45	; 69
    19da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19de:	dc 01       	movw	r26, r24
    19e0:	cb 01       	movw	r24, r22
    19e2:	8f 83       	std	Y+7, r24	; 0x07
    19e4:	98 87       	std	Y+8, r25	; 0x08
    19e6:	a9 87       	std	Y+9, r26	; 0x09
    19e8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    19ea:	6f 81       	ldd	r22, Y+7	; 0x07
    19ec:	78 85       	ldd	r23, Y+8	; 0x08
    19ee:	89 85       	ldd	r24, Y+9	; 0x09
    19f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    19f2:	20 e0       	ldi	r18, 0x00	; 0
    19f4:	30 e0       	ldi	r19, 0x00	; 0
    19f6:	40 e8       	ldi	r20, 0x80	; 128
    19f8:	5f e3       	ldi	r21, 0x3F	; 63
    19fa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    19fe:	88 23       	and	r24, r24
    1a00:	2c f4       	brge	.+10     	; 0x1a0c <WriteNLatch+0x218>
		__ticks = 1;
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	9e 83       	std	Y+6, r25	; 0x06
    1a08:	8d 83       	std	Y+5, r24	; 0x05
    1a0a:	3f c0       	rjmp	.+126    	; 0x1a8a <WriteNLatch+0x296>
	else if (__tmp > 65535)
    1a0c:	6f 81       	ldd	r22, Y+7	; 0x07
    1a0e:	78 85       	ldd	r23, Y+8	; 0x08
    1a10:	89 85       	ldd	r24, Y+9	; 0x09
    1a12:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a14:	20 e0       	ldi	r18, 0x00	; 0
    1a16:	3f ef       	ldi	r19, 0xFF	; 255
    1a18:	4f e7       	ldi	r20, 0x7F	; 127
    1a1a:	57 e4       	ldi	r21, 0x47	; 71
    1a1c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a20:	18 16       	cp	r1, r24
    1a22:	4c f5       	brge	.+82     	; 0x1a76 <WriteNLatch+0x282>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a24:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a26:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a28:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a2c:	20 e0       	ldi	r18, 0x00	; 0
    1a2e:	30 e0       	ldi	r19, 0x00	; 0
    1a30:	40 e2       	ldi	r20, 0x20	; 32
    1a32:	51 e4       	ldi	r21, 0x41	; 65
    1a34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a38:	dc 01       	movw	r26, r24
    1a3a:	cb 01       	movw	r24, r22
    1a3c:	bc 01       	movw	r22, r24
    1a3e:	cd 01       	movw	r24, r26
    1a40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a44:	dc 01       	movw	r26, r24
    1a46:	cb 01       	movw	r24, r22
    1a48:	9e 83       	std	Y+6, r25	; 0x06
    1a4a:	8d 83       	std	Y+5, r24	; 0x05
    1a4c:	0f c0       	rjmp	.+30     	; 0x1a6c <WriteNLatch+0x278>
    1a4e:	80 e9       	ldi	r24, 0x90	; 144
    1a50:	91 e0       	ldi	r25, 0x01	; 1
    1a52:	9c 83       	std	Y+4, r25	; 0x04
    1a54:	8b 83       	std	Y+3, r24	; 0x03
    1a56:	8b 81       	ldd	r24, Y+3	; 0x03
    1a58:	9c 81       	ldd	r25, Y+4	; 0x04
    1a5a:	01 97       	sbiw	r24, 0x01	; 1
    1a5c:	f1 f7       	brne	.-4      	; 0x1a5a <WriteNLatch+0x266>
    1a5e:	9c 83       	std	Y+4, r25	; 0x04
    1a60:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a62:	8d 81       	ldd	r24, Y+5	; 0x05
    1a64:	9e 81       	ldd	r25, Y+6	; 0x06
    1a66:	01 97       	sbiw	r24, 0x01	; 1
    1a68:	9e 83       	std	Y+6, r25	; 0x06
    1a6a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a70:	00 97       	sbiw	r24, 0x00	; 0
    1a72:	69 f7       	brne	.-38     	; 0x1a4e <WriteNLatch+0x25a>
    1a74:	14 c0       	rjmp	.+40     	; 0x1a9e <WriteNLatch+0x2aa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a76:	6f 81       	ldd	r22, Y+7	; 0x07
    1a78:	78 85       	ldd	r23, Y+8	; 0x08
    1a7a:	89 85       	ldd	r24, Y+9	; 0x09
    1a7c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a7e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a82:	dc 01       	movw	r26, r24
    1a84:	cb 01       	movw	r24, r22
    1a86:	9e 83       	std	Y+6, r25	; 0x06
    1a88:	8d 83       	std	Y+5, r24	; 0x05
    1a8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a8e:	9a 83       	std	Y+2, r25	; 0x02
    1a90:	89 83       	std	Y+1, r24	; 0x01
    1a92:	89 81       	ldd	r24, Y+1	; 0x01
    1a94:	9a 81       	ldd	r25, Y+2	; 0x02
    1a96:	01 97       	sbiw	r24, 0x01	; 1
    1a98:	f1 f7       	brne	.-4      	; 0x1a96 <WriteNLatch+0x2a2>
    1a9a:	9a 83       	std	Y+2, r25	; 0x02
    1a9c:	89 83       	std	Y+1, r24	; 0x01
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	63 e0       	ldi	r22, 0x03	; 3
    1aa2:	40 e0       	ldi	r20, 0x00	; 0
    1aa4:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
        #warning "Wrong LCD MODE"
        return Local_enu_ErrorState;

    #endif

    Local_enu_ErrorState = ERROR_STATUS_OK;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	8d 8f       	std	Y+29, r24	; 0x1d
    return Local_enu_ErrorState;
    1aac:	8d 8d       	ldd	r24, Y+29	; 0x1d
}
    1aae:	6e 96       	adiw	r28, 0x1e	; 30
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	f8 94       	cli
    1ab4:	de bf       	out	0x3e, r29	; 62
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	cd bf       	out	0x3d, r28	; 61
    1aba:	cf 91       	pop	r28
    1abc:	df 91       	pop	r29
    1abe:	08 95       	ret

00001ac0 <LCD_enuSendData>:

ErrorStatus_t LCD_enuSendData(uint8_t Copy_u8Data){
    1ac0:	df 93       	push	r29
    1ac2:	cf 93       	push	r28
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <LCD_enuSendData+0x6>
    1ac6:	cd b7       	in	r28, 0x3d	; 61
    1ac8:	de b7       	in	r29, 0x3e	; 62
    1aca:	8a 83       	std	Y+2, r24	; 0x02


	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
    1acc:	19 82       	std	Y+1, r1	; 0x01

						 

	// RS-> held to high since we are going to send data 
	DIO_enuSetPinValue(RS_PORT, RS_PIN, DIO_u8HIGH);
    1ace:	81 e0       	ldi	r24, 0x01	; 1
    1ad0:	61 e0       	ldi	r22, 0x01	; 1
    1ad2:	41 e0       	ldi	r20, 0x01	; 1
    1ad4:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
	DIO_enuSetPinValue(RW_PORT, RW_PIN, DIO_u8LOW);
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	62 e0       	ldi	r22, 0x02	; 2
    1adc:	40 e0       	ldi	r20, 0x00	; 0
    1ade:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>



	WriteNLatch(Copy_u8Data);
    1ae2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae4:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <WriteNLatch>



	return Local_enu_ErrorState;
    1ae8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1aea:	0f 90       	pop	r0
    1aec:	0f 90       	pop	r0
    1aee:	cf 91       	pop	r28
    1af0:	df 91       	pop	r29
    1af2:	08 95       	ret

00001af4 <LCD_enuSendCommand>:
ErrorStatus_t LCD_enuSendCommand(uint8_t Copy_u8Command){
    1af4:	df 93       	push	r29
    1af6:	cf 93       	push	r28
    1af8:	00 d0       	rcall	.+0      	; 0x1afa <LCD_enuSendCommand+0x6>
    1afa:	cd b7       	in	r28, 0x3d	; 61
    1afc:	de b7       	in	r29, 0x3e	; 62
    1afe:	8a 83       	std	Y+2, r24	; 0x02




	ErrorStatus_t Local_enu_ErrorState = ERROR_STATUS_FAILURE;
    1b00:	19 82       	std	Y+1, r1	; 0x01

						 
	// RS -> held to low since we are going to send command
	// RW -> held to low, because we writing on LCD
	DIO_enuSetPinValue(RS_PORT, RS_PIN, DIO_u8LOW);
    1b02:	81 e0       	ldi	r24, 0x01	; 1
    1b04:	61 e0       	ldi	r22, 0x01	; 1
    1b06:	40 e0       	ldi	r20, 0x00	; 0
    1b08:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
	DIO_enuSetPinValue(RW_PORT, RW_PIN, DIO_u8LOW);
    1b0c:	81 e0       	ldi	r24, 0x01	; 1
    1b0e:	62 e0       	ldi	r22, 0x02	; 2
    1b10:	40 e0       	ldi	r20, 0x00	; 0
    1b12:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
	WriteNLatch(Copy_u8Command);
    1b16:	8a 81       	ldd	r24, Y+2	; 0x02
    1b18:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <WriteNLatch>




	Local_enu_ErrorState = ERROR_STATUS_OK;
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	89 83       	std	Y+1, r24	; 0x01

	return Local_enu_ErrorState;
    1b20:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b22:	0f 90       	pop	r0
    1b24:	0f 90       	pop	r0
    1b26:	cf 91       	pop	r28
    1b28:	df 91       	pop	r29
    1b2a:	08 95       	ret

00001b2c <LCD_u8SendString>:


ErrorStatus_t LCD_u8SendString(const char *Copy_pu8String){
    1b2c:	df 93       	push	r29
    1b2e:	cf 93       	push	r28
    1b30:	00 d0       	rcall	.+0      	; 0x1b32 <LCD_u8SendString+0x6>
    1b32:	00 d0       	rcall	.+0      	; 0x1b34 <LCD_u8SendString+0x8>
    1b34:	0f 92       	push	r0
    1b36:	cd b7       	in	r28, 0x3d	; 61
    1b38:	de b7       	in	r29, 0x3e	; 62
    1b3a:	9c 83       	std	Y+4, r25	; 0x04
    1b3c:	8b 83       	std	Y+3, r24	; 0x03


	ErrorStatus_t Local_enuErrrorState = ERROR_STATUS_FAILURE;
    1b3e:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_pu8String != NULL){
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	9c 81       	ldd	r25, Y+4	; 0x04
    1b44:	00 97       	sbiw	r24, 0x00	; 0
    1b46:	f9 f0       	breq	.+62     	; 0x1b86 <LCD_u8SendString+0x5a>
		uint8_t local_u8counter = 0;
    1b48:	19 82       	std	Y+1, r1	; 0x01
    1b4a:	0f c0       	rjmp	.+30     	; 0x1b6a <LCD_u8SendString+0x3e>

		// condition tests whether we reached end of given text
		while(Copy_pu8String[local_u8counter] != '\0'){
			LCD_enuSendData(Copy_pu8String[local_u8counter++]);
    1b4c:	89 81       	ldd	r24, Y+1	; 0x01
    1b4e:	28 2f       	mov	r18, r24
    1b50:	30 e0       	ldi	r19, 0x00	; 0
    1b52:	8b 81       	ldd	r24, Y+3	; 0x03
    1b54:	9c 81       	ldd	r25, Y+4	; 0x04
    1b56:	fc 01       	movw	r30, r24
    1b58:	e2 0f       	add	r30, r18
    1b5a:	f3 1f       	adc	r31, r19
    1b5c:	90 81       	ld	r25, Z
    1b5e:	89 81       	ldd	r24, Y+1	; 0x01
    1b60:	8f 5f       	subi	r24, 0xFF	; 255
    1b62:	89 83       	std	Y+1, r24	; 0x01
    1b64:	89 2f       	mov	r24, r25
    1b66:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <LCD_enuSendData>
	ErrorStatus_t Local_enuErrrorState = ERROR_STATUS_FAILURE;
	if(Copy_pu8String != NULL){
		uint8_t local_u8counter = 0;

		// condition tests whether we reached end of given text
		while(Copy_pu8String[local_u8counter] != '\0'){
    1b6a:	89 81       	ldd	r24, Y+1	; 0x01
    1b6c:	28 2f       	mov	r18, r24
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	8b 81       	ldd	r24, Y+3	; 0x03
    1b72:	9c 81       	ldd	r25, Y+4	; 0x04
    1b74:	fc 01       	movw	r30, r24
    1b76:	e2 0f       	add	r30, r18
    1b78:	f3 1f       	adc	r31, r19
    1b7a:	80 81       	ld	r24, Z
    1b7c:	88 23       	and	r24, r24
    1b7e:	31 f7       	brne	.-52     	; 0x1b4c <LCD_u8SendString+0x20>

		Local_enuErrrorState = ERROR_STATUS_OK;
		return Local_enuErrrorState;
	}

	return Local_enuErrrorState;
    1b80:	8a 81       	ldd	r24, Y+2	; 0x02
    1b82:	8d 83       	std	Y+5, r24	; 0x05
    1b84:	04 c0       	rjmp	.+8      	; 0x1b8e <LCD_u8SendString+0x62>
		while(Copy_pu8String[local_u8counter] != '\0'){
			LCD_enuSendData(Copy_pu8String[local_u8counter++]);
		}
	}else{

		Local_enuErrrorState = ERROR_STATUS_OK;
    1b86:	81 e0       	ldi	r24, 0x01	; 1
    1b88:	8a 83       	std	Y+2, r24	; 0x02
		return Local_enuErrrorState;
    1b8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b8c:	8d 83       	std	Y+5, r24	; 0x05
    1b8e:	8d 81       	ldd	r24, Y+5	; 0x05
	}

	return Local_enuErrrorState;
}
    1b90:	0f 90       	pop	r0
    1b92:	0f 90       	pop	r0
    1b94:	0f 90       	pop	r0
    1b96:	0f 90       	pop	r0
    1b98:	0f 90       	pop	r0
    1b9a:	cf 91       	pop	r28
    1b9c:	df 91       	pop	r29
    1b9e:	08 95       	ret

00001ba0 <LCD_enuIntegerToString>:



ErrorStatus_t LCD_enuIntegerToString(sint32_t Copy_u8data, uint8_t Copy_u8Base){
    1ba0:	df 93       	push	r29
    1ba2:	cf 93       	push	r28
    1ba4:	cd b7       	in	r28, 0x3d	; 61
    1ba6:	de b7       	in	r29, 0x3e	; 62
    1ba8:	a0 97       	sbiw	r28, 0x20	; 32
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	f8 94       	cli
    1bae:	de bf       	out	0x3e, r29	; 62
    1bb0:	0f be       	out	0x3f, r0	; 63
    1bb2:	cd bf       	out	0x3d, r28	; 61
    1bb4:	6b 8f       	std	Y+27, r22	; 0x1b
    1bb6:	7c 8f       	std	Y+28, r23	; 0x1c
    1bb8:	8d 8f       	std	Y+29, r24	; 0x1d
    1bba:	9e 8f       	std	Y+30, r25	; 0x1e
    1bbc:	4f 8f       	std	Y+31, r20	; 0x1f

	ErrorStatus_t Local_enuErrrorState = ERROR_STATUS_FAILURE;
    1bbe:	1e 82       	std	Y+6, r1	; 0x06

	// To handle store given number as string & converting process
	char  Copy_u8Buffer[20];
	uint8_t Local_u8Counter = 0;
    1bc0:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t Local_u8NumberIndex= 0;
    1bc2:	1c 82       	std	Y+4, r1	; 0x04


	// To handle reversing the string
	uint8_t Local_u8Start = 0;
    1bc4:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t Local_u8End   = 0;
    1bc6:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t Local_u8temp;


	//Handle Negative Numbers
	if(Copy_u8data < 0){
    1bc8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1bca:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1bcc:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1bce:	be 8d       	ldd	r27, Y+30	; 0x1e
    1bd0:	bb 23       	and	r27, r27
    1bd2:	94 f4       	brge	.+36     	; 0x1bf8 <LCD_enuIntegerToString+0x58>
		LCD_enuSendData('-');
    1bd4:	8d e2       	ldi	r24, 0x2D	; 45
    1bd6:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <LCD_enuSendData>
		Copy_u8data*=-1;
    1bda:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1bdc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1bde:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1be0:	be 8d       	ldd	r27, Y+30	; 0x1e
    1be2:	b0 95       	com	r27
    1be4:	a0 95       	com	r26
    1be6:	90 95       	com	r25
    1be8:	81 95       	neg	r24
    1bea:	9f 4f       	sbci	r25, 0xFF	; 255
    1bec:	af 4f       	sbci	r26, 0xFF	; 255
    1bee:	bf 4f       	sbci	r27, 0xFF	; 255
    1bf0:	8b 8f       	std	Y+27, r24	; 0x1b
    1bf2:	9c 8f       	std	Y+28, r25	; 0x1c
    1bf4:	ad 8f       	std	Y+29, r26	; 0x1d
    1bf6:	be 8f       	std	Y+30, r27	; 0x1e
	}


	if(Copy_u8data == 0){
    1bf8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1bfa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1bfc:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1bfe:	be 8d       	ldd	r27, Y+30	; 0x1e
    1c00:	00 97       	sbiw	r24, 0x00	; 0
    1c02:	a1 05       	cpc	r26, r1
    1c04:	b1 05       	cpc	r27, r1
    1c06:	09 f0       	breq	.+2      	; 0x1c0a <LCD_enuIntegerToString+0x6a>
    1c08:	4b c0       	rjmp	.+150    	; 0x1ca0 <LCD_enuIntegerToString+0x100>
		Copy_u8Buffer[Local_u8Counter++] = '0';
    1c0a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c0c:	28 2f       	mov	r18, r24
    1c0e:	30 e0       	ldi	r19, 0x00	; 0
    1c10:	ce 01       	movw	r24, r28
    1c12:	07 96       	adiw	r24, 0x07	; 7
    1c14:	fc 01       	movw	r30, r24
    1c16:	e2 0f       	add	r30, r18
    1c18:	f3 1f       	adc	r31, r19
    1c1a:	80 e3       	ldi	r24, 0x30	; 48
    1c1c:	80 83       	st	Z, r24
    1c1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c20:	8f 5f       	subi	r24, 0xFF	; 255
    1c22:	8d 83       	std	Y+5, r24	; 0x05
		Copy_u8Buffer[Local_u8Counter] = '\0';
    1c24:	8d 81       	ldd	r24, Y+5	; 0x05
    1c26:	28 2f       	mov	r18, r24
    1c28:	30 e0       	ldi	r19, 0x00	; 0
    1c2a:	ce 01       	movw	r24, r28
    1c2c:	07 96       	adiw	r24, 0x07	; 7
    1c2e:	fc 01       	movw	r30, r24
    1c30:	e2 0f       	add	r30, r18
    1c32:	f3 1f       	adc	r31, r19
    1c34:	10 82       	st	Z, r1

		return Local_enuErrrorState;
    1c36:	8e 81       	ldd	r24, Y+6	; 0x06
    1c38:	88 a3       	std	Y+32, r24	; 0x20
    1c3a:	7f c0       	rjmp	.+254    	; 0x1d3a <LCD_enuIntegerToString+0x19a>

	else{


		while(Copy_u8data != 0){
			Local_u8NumberIndex = (Copy_u8data%Copy_u8Base);
    1c3c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1c3e:	28 2f       	mov	r18, r24
    1c40:	30 e0       	ldi	r19, 0x00	; 0
    1c42:	40 e0       	ldi	r20, 0x00	; 0
    1c44:	50 e0       	ldi	r21, 0x00	; 0
    1c46:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c48:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c4a:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1c4c:	be 8d       	ldd	r27, Y+30	; 0x1e
    1c4e:	bc 01       	movw	r22, r24
    1c50:	cd 01       	movw	r24, r26
    1c52:	0e 94 8f 3f 	call	0x7f1e	; 0x7f1e <__divmodsi4>
    1c56:	dc 01       	movw	r26, r24
    1c58:	cb 01       	movw	r24, r22
    1c5a:	8c 83       	std	Y+4, r24	; 0x04

			Copy_u8Buffer[Local_u8Counter++] = (Local_u8NumberIndex)+'0';
    1c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c5e:	28 2f       	mov	r18, r24
    1c60:	30 e0       	ldi	r19, 0x00	; 0
    1c62:	8c 81       	ldd	r24, Y+4	; 0x04
    1c64:	48 2f       	mov	r20, r24
    1c66:	40 5d       	subi	r20, 0xD0	; 208
    1c68:	ce 01       	movw	r24, r28
    1c6a:	07 96       	adiw	r24, 0x07	; 7
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	e2 0f       	add	r30, r18
    1c70:	f3 1f       	adc	r31, r19
    1c72:	40 83       	st	Z, r20
    1c74:	8d 81       	ldd	r24, Y+5	; 0x05
    1c76:	8f 5f       	subi	r24, 0xFF	; 255
    1c78:	8d 83       	std	Y+5, r24	; 0x05

			Copy_u8data /= Copy_u8Base;
    1c7a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1c7c:	28 2f       	mov	r18, r24
    1c7e:	30 e0       	ldi	r19, 0x00	; 0
    1c80:	40 e0       	ldi	r20, 0x00	; 0
    1c82:	50 e0       	ldi	r21, 0x00	; 0
    1c84:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c86:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c88:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1c8a:	be 8d       	ldd	r27, Y+30	; 0x1e
    1c8c:	bc 01       	movw	r22, r24
    1c8e:	cd 01       	movw	r24, r26
    1c90:	0e 94 8f 3f 	call	0x7f1e	; 0x7f1e <__divmodsi4>
    1c94:	da 01       	movw	r26, r20
    1c96:	c9 01       	movw	r24, r18
    1c98:	8b 8f       	std	Y+27, r24	; 0x1b
    1c9a:	9c 8f       	std	Y+28, r25	; 0x1c
    1c9c:	ad 8f       	std	Y+29, r26	; 0x1d
    1c9e:	be 8f       	std	Y+30, r27	; 0x1e


	else{


		while(Copy_u8data != 0){
    1ca0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ca2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ca4:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1ca6:	be 8d       	ldd	r27, Y+30	; 0x1e
    1ca8:	00 97       	sbiw	r24, 0x00	; 0
    1caa:	a1 05       	cpc	r26, r1
    1cac:	b1 05       	cpc	r27, r1
    1cae:	31 f6       	brne	.-116    	; 0x1c3c <LCD_enuIntegerToString+0x9c>
			Copy_u8Buffer[Local_u8Counter++] = (Local_u8NumberIndex)+'0';

			Copy_u8data /= Copy_u8Base;
		}

	    Copy_u8Buffer[Local_u8Counter] = '\0';
    1cb0:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb2:	28 2f       	mov	r18, r24
    1cb4:	30 e0       	ldi	r19, 0x00	; 0
    1cb6:	ce 01       	movw	r24, r28
    1cb8:	07 96       	adiw	r24, 0x07	; 7
    1cba:	fc 01       	movw	r30, r24
    1cbc:	e2 0f       	add	r30, r18
    1cbe:	f3 1f       	adc	r31, r19
    1cc0:	10 82       	st	Z, r1

	}

	Local_u8End = Local_u8Counter-1;
    1cc2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc4:	81 50       	subi	r24, 0x01	; 1
    1cc6:	8a 83       	std	Y+2, r24	; 0x02
    1cc8:	2c c0       	rjmp	.+88     	; 0x1d22 <LCD_enuIntegerToString+0x182>
    // Reverse Buffer
	while(Local_u8Start < Local_u8End){
    	Local_u8temp = Copy_u8Buffer[Local_u8Start];
    1cca:	8b 81       	ldd	r24, Y+3	; 0x03
    1ccc:	28 2f       	mov	r18, r24
    1cce:	30 e0       	ldi	r19, 0x00	; 0
    1cd0:	ce 01       	movw	r24, r28
    1cd2:	07 96       	adiw	r24, 0x07	; 7
    1cd4:	fc 01       	movw	r30, r24
    1cd6:	e2 0f       	add	r30, r18
    1cd8:	f3 1f       	adc	r31, r19
    1cda:	80 81       	ld	r24, Z
    1cdc:	89 83       	std	Y+1, r24	; 0x01

        Copy_u8Buffer[Local_u8Start] = Copy_u8Buffer[Local_u8End];
    1cde:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce0:	48 2f       	mov	r20, r24
    1ce2:	50 e0       	ldi	r21, 0x00	; 0
    1ce4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce6:	28 2f       	mov	r18, r24
    1ce8:	30 e0       	ldi	r19, 0x00	; 0
    1cea:	ce 01       	movw	r24, r28
    1cec:	07 96       	adiw	r24, 0x07	; 7
    1cee:	fc 01       	movw	r30, r24
    1cf0:	e2 0f       	add	r30, r18
    1cf2:	f3 1f       	adc	r31, r19
    1cf4:	20 81       	ld	r18, Z
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	07 96       	adiw	r24, 0x07	; 7
    1cfa:	fc 01       	movw	r30, r24
    1cfc:	e4 0f       	add	r30, r20
    1cfe:	f5 1f       	adc	r31, r21
    1d00:	20 83       	st	Z, r18
        Copy_u8Buffer[Local_u8End] = Local_u8temp;
    1d02:	8a 81       	ldd	r24, Y+2	; 0x02
    1d04:	28 2f       	mov	r18, r24
    1d06:	30 e0       	ldi	r19, 0x00	; 0
    1d08:	ce 01       	movw	r24, r28
    1d0a:	07 96       	adiw	r24, 0x07	; 7
    1d0c:	fc 01       	movw	r30, r24
    1d0e:	e2 0f       	add	r30, r18
    1d10:	f3 1f       	adc	r31, r19
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	80 83       	st	Z, r24

        Local_u8Start++;
    1d16:	8b 81       	ldd	r24, Y+3	; 0x03
    1d18:	8f 5f       	subi	r24, 0xFF	; 255
    1d1a:	8b 83       	std	Y+3, r24	; 0x03
        Local_u8End--;
    1d1c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d1e:	81 50       	subi	r24, 0x01	; 1
    1d20:	8a 83       	std	Y+2, r24	; 0x02

	}

	Local_u8End = Local_u8Counter-1;
    // Reverse Buffer
	while(Local_u8Start < Local_u8End){
    1d22:	9b 81       	ldd	r25, Y+3	; 0x03
    1d24:	8a 81       	ldd	r24, Y+2	; 0x02
    1d26:	98 17       	cp	r25, r24
    1d28:	80 f2       	brcs	.-96     	; 0x1cca <LCD_enuIntegerToString+0x12a>

        Local_u8Start++;
        Local_u8End--;
    }

	LCD_u8SendString(Copy_u8Buffer);
    1d2a:	ce 01       	movw	r24, r28
    1d2c:	07 96       	adiw	r24, 0x07	; 7
    1d2e:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <LCD_u8SendString>

	Local_enuErrrorState = ERROR_STATUS_OK;
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	8e 83       	std	Y+6, r24	; 0x06
	return Local_enuErrrorState;
    1d36:	8e 81       	ldd	r24, Y+6	; 0x06
    1d38:	88 a3       	std	Y+32, r24	; 0x20
    1d3a:	88 a1       	ldd	r24, Y+32	; 0x20
}
    1d3c:	a0 96       	adiw	r28, 0x20	; 32
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	de bf       	out	0x3e, r29	; 62
    1d44:	0f be       	out	0x3f, r0	; 63
    1d46:	cd bf       	out	0x3d, r28	; 61
    1d48:	cf 91       	pop	r28
    1d4a:	df 91       	pop	r29
    1d4c:	08 95       	ret

00001d4e <LCD_u8SetPosXY>:



ErrorStatus_t LCD_u8SetPosXY(uint8_t copy_u8PosX,uint8_t copy_u8PosY)
{
    1d4e:	df 93       	push	r29
    1d50:	cf 93       	push	r28
    1d52:	cd b7       	in	r28, 0x3d	; 61
    1d54:	de b7       	in	r29, 0x3e	; 62
    1d56:	27 97       	sbiw	r28, 0x07	; 7
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	de bf       	out	0x3e, r29	; 62
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	cd bf       	out	0x3d, r28	; 61
    1d62:	8b 83       	std	Y+3, r24	; 0x03
    1d64:	6c 83       	std	Y+4, r22	; 0x04
	ErrorStatus_t local_u8ErrorState=ERROR_STATUS_FAILURE;
    1d66:	1a 82       	std	Y+2, r1	; 0x02

	if(copy_u8PosX > 16 || copy_u8PosY > 2){
    1d68:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6a:	81 31       	cpi	r24, 0x11	; 17
    1d6c:	18 f4       	brcc	.+6      	; 0x1d74 <LCD_u8SetPosXY+0x26>
    1d6e:	8c 81       	ldd	r24, Y+4	; 0x04
    1d70:	83 30       	cpi	r24, 0x03	; 3
    1d72:	18 f0       	brcs	.+6      	; 0x1d7a <LCD_u8SetPosXY+0x2c>
		return local_u8ErrorState;
    1d74:	2a 81       	ldd	r18, Y+2	; 0x02
    1d76:	2f 83       	std	Y+7, r18	; 0x07
    1d78:	23 c0       	rjmp	.+70     	; 0x1dc0 <LCD_u8SetPosXY+0x72>
	}

	else{
		uint8_t local_u8DDRAM=0;
    1d7a:	19 82       	std	Y+1, r1	; 0x01

		switch(copy_u8PosY)
    1d7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d7e:	28 2f       	mov	r18, r24
    1d80:	30 e0       	ldi	r19, 0x00	; 0
    1d82:	3e 83       	std	Y+6, r19	; 0x06
    1d84:	2d 83       	std	Y+5, r18	; 0x05
    1d86:	8d 81       	ldd	r24, Y+5	; 0x05
    1d88:	9e 81       	ldd	r25, Y+6	; 0x06
    1d8a:	81 30       	cpi	r24, 0x01	; 1
    1d8c:	91 05       	cpc	r25, r1
    1d8e:	31 f0       	breq	.+12     	; 0x1d9c <LCD_u8SetPosXY+0x4e>
    1d90:	2d 81       	ldd	r18, Y+5	; 0x05
    1d92:	3e 81       	ldd	r19, Y+6	; 0x06
    1d94:	22 30       	cpi	r18, 0x02	; 2
    1d96:	31 05       	cpc	r19, r1
    1d98:	21 f0       	breq	.+8      	; 0x1da2 <LCD_u8SetPosXY+0x54>
    1d9a:	07 c0       	rjmp	.+14     	; 0x1daa <LCD_u8SetPosXY+0x5c>
		{
			case 1:
				local_u8DDRAM = copy_u8PosX;
    1d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d9e:	89 83       	std	Y+1, r24	; 0x01
    1da0:	05 c0       	rjmp	.+10     	; 0x1dac <LCD_u8SetPosXY+0x5e>
				break;

			case 2:
				local_u8DDRAM= copy_u8PosX+0x40;
    1da2:	8b 81       	ldd	r24, Y+3	; 0x03
    1da4:	80 5c       	subi	r24, 0xC0	; 192
    1da6:	89 83       	std	Y+1, r24	; 0x01
    1da8:	01 c0       	rjmp	.+2      	; 0x1dac <LCD_u8SetPosXY+0x5e>
				break;

			default:
				local_u8ErrorState=ERROR_STATUS_FAILURE;
    1daa:	1a 82       	std	Y+2, r1	; 0x02
			break;
		}


		SET_BIT(local_u8DDRAM,7); // From datasheet
    1dac:	89 81       	ldd	r24, Y+1	; 0x01
    1dae:	80 68       	ori	r24, 0x80	; 128
    1db0:	89 83       	std	Y+1, r24	; 0x01

		LCD_enuSendCommand(local_u8DDRAM);
    1db2:	89 81       	ldd	r24, Y+1	; 0x01
    1db4:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
	}

	local_u8ErrorState = ERROR_STATUS_OK;
    1db8:	81 e0       	ldi	r24, 0x01	; 1
    1dba:	8a 83       	std	Y+2, r24	; 0x02
	return local_u8ErrorState;
    1dbc:	3a 81       	ldd	r19, Y+2	; 0x02
    1dbe:	3f 83       	std	Y+7, r19	; 0x07
    1dc0:	8f 81       	ldd	r24, Y+7	; 0x07
}
    1dc2:	27 96       	adiw	r28, 0x07	; 7
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	de bf       	out	0x3e, r29	; 62
    1dca:	0f be       	out	0x3f, r0	; 63
    1dcc:	cd bf       	out	0x3d, r28	; 61
    1dce:	cf 91       	pop	r28
    1dd0:	df 91       	pop	r29
    1dd2:	08 95       	ret

00001dd4 <LCD_u8StoreCustomChar>:


ErrorStatus_t LCD_u8StoreCustomChar(uint8_t *copy_u8pattern, uint8_t copy_u8CGRAM_index){
    1dd4:	df 93       	push	r29
    1dd6:	cf 93       	push	r28
    1dd8:	cd b7       	in	r28, 0x3d	; 61
    1dda:	de b7       	in	r29, 0x3e	; 62
    1ddc:	27 97       	sbiw	r28, 0x07	; 7
    1dde:	0f b6       	in	r0, 0x3f	; 63
    1de0:	f8 94       	cli
    1de2:	de bf       	out	0x3e, r29	; 62
    1de4:	0f be       	out	0x3f, r0	; 63
    1de6:	cd bf       	out	0x3d, r28	; 61
    1de8:	9d 83       	std	Y+5, r25	; 0x05
    1dea:	8c 83       	std	Y+4, r24	; 0x04
    1dec:	6e 83       	std	Y+6, r22	; 0x06
	ErrorStatus_t Local_enuErrrorState = ERROR_STATUS_FAILURE;
    1dee:	1b 82       	std	Y+3, r1	; 0x03



	if(copy_u8pattern == NULL || copy_u8CGRAM_index < 0 || copy_u8CGRAM_index > 8){
    1df0:	8c 81       	ldd	r24, Y+4	; 0x04
    1df2:	9d 81       	ldd	r25, Y+5	; 0x05
    1df4:	00 97       	sbiw	r24, 0x00	; 0
    1df6:	19 f0       	breq	.+6      	; 0x1dfe <LCD_u8StoreCustomChar+0x2a>
    1df8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dfa:	89 30       	cpi	r24, 0x09	; 9
    1dfc:	18 f0       	brcs	.+6      	; 0x1e04 <LCD_u8StoreCustomChar+0x30>
		return Local_enuErrrorState;
    1dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    1e00:	8f 83       	std	Y+7, r24	; 0x07
    1e02:	2a c0       	rjmp	.+84     	; 0x1e58 <LCD_u8StoreCustomChar+0x84>

	}else{
		uint8_t local_u8CGRAM= copy_u8CGRAM_index*8;
    1e04:	8e 81       	ldd	r24, Y+6	; 0x06
    1e06:	88 2f       	mov	r24, r24
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	88 0f       	add	r24, r24
    1e0c:	99 1f       	adc	r25, r25
    1e0e:	88 0f       	add	r24, r24
    1e10:	99 1f       	adc	r25, r25
    1e12:	88 0f       	add	r24, r24
    1e14:	99 1f       	adc	r25, r25
    1e16:	8a 83       	std	Y+2, r24	; 0x02

		SET_BIT(local_u8CGRAM, 6); // from datasheet
    1e18:	8a 81       	ldd	r24, Y+2	; 0x02
    1e1a:	80 64       	ori	r24, 0x40	; 64
    1e1c:	8a 83       	std	Y+2, r24	; 0x02
		LCD_enuSendCommand(local_u8CGRAM);
    1e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e20:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>



		for(uint8_t Local_u8Index = 0; Local_u8Index < 8; Local_u8Index++){
    1e24:	19 82       	std	Y+1, r1	; 0x01
    1e26:	0e c0       	rjmp	.+28     	; 0x1e44 <LCD_u8StoreCustomChar+0x70>
			LCD_enuSendData(copy_u8pattern[Local_u8Index]);
    1e28:	89 81       	ldd	r24, Y+1	; 0x01
    1e2a:	28 2f       	mov	r18, r24
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1e30:	9d 81       	ldd	r25, Y+5	; 0x05
    1e32:	fc 01       	movw	r30, r24
    1e34:	e2 0f       	add	r30, r18
    1e36:	f3 1f       	adc	r31, r19
    1e38:	80 81       	ld	r24, Z
    1e3a:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <LCD_enuSendData>
		SET_BIT(local_u8CGRAM, 6); // from datasheet
		LCD_enuSendCommand(local_u8CGRAM);



		for(uint8_t Local_u8Index = 0; Local_u8Index < 8; Local_u8Index++){
    1e3e:	89 81       	ldd	r24, Y+1	; 0x01
    1e40:	8f 5f       	subi	r24, 0xFF	; 255
    1e42:	89 83       	std	Y+1, r24	; 0x01
    1e44:	89 81       	ldd	r24, Y+1	; 0x01
    1e46:	88 30       	cpi	r24, 0x08	; 8
    1e48:	78 f3       	brcs	.-34     	; 0x1e28 <LCD_u8StoreCustomChar+0x54>

	}


	// return Home
	LCD_enuSendCommand(RETURN_HOME);
    1e4a:	82 e0       	ldi	r24, 0x02	; 2
    1e4c:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
	Local_enuErrrorState = ERROR_STATUS_OK;
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	8b 83       	std	Y+3, r24	; 0x03
	return Local_enuErrrorState;
    1e54:	8b 81       	ldd	r24, Y+3	; 0x03
    1e56:	8f 83       	std	Y+7, r24	; 0x07
    1e58:	8f 81       	ldd	r24, Y+7	; 0x07
}
    1e5a:	27 96       	adiw	r28, 0x07	; 7
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	de bf       	out	0x3e, r29	; 62
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	cd bf       	out	0x3d, r28	; 61
    1e66:	cf 91       	pop	r28
    1e68:	df 91       	pop	r29
    1e6a:	08 95       	ret

00001e6c <LCD_u8DisplayCustomChar>:



ErrorStatus_t LCD_u8DisplayCustomChar(uint8_t copy_u8CGRAM_index, uint8_t copy_u8Col, uint8_t copy_u8Row){
    1e6c:	df 93       	push	r29
    1e6e:	cf 93       	push	r28
    1e70:	00 d0       	rcall	.+0      	; 0x1e72 <LCD_u8DisplayCustomChar+0x6>
    1e72:	00 d0       	rcall	.+0      	; 0x1e74 <LCD_u8DisplayCustomChar+0x8>
    1e74:	cd b7       	in	r28, 0x3d	; 61
    1e76:	de b7       	in	r29, 0x3e	; 62
    1e78:	8a 83       	std	Y+2, r24	; 0x02
    1e7a:	6b 83       	std	Y+3, r22	; 0x03
    1e7c:	4c 83       	std	Y+4, r20	; 0x04
	ErrorStatus_t Local_enuErrrorState = ERROR_STATUS_FAILURE;
    1e7e:	19 82       	std	Y+1, r1	; 0x01


	LCD_u8SetPosXY(copy_u8Row, copy_u8Col);
    1e80:	8c 81       	ldd	r24, Y+4	; 0x04
    1e82:	6b 81       	ldd	r22, Y+3	; 0x03
    1e84:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <LCD_u8SetPosXY>
	/*
	 * if tried to write 0-7
	 * we accessing reserved places in CGROM for CGRAM
	 * */

	LCD_enuSendData(copy_u8CGRAM_index);
    1e88:	8a 81       	ldd	r24, Y+2	; 0x02
    1e8a:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <LCD_enuSendData>


	Local_enuErrrorState = ERROR_STATUS_OK;
    1e8e:	81 e0       	ldi	r24, 0x01	; 1
    1e90:	89 83       	std	Y+1, r24	; 0x01
	return Local_enuErrrorState;
    1e92:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e94:	0f 90       	pop	r0
    1e96:	0f 90       	pop	r0
    1e98:	0f 90       	pop	r0
    1e9a:	0f 90       	pop	r0
    1e9c:	cf 91       	pop	r28
    1e9e:	df 91       	pop	r29
    1ea0:	08 95       	ret

00001ea2 <BTN_u8Read>:





uint8_t BTN_u8Read(uint8_t Copy_u8BTNPortID,uint8_t Copy_u8BTNPinID){
    1ea2:	df 93       	push	r29
    1ea4:	cf 93       	push	r28
    1ea6:	00 d0       	rcall	.+0      	; 0x1ea8 <BTN_u8Read+0x6>
    1ea8:	0f 92       	push	r0
    1eaa:	cd b7       	in	r28, 0x3d	; 61
    1eac:	de b7       	in	r29, 0x3e	; 62
    1eae:	8a 83       	std	Y+2, r24	; 0x02
    1eb0:	6b 83       	std	Y+3, r22	; 0x03


	uint8_t value = 0;
    1eb2:	19 82       	std	Y+1, r1	; 0x01


	DIO_enuGetPinValue(Copy_u8BTNPortID, Copy_u8BTNPinID, &value);
    1eb4:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb6:	6b 81       	ldd	r22, Y+3	; 0x03
    1eb8:	9e 01       	movw	r18, r28
    1eba:	2f 5f       	subi	r18, 0xFF	; 255
    1ebc:	3f 4f       	sbci	r19, 0xFF	; 255
    1ebe:	a9 01       	movw	r20, r18
    1ec0:	0e 94 c6 07 	call	0xf8c	; 0xf8c <DIO_enuGetPinValue>

	return value;
    1ec4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ec6:	0f 90       	pop	r0
    1ec8:	0f 90       	pop	r0
    1eca:	0f 90       	pop	r0
    1ecc:	cf 91       	pop	r28
    1ece:	df 91       	pop	r29
    1ed0:	08 95       	ret

00001ed2 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1ed2:	df 93       	push	r29
    1ed4:	cf 93       	push	r28
    1ed6:	00 d0       	rcall	.+0      	; 0x1ed8 <xEventGroupCreate+0x6>
    1ed8:	cd b7       	in	r28, 0x3d	; 61
    1eda:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1edc:	8b e0       	ldi	r24, 0x0B	; 11
    1ede:	90 e0       	ldi	r25, 0x00	; 0
    1ee0:	0e 94 ae 12 	call	0x255c	; 0x255c <pvPortMalloc>
    1ee4:	9a 83       	std	Y+2, r25	; 0x02
    1ee6:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1ee8:	89 81       	ldd	r24, Y+1	; 0x01
    1eea:	9a 81       	ldd	r25, Y+2	; 0x02
    1eec:	00 97       	sbiw	r24, 0x00	; 0
    1eee:	49 f0       	breq	.+18     	; 0x1f02 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1ef0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ef2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ef4:	11 82       	std	Z+1, r1	; 0x01
    1ef6:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1ef8:	89 81       	ldd	r24, Y+1	; 0x01
    1efa:	9a 81       	ldd	r25, Y+2	; 0x02
    1efc:	02 96       	adiw	r24, 0x02	; 2
    1efe:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1f02:	89 81       	ldd	r24, Y+1	; 0x01
    1f04:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1f06:	0f 90       	pop	r0
    1f08:	0f 90       	pop	r0
    1f0a:	cf 91       	pop	r28
    1f0c:	df 91       	pop	r29
    1f0e:	08 95       	ret

00001f10 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1f10:	df 93       	push	r29
    1f12:	cf 93       	push	r28
    1f14:	cd b7       	in	r28, 0x3d	; 61
    1f16:	de b7       	in	r29, 0x3e	; 62
    1f18:	60 97       	sbiw	r28, 0x10	; 16
    1f1a:	0f b6       	in	r0, 0x3f	; 63
    1f1c:	f8 94       	cli
    1f1e:	de bf       	out	0x3e, r29	; 62
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	cd bf       	out	0x3d, r28	; 61
    1f24:	9a 87       	std	Y+10, r25	; 0x0a
    1f26:	89 87       	std	Y+9, r24	; 0x09
    1f28:	7c 87       	std	Y+12, r23	; 0x0c
    1f2a:	6b 87       	std	Y+11, r22	; 0x0b
    1f2c:	5e 87       	std	Y+14, r21	; 0x0e
    1f2e:	4d 87       	std	Y+13, r20	; 0x0d
    1f30:	38 8b       	std	Y+16, r19	; 0x10
    1f32:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1f34:	89 85       	ldd	r24, Y+9	; 0x09
    1f36:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f38:	9c 83       	std	Y+4, r25	; 0x04
    1f3a:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1f3c:	19 82       	std	Y+1, r1	; 0x01
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    1f3e:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1f42:	eb 81       	ldd	r30, Y+3	; 0x03
    1f44:	fc 81       	ldd	r31, Y+4	; 0x04
    1f46:	80 81       	ld	r24, Z
    1f48:	91 81       	ldd	r25, Z+1	; 0x01
    1f4a:	98 87       	std	Y+8, r25	; 0x08
    1f4c:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1f4e:	89 85       	ldd	r24, Y+9	; 0x09
    1f50:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f52:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f54:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f56:	b9 01       	movw	r22, r18
    1f58:	0e 94 5f 11 	call	0x22be	; 0x22be <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f5c:	2f 81       	ldd	r18, Y+7	; 0x07
    1f5e:	38 85       	ldd	r19, Y+8	; 0x08
    1f60:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f62:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f64:	28 2b       	or	r18, r24
    1f66:	39 2b       	or	r19, r25
    1f68:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f6c:	28 23       	and	r18, r24
    1f6e:	39 23       	and	r19, r25
    1f70:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f72:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f74:	28 17       	cp	r18, r24
    1f76:	39 07       	cpc	r19, r25
    1f78:	c9 f4       	brne	.+50     	; 0x1fac <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1f7a:	2f 81       	ldd	r18, Y+7	; 0x07
    1f7c:	38 85       	ldd	r19, Y+8	; 0x08
    1f7e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f80:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f82:	82 2b       	or	r24, r18
    1f84:	93 2b       	or	r25, r19
    1f86:	9e 83       	std	Y+6, r25	; 0x06
    1f88:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f8e:	20 81       	ld	r18, Z
    1f90:	31 81       	ldd	r19, Z+1	; 0x01
    1f92:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f94:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f96:	80 95       	com	r24
    1f98:	90 95       	com	r25
    1f9a:	82 23       	and	r24, r18
    1f9c:	93 23       	and	r25, r19
    1f9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa2:	91 83       	std	Z+1, r25	; 0x01
    1fa4:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1fa6:	18 8a       	std	Y+16, r1	; 0x10
    1fa8:	1f 86       	std	Y+15, r1	; 0x0f
    1faa:	1e c0       	rjmp	.+60     	; 0x1fe8 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1fac:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fae:	98 89       	ldd	r25, Y+16	; 0x10
    1fb0:	00 97       	sbiw	r24, 0x00	; 0
    1fb2:	91 f0       	breq	.+36     	; 0x1fd8 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb8:	bc 01       	movw	r22, r24
    1fba:	6e 5f       	subi	r22, 0xFE	; 254
    1fbc:	7f 4f       	sbci	r23, 0xFF	; 255
    1fbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fc0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fc2:	9c 01       	movw	r18, r24
    1fc4:	35 60       	ori	r19, 0x05	; 5
    1fc6:	4f 85       	ldd	r20, Y+15	; 0x0f
    1fc8:	58 89       	ldd	r21, Y+16	; 0x10
    1fca:	cb 01       	movw	r24, r22
    1fcc:	b9 01       	movw	r22, r18
    1fce:	0e 94 d0 31 	call	0x63a0	; 0x63a0 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1fd2:	1e 82       	std	Y+6, r1	; 0x06
    1fd4:	1d 82       	std	Y+5, r1	; 0x05
    1fd6:	08 c0       	rjmp	.+16     	; 0x1fe8 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1fd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fda:	fc 81       	ldd	r31, Y+4	; 0x04
    1fdc:	80 81       	ld	r24, Z
    1fde:	91 81       	ldd	r25, Z+1	; 0x01
    1fe0:	9e 83       	std	Y+6, r25	; 0x06
    1fe2:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1fe8:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    1fec:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1fee:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ff0:	98 89       	ldd	r25, Y+16	; 0x10
    1ff2:	00 97       	sbiw	r24, 0x00	; 0
    1ff4:	09 f4       	brne	.+2      	; 0x1ff8 <xEventGroupSync+0xe8>
    1ff6:	3a c0       	rjmp	.+116    	; 0x206c <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffa:	88 23       	and	r24, r24
    1ffc:	11 f4       	brne	.+4      	; 0x2002 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1ffe:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2002:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <uxTaskResetEventItemValue>
    2006:	9e 83       	std	Y+6, r25	; 0x06
    2008:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    200a:	8d 81       	ldd	r24, Y+5	; 0x05
    200c:	9e 81       	ldd	r25, Y+6	; 0x06
    200e:	80 70       	andi	r24, 0x00	; 0
    2010:	92 70       	andi	r25, 0x02	; 2
    2012:	00 97       	sbiw	r24, 0x00	; 0
    2014:	31 f5       	brne	.+76     	; 0x2062 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    2016:	0f b6       	in	r0, 0x3f	; 63
    2018:	f8 94       	cli
    201a:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    201c:	eb 81       	ldd	r30, Y+3	; 0x03
    201e:	fc 81       	ldd	r31, Y+4	; 0x04
    2020:	80 81       	ld	r24, Z
    2022:	91 81       	ldd	r25, Z+1	; 0x01
    2024:	9e 83       	std	Y+6, r25	; 0x06
    2026:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2028:	2d 81       	ldd	r18, Y+5	; 0x05
    202a:	3e 81       	ldd	r19, Y+6	; 0x06
    202c:	8d 85       	ldd	r24, Y+13	; 0x0d
    202e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2030:	28 23       	and	r18, r24
    2032:	39 23       	and	r19, r25
    2034:	8d 85       	ldd	r24, Y+13	; 0x0d
    2036:	9e 85       	ldd	r25, Y+14	; 0x0e
    2038:	28 17       	cp	r18, r24
    203a:	39 07       	cpc	r19, r25
    203c:	71 f4       	brne	.+28     	; 0x205a <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    203e:	eb 81       	ldd	r30, Y+3	; 0x03
    2040:	fc 81       	ldd	r31, Y+4	; 0x04
    2042:	20 81       	ld	r18, Z
    2044:	31 81       	ldd	r19, Z+1	; 0x01
    2046:	8d 85       	ldd	r24, Y+13	; 0x0d
    2048:	9e 85       	ldd	r25, Y+14	; 0x0e
    204a:	80 95       	com	r24
    204c:	90 95       	com	r25
    204e:	82 23       	and	r24, r18
    2050:	93 23       	and	r25, r19
    2052:	eb 81       	ldd	r30, Y+3	; 0x03
    2054:	fc 81       	ldd	r31, Y+4	; 0x04
    2056:	91 83       	std	Z+1, r25	; 0x01
    2058:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    205a:	0f 90       	pop	r0
    205c:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2062:	8d 81       	ldd	r24, Y+5	; 0x05
    2064:	9e 81       	ldd	r25, Y+6	; 0x06
    2066:	90 70       	andi	r25, 0x00	; 0
    2068:	9e 83       	std	Y+6, r25	; 0x06
    206a:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    206c:	8d 81       	ldd	r24, Y+5	; 0x05
    206e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2070:	60 96       	adiw	r28, 0x10	; 16
    2072:	0f b6       	in	r0, 0x3f	; 63
    2074:	f8 94       	cli
    2076:	de bf       	out	0x3e, r29	; 62
    2078:	0f be       	out	0x3f, r0	; 63
    207a:	cd bf       	out	0x3d, r28	; 61
    207c:	cf 91       	pop	r28
    207e:	df 91       	pop	r29
    2080:	08 95       	ret

00002082 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    2082:	0f 93       	push	r16
    2084:	1f 93       	push	r17
    2086:	df 93       	push	r29
    2088:	cf 93       	push	r28
    208a:	cd b7       	in	r28, 0x3d	; 61
    208c:	de b7       	in	r29, 0x3e	; 62
    208e:	63 97       	sbiw	r28, 0x13	; 19
    2090:	0f b6       	in	r0, 0x3f	; 63
    2092:	f8 94       	cli
    2094:	de bf       	out	0x3e, r29	; 62
    2096:	0f be       	out	0x3f, r0	; 63
    2098:	cd bf       	out	0x3d, r28	; 61
    209a:	9d 87       	std	Y+13, r25	; 0x0d
    209c:	8c 87       	std	Y+12, r24	; 0x0c
    209e:	7f 87       	std	Y+15, r23	; 0x0f
    20a0:	6e 87       	std	Y+14, r22	; 0x0e
    20a2:	48 8b       	std	Y+16, r20	; 0x10
    20a4:	29 8b       	std	Y+17, r18	; 0x11
    20a6:	1b 8b       	std	Y+19, r17	; 0x13
    20a8:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    20aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    20ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    20ae:	9b 87       	std	Y+11, r25	; 0x0b
    20b0:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    20b2:	1f 82       	std	Y+7, r1	; 0x07
    20b4:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    20b6:	1b 82       	std	Y+3, r1	; 0x03
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    20b8:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    20bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    20be:	fb 85       	ldd	r31, Y+11	; 0x0b
    20c0:	80 81       	ld	r24, Z
    20c2:	91 81       	ldd	r25, Z+1	; 0x01
    20c4:	9a 83       	std	Y+2, r25	; 0x02
    20c6:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    20c8:	89 81       	ldd	r24, Y+1	; 0x01
    20ca:	9a 81       	ldd	r25, Y+2	; 0x02
    20cc:	2e 85       	ldd	r18, Y+14	; 0x0e
    20ce:	3f 85       	ldd	r19, Y+15	; 0x0f
    20d0:	b9 01       	movw	r22, r18
    20d2:	49 89       	ldd	r20, Y+17	; 0x11
    20d4:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <prvTestWaitCondition>
    20d8:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    20da:	8d 81       	ldd	r24, Y+5	; 0x05
    20dc:	88 23       	and	r24, r24
    20de:	c1 f0       	breq	.+48     	; 0x2110 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	99 87       	std	Y+9, r25	; 0x09
    20e6:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    20e8:	1b 8a       	std	Y+19, r1	; 0x13
    20ea:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    20ec:	88 89       	ldd	r24, Y+16	; 0x10
    20ee:	88 23       	and	r24, r24
    20f0:	e9 f1       	breq	.+122    	; 0x216c <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    20f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    20f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    20f6:	20 81       	ld	r18, Z
    20f8:	31 81       	ldd	r19, Z+1	; 0x01
    20fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    20fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    20fe:	80 95       	com	r24
    2100:	90 95       	com	r25
    2102:	82 23       	and	r24, r18
    2104:	93 23       	and	r25, r19
    2106:	ea 85       	ldd	r30, Y+10	; 0x0a
    2108:	fb 85       	ldd	r31, Y+11	; 0x0b
    210a:	91 83       	std	Z+1, r25	; 0x01
    210c:	80 83       	st	Z, r24
    210e:	2e c0       	rjmp	.+92     	; 0x216c <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    2110:	8a 89       	ldd	r24, Y+18	; 0x12
    2112:	9b 89       	ldd	r25, Y+19	; 0x13
    2114:	00 97       	sbiw	r24, 0x00	; 0
    2116:	39 f4       	brne	.+14     	; 0x2126 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    2118:	89 81       	ldd	r24, Y+1	; 0x01
    211a:	9a 81       	ldd	r25, Y+2	; 0x02
    211c:	99 87       	std	Y+9, r25	; 0x09
    211e:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	8b 83       	std	Y+3, r24	; 0x03
    2124:	23 c0       	rjmp	.+70     	; 0x216c <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    2126:	88 89       	ldd	r24, Y+16	; 0x10
    2128:	88 23       	and	r24, r24
    212a:	29 f0       	breq	.+10     	; 0x2136 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    212c:	8e 81       	ldd	r24, Y+6	; 0x06
    212e:	9f 81       	ldd	r25, Y+7	; 0x07
    2130:	91 60       	ori	r25, 0x01	; 1
    2132:	9f 83       	std	Y+7, r25	; 0x07
    2134:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    2136:	89 89       	ldd	r24, Y+17	; 0x11
    2138:	88 23       	and	r24, r24
    213a:	29 f0       	breq	.+10     	; 0x2146 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    213c:	8e 81       	ldd	r24, Y+6	; 0x06
    213e:	9f 81       	ldd	r25, Y+7	; 0x07
    2140:	94 60       	ori	r25, 0x04	; 4
    2142:	9f 83       	std	Y+7, r25	; 0x07
    2144:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2146:	8a 85       	ldd	r24, Y+10	; 0x0a
    2148:	9b 85       	ldd	r25, Y+11	; 0x0b
    214a:	bc 01       	movw	r22, r24
    214c:	6e 5f       	subi	r22, 0xFE	; 254
    214e:	7f 4f       	sbci	r23, 0xFF	; 255
    2150:	2e 85       	ldd	r18, Y+14	; 0x0e
    2152:	3f 85       	ldd	r19, Y+15	; 0x0f
    2154:	8e 81       	ldd	r24, Y+6	; 0x06
    2156:	9f 81       	ldd	r25, Y+7	; 0x07
    2158:	28 2b       	or	r18, r24
    215a:	39 2b       	or	r19, r25
    215c:	4a 89       	ldd	r20, Y+18	; 0x12
    215e:	5b 89       	ldd	r21, Y+19	; 0x13
    2160:	cb 01       	movw	r24, r22
    2162:	b9 01       	movw	r22, r18
    2164:	0e 94 d0 31 	call	0x63a0	; 0x63a0 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    2168:	19 86       	std	Y+9, r1	; 0x09
    216a:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    216c:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    2170:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    2172:	8a 89       	ldd	r24, Y+18	; 0x12
    2174:	9b 89       	ldd	r25, Y+19	; 0x13
    2176:	00 97       	sbiw	r24, 0x00	; 0
    2178:	09 f4       	brne	.+2      	; 0x217c <xEventGroupWaitBits+0xfa>
    217a:	3c c0       	rjmp	.+120    	; 0x21f4 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    217c:	8c 81       	ldd	r24, Y+4	; 0x04
    217e:	88 23       	and	r24, r24
    2180:	11 f4       	brne	.+4      	; 0x2186 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    2182:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2186:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <uxTaskResetEventItemValue>
    218a:	99 87       	std	Y+9, r25	; 0x09
    218c:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    218e:	88 85       	ldd	r24, Y+8	; 0x08
    2190:	99 85       	ldd	r25, Y+9	; 0x09
    2192:	80 70       	andi	r24, 0x00	; 0
    2194:	92 70       	andi	r25, 0x02	; 2
    2196:	00 97       	sbiw	r24, 0x00	; 0
    2198:	41 f5       	brne	.+80     	; 0x21ea <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    219a:	0f b6       	in	r0, 0x3f	; 63
    219c:	f8 94       	cli
    219e:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    21a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    21a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    21a4:	80 81       	ld	r24, Z
    21a6:	91 81       	ldd	r25, Z+1	; 0x01
    21a8:	99 87       	std	Y+9, r25	; 0x09
    21aa:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    21ac:	88 85       	ldd	r24, Y+8	; 0x08
    21ae:	99 85       	ldd	r25, Y+9	; 0x09
    21b0:	2e 85       	ldd	r18, Y+14	; 0x0e
    21b2:	3f 85       	ldd	r19, Y+15	; 0x0f
    21b4:	b9 01       	movw	r22, r18
    21b6:	49 89       	ldd	r20, Y+17	; 0x11
    21b8:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <prvTestWaitCondition>
    21bc:	88 23       	and	r24, r24
    21be:	89 f0       	breq	.+34     	; 0x21e2 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    21c0:	88 89       	ldd	r24, Y+16	; 0x10
    21c2:	88 23       	and	r24, r24
    21c4:	71 f0       	breq	.+28     	; 0x21e2 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    21c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    21c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    21ca:	20 81       	ld	r18, Z
    21cc:	31 81       	ldd	r19, Z+1	; 0x01
    21ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    21d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    21d2:	80 95       	com	r24
    21d4:	90 95       	com	r25
    21d6:	82 23       	and	r24, r18
    21d8:	93 23       	and	r25, r19
    21da:	ea 85       	ldd	r30, Y+10	; 0x0a
    21dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    21de:	91 83       	std	Z+1, r25	; 0x01
    21e0:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    21e2:	81 e0       	ldi	r24, 0x01	; 1
    21e4:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    21e6:	0f 90       	pop	r0
    21e8:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    21ea:	88 85       	ldd	r24, Y+8	; 0x08
    21ec:	99 85       	ldd	r25, Y+9	; 0x09
    21ee:	90 70       	andi	r25, 0x00	; 0
    21f0:	99 87       	std	Y+9, r25	; 0x09
    21f2:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    21f4:	88 85       	ldd	r24, Y+8	; 0x08
    21f6:	99 85       	ldd	r25, Y+9	; 0x09
}
    21f8:	63 96       	adiw	r28, 0x13	; 19
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	de bf       	out	0x3e, r29	; 62
    2200:	0f be       	out	0x3f, r0	; 63
    2202:	cd bf       	out	0x3d, r28	; 61
    2204:	cf 91       	pop	r28
    2206:	df 91       	pop	r29
    2208:	1f 91       	pop	r17
    220a:	0f 91       	pop	r16
    220c:	08 95       	ret

0000220e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    220e:	df 93       	push	r29
    2210:	cf 93       	push	r28
    2212:	cd b7       	in	r28, 0x3d	; 61
    2214:	de b7       	in	r29, 0x3e	; 62
    2216:	28 97       	sbiw	r28, 0x08	; 8
    2218:	0f b6       	in	r0, 0x3f	; 63
    221a:	f8 94       	cli
    221c:	de bf       	out	0x3e, r29	; 62
    221e:	0f be       	out	0x3f, r0	; 63
    2220:	cd bf       	out	0x3d, r28	; 61
    2222:	9e 83       	std	Y+6, r25	; 0x06
    2224:	8d 83       	std	Y+5, r24	; 0x05
    2226:	78 87       	std	Y+8, r23	; 0x08
    2228:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    222a:	8d 81       	ldd	r24, Y+5	; 0x05
    222c:	9e 81       	ldd	r25, Y+6	; 0x06
    222e:	9c 83       	std	Y+4, r25	; 0x04
    2230:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    2232:	0f b6       	in	r0, 0x3f	; 63
    2234:	f8 94       	cli
    2236:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    2238:	eb 81       	ldd	r30, Y+3	; 0x03
    223a:	fc 81       	ldd	r31, Y+4	; 0x04
    223c:	80 81       	ld	r24, Z
    223e:	91 81       	ldd	r25, Z+1	; 0x01
    2240:	9a 83       	std	Y+2, r25	; 0x02
    2242:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2244:	eb 81       	ldd	r30, Y+3	; 0x03
    2246:	fc 81       	ldd	r31, Y+4	; 0x04
    2248:	20 81       	ld	r18, Z
    224a:	31 81       	ldd	r19, Z+1	; 0x01
    224c:	8f 81       	ldd	r24, Y+7	; 0x07
    224e:	98 85       	ldd	r25, Y+8	; 0x08
    2250:	80 95       	com	r24
    2252:	90 95       	com	r25
    2254:	82 23       	and	r24, r18
    2256:	93 23       	and	r25, r19
    2258:	eb 81       	ldd	r30, Y+3	; 0x03
    225a:	fc 81       	ldd	r31, Y+4	; 0x04
    225c:	91 83       	std	Z+1, r25	; 0x01
    225e:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    2260:	0f 90       	pop	r0
    2262:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2264:	89 81       	ldd	r24, Y+1	; 0x01
    2266:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2268:	28 96       	adiw	r28, 0x08	; 8
    226a:	0f b6       	in	r0, 0x3f	; 63
    226c:	f8 94       	cli
    226e:	de bf       	out	0x3e, r29	; 62
    2270:	0f be       	out	0x3f, r0	; 63
    2272:	cd bf       	out	0x3d, r28	; 61
    2274:	cf 91       	pop	r28
    2276:	df 91       	pop	r29
    2278:	08 95       	ret

0000227a <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    227a:	df 93       	push	r29
    227c:	cf 93       	push	r28
    227e:	cd b7       	in	r28, 0x3d	; 61
    2280:	de b7       	in	r29, 0x3e	; 62
    2282:	27 97       	sbiw	r28, 0x07	; 7
    2284:	0f b6       	in	r0, 0x3f	; 63
    2286:	f8 94       	cli
    2288:	de bf       	out	0x3e, r29	; 62
    228a:	0f be       	out	0x3f, r0	; 63
    228c:	cd bf       	out	0x3d, r28	; 61
    228e:	9f 83       	std	Y+7, r25	; 0x07
    2290:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    2292:	8e 81       	ldd	r24, Y+6	; 0x06
    2294:	9f 81       	ldd	r25, Y+7	; 0x07
    2296:	9c 83       	std	Y+4, r25	; 0x04
    2298:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    229a:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    229c:	eb 81       	ldd	r30, Y+3	; 0x03
    229e:	fc 81       	ldd	r31, Y+4	; 0x04
    22a0:	80 81       	ld	r24, Z
    22a2:	91 81       	ldd	r25, Z+1	; 0x01
    22a4:	9a 83       	std	Y+2, r25	; 0x02
    22a6:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    22a8:	89 81       	ldd	r24, Y+1	; 0x01
    22aa:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    22ac:	27 96       	adiw	r28, 0x07	; 7
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	de bf       	out	0x3e, r29	; 62
    22b4:	0f be       	out	0x3f, r0	; 63
    22b6:	cd bf       	out	0x3d, r28	; 61
    22b8:	cf 91       	pop	r28
    22ba:	df 91       	pop	r29
    22bc:	08 95       	ret

000022be <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    22be:	df 93       	push	r29
    22c0:	cf 93       	push	r28
    22c2:	cd b7       	in	r28, 0x3d	; 61
    22c4:	de b7       	in	r29, 0x3e	; 62
    22c6:	65 97       	sbiw	r28, 0x15	; 21
    22c8:	0f b6       	in	r0, 0x3f	; 63
    22ca:	f8 94       	cli
    22cc:	de bf       	out	0x3e, r29	; 62
    22ce:	0f be       	out	0x3f, r0	; 63
    22d0:	cd bf       	out	0x3d, r28	; 61
    22d2:	9b 8b       	std	Y+19, r25	; 0x13
    22d4:	8a 8b       	std	Y+18, r24	; 0x12
    22d6:	7d 8b       	std	Y+21, r23	; 0x15
    22d8:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    22da:	19 86       	std	Y+9, r1	; 0x09
    22dc:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    22de:	8a 89       	ldd	r24, Y+18	; 0x12
    22e0:	9b 89       	ldd	r25, Y+19	; 0x13
    22e2:	9b 83       	std	Y+3, r25	; 0x03
    22e4:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    22e6:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    22e8:	8a 81       	ldd	r24, Y+2	; 0x02
    22ea:	9b 81       	ldd	r25, Y+3	; 0x03
    22ec:	02 96       	adiw	r24, 0x02	; 2
    22ee:	9b 87       	std	Y+11, r25	; 0x0b
    22f0:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    22f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    22f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    22f6:	03 96       	adiw	r24, 0x03	; 3
    22f8:	9d 87       	std	Y+13, r25	; 0x0d
    22fa:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    22fc:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    2300:	ea 85       	ldd	r30, Y+10	; 0x0a
    2302:	fb 85       	ldd	r31, Y+11	; 0x0b
    2304:	85 81       	ldd	r24, Z+5	; 0x05
    2306:	96 81       	ldd	r25, Z+6	; 0x06
    2308:	99 8b       	std	Y+17, r25	; 0x11
    230a:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    230c:	ea 81       	ldd	r30, Y+2	; 0x02
    230e:	fb 81       	ldd	r31, Y+3	; 0x03
    2310:	20 81       	ld	r18, Z
    2312:	31 81       	ldd	r19, Z+1	; 0x01
    2314:	8c 89       	ldd	r24, Y+20	; 0x14
    2316:	9d 89       	ldd	r25, Y+21	; 0x15
    2318:	82 2b       	or	r24, r18
    231a:	93 2b       	or	r25, r19
    231c:	ea 81       	ldd	r30, Y+2	; 0x02
    231e:	fb 81       	ldd	r31, Y+3	; 0x03
    2320:	91 83       	std	Z+1, r25	; 0x01
    2322:	80 83       	st	Z, r24
    2324:	59 c0       	rjmp	.+178    	; 0x23d8 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    2326:	e8 89       	ldd	r30, Y+16	; 0x10
    2328:	f9 89       	ldd	r31, Y+17	; 0x11
    232a:	82 81       	ldd	r24, Z+2	; 0x02
    232c:	93 81       	ldd	r25, Z+3	; 0x03
    232e:	9f 87       	std	Y+15, r25	; 0x0f
    2330:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2332:	e8 89       	ldd	r30, Y+16	; 0x10
    2334:	f9 89       	ldd	r31, Y+17	; 0x11
    2336:	80 81       	ld	r24, Z
    2338:	91 81       	ldd	r25, Z+1	; 0x01
    233a:	9f 83       	std	Y+7, r25	; 0x07
    233c:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    233e:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2340:	8e 81       	ldd	r24, Y+6	; 0x06
    2342:	9f 81       	ldd	r25, Y+7	; 0x07
    2344:	80 70       	andi	r24, 0x00	; 0
    2346:	9d 83       	std	Y+5, r25	; 0x05
    2348:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    234a:	8e 81       	ldd	r24, Y+6	; 0x06
    234c:	9f 81       	ldd	r25, Y+7	; 0x07
    234e:	90 70       	andi	r25, 0x00	; 0
    2350:	9f 83       	std	Y+7, r25	; 0x07
    2352:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2354:	8c 81       	ldd	r24, Y+4	; 0x04
    2356:	9d 81       	ldd	r25, Y+5	; 0x05
    2358:	80 70       	andi	r24, 0x00	; 0
    235a:	94 70       	andi	r25, 0x04	; 4
    235c:	00 97       	sbiw	r24, 0x00	; 0
    235e:	69 f4       	brne	.+26     	; 0x237a <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2360:	ea 81       	ldd	r30, Y+2	; 0x02
    2362:	fb 81       	ldd	r31, Y+3	; 0x03
    2364:	20 81       	ld	r18, Z
    2366:	31 81       	ldd	r19, Z+1	; 0x01
    2368:	8e 81       	ldd	r24, Y+6	; 0x06
    236a:	9f 81       	ldd	r25, Y+7	; 0x07
    236c:	82 23       	and	r24, r18
    236e:	93 23       	and	r25, r19
    2370:	00 97       	sbiw	r24, 0x00	; 0
    2372:	91 f0       	breq	.+36     	; 0x2398 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	89 83       	std	Y+1, r24	; 0x01
    2378:	0f c0       	rjmp	.+30     	; 0x2398 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    237a:	ea 81       	ldd	r30, Y+2	; 0x02
    237c:	fb 81       	ldd	r31, Y+3	; 0x03
    237e:	20 81       	ld	r18, Z
    2380:	31 81       	ldd	r19, Z+1	; 0x01
    2382:	8e 81       	ldd	r24, Y+6	; 0x06
    2384:	9f 81       	ldd	r25, Y+7	; 0x07
    2386:	28 23       	and	r18, r24
    2388:	39 23       	and	r19, r25
    238a:	8e 81       	ldd	r24, Y+6	; 0x06
    238c:	9f 81       	ldd	r25, Y+7	; 0x07
    238e:	28 17       	cp	r18, r24
    2390:	39 07       	cpc	r19, r25
    2392:	11 f4       	brne	.+4      	; 0x2398 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    2394:	81 e0       	ldi	r24, 0x01	; 1
    2396:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    2398:	89 81       	ldd	r24, Y+1	; 0x01
    239a:	88 23       	and	r24, r24
    239c:	c9 f0       	breq	.+50     	; 0x23d0 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    239e:	8c 81       	ldd	r24, Y+4	; 0x04
    23a0:	9d 81       	ldd	r25, Y+5	; 0x05
    23a2:	80 70       	andi	r24, 0x00	; 0
    23a4:	91 70       	andi	r25, 0x01	; 1
    23a6:	00 97       	sbiw	r24, 0x00	; 0
    23a8:	41 f0       	breq	.+16     	; 0x23ba <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    23aa:	88 85       	ldd	r24, Y+8	; 0x08
    23ac:	99 85       	ldd	r25, Y+9	; 0x09
    23ae:	2e 81       	ldd	r18, Y+6	; 0x06
    23b0:	3f 81       	ldd	r19, Y+7	; 0x07
    23b2:	82 2b       	or	r24, r18
    23b4:	93 2b       	or	r25, r19
    23b6:	99 87       	std	Y+9, r25	; 0x09
    23b8:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    23ba:	ea 81       	ldd	r30, Y+2	; 0x02
    23bc:	fb 81       	ldd	r31, Y+3	; 0x03
    23be:	80 81       	ld	r24, Z
    23c0:	91 81       	ldd	r25, Z+1	; 0x01
    23c2:	9c 01       	movw	r18, r24
    23c4:	32 60       	ori	r19, 0x02	; 2
    23c6:	88 89       	ldd	r24, Y+16	; 0x10
    23c8:	99 89       	ldd	r25, Y+17	; 0x11
    23ca:	b9 01       	movw	r22, r18
    23cc:	0e 94 79 33 	call	0x66f2	; 0x66f2 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    23d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    23d2:	9f 85       	ldd	r25, Y+15	; 0x0f
    23d4:	99 8b       	std	Y+17, r25	; 0x11
    23d6:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    23d8:	28 89       	ldd	r18, Y+16	; 0x10
    23da:	39 89       	ldd	r19, Y+17	; 0x11
    23dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    23de:	9d 85       	ldd	r25, Y+13	; 0x0d
    23e0:	28 17       	cp	r18, r24
    23e2:	39 07       	cpc	r19, r25
    23e4:	09 f0       	breq	.+2      	; 0x23e8 <xEventGroupSetBits+0x12a>
    23e6:	9f cf       	rjmp	.-194    	; 0x2326 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    23e8:	ea 81       	ldd	r30, Y+2	; 0x02
    23ea:	fb 81       	ldd	r31, Y+3	; 0x03
    23ec:	20 81       	ld	r18, Z
    23ee:	31 81       	ldd	r19, Z+1	; 0x01
    23f0:	88 85       	ldd	r24, Y+8	; 0x08
    23f2:	99 85       	ldd	r25, Y+9	; 0x09
    23f4:	80 95       	com	r24
    23f6:	90 95       	com	r25
    23f8:	82 23       	and	r24, r18
    23fa:	93 23       	and	r25, r19
    23fc:	ea 81       	ldd	r30, Y+2	; 0x02
    23fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2400:	91 83       	std	Z+1, r25	; 0x01
    2402:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    2404:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2408:	ea 81       	ldd	r30, Y+2	; 0x02
    240a:	fb 81       	ldd	r31, Y+3	; 0x03
    240c:	80 81       	ld	r24, Z
    240e:	91 81       	ldd	r25, Z+1	; 0x01
}
    2410:	65 96       	adiw	r28, 0x15	; 21
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	de bf       	out	0x3e, r29	; 62
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	cd bf       	out	0x3d, r28	; 61
    241c:	cf 91       	pop	r28
    241e:	df 91       	pop	r29
    2420:	08 95       	ret

00002422 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2422:	df 93       	push	r29
    2424:	cf 93       	push	r28
    2426:	00 d0       	rcall	.+0      	; 0x2428 <vEventGroupDelete+0x6>
    2428:	00 d0       	rcall	.+0      	; 0x242a <vEventGroupDelete+0x8>
    242a:	00 d0       	rcall	.+0      	; 0x242c <vEventGroupDelete+0xa>
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	9e 83       	std	Y+6, r25	; 0x06
    2432:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    2434:	8d 81       	ldd	r24, Y+5	; 0x05
    2436:	9e 81       	ldd	r25, Y+6	; 0x06
    2438:	9c 83       	std	Y+4, r25	; 0x04
    243a:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    243c:	8b 81       	ldd	r24, Y+3	; 0x03
    243e:	9c 81       	ldd	r25, Y+4	; 0x04
    2440:	02 96       	adiw	r24, 0x02	; 2
    2442:	9a 83       	std	Y+2, r25	; 0x02
    2444:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2446:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
    244a:	08 c0       	rjmp	.+16     	; 0x245c <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    244c:	e9 81       	ldd	r30, Y+1	; 0x01
    244e:	fa 81       	ldd	r31, Y+2	; 0x02
    2450:	85 81       	ldd	r24, Z+5	; 0x05
    2452:	96 81       	ldd	r25, Z+6	; 0x06
    2454:	60 e0       	ldi	r22, 0x00	; 0
    2456:	72 e0       	ldi	r23, 0x02	; 2
    2458:	0e 94 79 33 	call	0x66f2	; 0x66f2 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    245c:	e9 81       	ldd	r30, Y+1	; 0x01
    245e:	fa 81       	ldd	r31, Y+2	; 0x02
    2460:	80 81       	ld	r24, Z
    2462:	88 23       	and	r24, r24
    2464:	99 f7       	brne	.-26     	; 0x244c <vEventGroupDelete+0x2a>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    2466:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    246a:	8b 81       	ldd	r24, Y+3	; 0x03
    246c:	9c 81       	ldd	r25, Y+4	; 0x04
    246e:	0e 94 a3 13 	call	0x2746	; 0x2746 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2472:	26 96       	adiw	r28, 0x06	; 6
    2474:	0f b6       	in	r0, 0x3f	; 63
    2476:	f8 94       	cli
    2478:	de bf       	out	0x3e, r29	; 62
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	cd bf       	out	0x3d, r28	; 61
    247e:	cf 91       	pop	r28
    2480:	df 91       	pop	r29
    2482:	08 95       	ret

00002484 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2484:	df 93       	push	r29
    2486:	cf 93       	push	r28
    2488:	00 d0       	rcall	.+0      	; 0x248a <vEventGroupSetBitsCallback+0x6>
    248a:	00 d0       	rcall	.+0      	; 0x248c <vEventGroupSetBitsCallback+0x8>
    248c:	00 d0       	rcall	.+0      	; 0x248e <vEventGroupSetBitsCallback+0xa>
    248e:	cd b7       	in	r28, 0x3d	; 61
    2490:	de b7       	in	r29, 0x3e	; 62
    2492:	9a 83       	std	Y+2, r25	; 0x02
    2494:	89 83       	std	Y+1, r24	; 0x01
    2496:	4b 83       	std	Y+3, r20	; 0x03
    2498:	5c 83       	std	Y+4, r21	; 0x04
    249a:	6d 83       	std	Y+5, r22	; 0x05
    249c:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    249e:	89 81       	ldd	r24, Y+1	; 0x01
    24a0:	9a 81       	ldd	r25, Y+2	; 0x02
    24a2:	2b 81       	ldd	r18, Y+3	; 0x03
    24a4:	3c 81       	ldd	r19, Y+4	; 0x04
    24a6:	b9 01       	movw	r22, r18
    24a8:	0e 94 5f 11 	call	0x22be	; 0x22be <xEventGroupSetBits>
}
    24ac:	26 96       	adiw	r28, 0x06	; 6
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	de bf       	out	0x3e, r29	; 62
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	cd bf       	out	0x3d, r28	; 61
    24b8:	cf 91       	pop	r28
    24ba:	df 91       	pop	r29
    24bc:	08 95       	ret

000024be <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    24be:	df 93       	push	r29
    24c0:	cf 93       	push	r28
    24c2:	00 d0       	rcall	.+0      	; 0x24c4 <vEventGroupClearBitsCallback+0x6>
    24c4:	00 d0       	rcall	.+0      	; 0x24c6 <vEventGroupClearBitsCallback+0x8>
    24c6:	00 d0       	rcall	.+0      	; 0x24c8 <vEventGroupClearBitsCallback+0xa>
    24c8:	cd b7       	in	r28, 0x3d	; 61
    24ca:	de b7       	in	r29, 0x3e	; 62
    24cc:	9a 83       	std	Y+2, r25	; 0x02
    24ce:	89 83       	std	Y+1, r24	; 0x01
    24d0:	4b 83       	std	Y+3, r20	; 0x03
    24d2:	5c 83       	std	Y+4, r21	; 0x04
    24d4:	6d 83       	std	Y+5, r22	; 0x05
    24d6:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    24d8:	89 81       	ldd	r24, Y+1	; 0x01
    24da:	9a 81       	ldd	r25, Y+2	; 0x02
    24dc:	2b 81       	ldd	r18, Y+3	; 0x03
    24de:	3c 81       	ldd	r19, Y+4	; 0x04
    24e0:	b9 01       	movw	r22, r18
    24e2:	0e 94 07 11 	call	0x220e	; 0x220e <xEventGroupClearBits>
}
    24e6:	26 96       	adiw	r28, 0x06	; 6
    24e8:	0f b6       	in	r0, 0x3f	; 63
    24ea:	f8 94       	cli
    24ec:	de bf       	out	0x3e, r29	; 62
    24ee:	0f be       	out	0x3f, r0	; 63
    24f0:	cd bf       	out	0x3d, r28	; 61
    24f2:	cf 91       	pop	r28
    24f4:	df 91       	pop	r29
    24f6:	08 95       	ret

000024f8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    24f8:	df 93       	push	r29
    24fa:	cf 93       	push	r28
    24fc:	00 d0       	rcall	.+0      	; 0x24fe <prvTestWaitCondition+0x6>
    24fe:	00 d0       	rcall	.+0      	; 0x2500 <prvTestWaitCondition+0x8>
    2500:	00 d0       	rcall	.+0      	; 0x2502 <prvTestWaitCondition+0xa>
    2502:	cd b7       	in	r28, 0x3d	; 61
    2504:	de b7       	in	r29, 0x3e	; 62
    2506:	9b 83       	std	Y+3, r25	; 0x03
    2508:	8a 83       	std	Y+2, r24	; 0x02
    250a:	7d 83       	std	Y+5, r23	; 0x05
    250c:	6c 83       	std	Y+4, r22	; 0x04
    250e:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    2510:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    2512:	8e 81       	ldd	r24, Y+6	; 0x06
    2514:	88 23       	and	r24, r24
    2516:	59 f4       	brne	.+22     	; 0x252e <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2518:	8a 81       	ldd	r24, Y+2	; 0x02
    251a:	9b 81       	ldd	r25, Y+3	; 0x03
    251c:	2c 81       	ldd	r18, Y+4	; 0x04
    251e:	3d 81       	ldd	r19, Y+5	; 0x05
    2520:	82 23       	and	r24, r18
    2522:	93 23       	and	r25, r19
    2524:	00 97       	sbiw	r24, 0x00	; 0
    2526:	81 f0       	breq	.+32     	; 0x2548 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2528:	81 e0       	ldi	r24, 0x01	; 1
    252a:	89 83       	std	Y+1, r24	; 0x01
    252c:	0d c0       	rjmp	.+26     	; 0x2548 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    252e:	2a 81       	ldd	r18, Y+2	; 0x02
    2530:	3b 81       	ldd	r19, Y+3	; 0x03
    2532:	8c 81       	ldd	r24, Y+4	; 0x04
    2534:	9d 81       	ldd	r25, Y+5	; 0x05
    2536:	28 23       	and	r18, r24
    2538:	39 23       	and	r19, r25
    253a:	8c 81       	ldd	r24, Y+4	; 0x04
    253c:	9d 81       	ldd	r25, Y+5	; 0x05
    253e:	28 17       	cp	r18, r24
    2540:	39 07       	cpc	r19, r25
    2542:	11 f4       	brne	.+4      	; 0x2548 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2544:	81 e0       	ldi	r24, 0x01	; 1
    2546:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2548:	89 81       	ldd	r24, Y+1	; 0x01
}
    254a:	26 96       	adiw	r28, 0x06	; 6
    254c:	0f b6       	in	r0, 0x3f	; 63
    254e:	f8 94       	cli
    2550:	de bf       	out	0x3e, r29	; 62
    2552:	0f be       	out	0x3f, r0	; 63
    2554:	cd bf       	out	0x3d, r28	; 61
    2556:	cf 91       	pop	r28
    2558:	df 91       	pop	r29
    255a:	08 95       	ret

0000255c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    255c:	df 93       	push	r29
    255e:	cf 93       	push	r28
    2560:	cd b7       	in	r28, 0x3d	; 61
    2562:	de b7       	in	r29, 0x3e	; 62
    2564:	2a 97       	sbiw	r28, 0x0a	; 10
    2566:	0f b6       	in	r0, 0x3f	; 63
    2568:	f8 94       	cli
    256a:	de bf       	out	0x3e, r29	; 62
    256c:	0f be       	out	0x3f, r0	; 63
    256e:	cd bf       	out	0x3d, r28	; 61
    2570:	9a 87       	std	Y+10, r25	; 0x0a
    2572:	89 87       	std	Y+9, r24	; 0x09
	BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	void *pvReturn = NULL;
    2574:	1a 82       	std	Y+2, r1	; 0x02
    2576:	19 82       	std	Y+1, r1	; 0x01

	vTaskSuspendAll();
    2578:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    257c:	80 91 a9 00 	lds	r24, 0x00A9
    2580:	90 91 aa 00 	lds	r25, 0x00AA
    2584:	00 97       	sbiw	r24, 0x00	; 0
    2586:	11 f4       	brne	.+4      	; 0x258c <pvPortMalloc+0x30>
		{
			prvHeapInit();
    2588:	0e 94 25 14 	call	0x284a	; 0x284a <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    258c:	80 91 af 00 	lds	r24, 0x00AF
    2590:	90 91 b0 00 	lds	r25, 0x00B0
    2594:	29 85       	ldd	r18, Y+9	; 0x09
    2596:	3a 85       	ldd	r19, Y+10	; 0x0a
    2598:	82 23       	and	r24, r18
    259a:	93 23       	and	r25, r19
    259c:	00 97       	sbiw	r24, 0x00	; 0
    259e:	09 f0       	breq	.+2      	; 0x25a2 <pvPortMalloc+0x46>
    25a0:	c5 c0       	rjmp	.+394    	; 0x272c <pvPortMalloc+0x1d0>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    25a2:	89 85       	ldd	r24, Y+9	; 0x09
    25a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    25a6:	00 97       	sbiw	r24, 0x00	; 0
    25a8:	51 f0       	breq	.+20     	; 0x25be <pvPortMalloc+0x62>
			{
				xWantedSize += xHeapStructSize;
    25aa:	80 91 a5 00 	lds	r24, 0x00A5
    25ae:	90 91 a6 00 	lds	r25, 0x00A6
    25b2:	29 85       	ldd	r18, Y+9	; 0x09
    25b4:	3a 85       	ldd	r19, Y+10	; 0x0a
    25b6:	82 0f       	add	r24, r18
    25b8:	93 1f       	adc	r25, r19
    25ba:	9a 87       	std	Y+10, r25	; 0x0a
    25bc:	89 87       	std	Y+9, r24	; 0x09
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    25be:	89 85       	ldd	r24, Y+9	; 0x09
    25c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    25c2:	00 97       	sbiw	r24, 0x00	; 0
    25c4:	09 f4       	brne	.+2      	; 0x25c8 <pvPortMalloc+0x6c>
    25c6:	b2 c0       	rjmp	.+356    	; 0x272c <pvPortMalloc+0x1d0>
    25c8:	20 91 ab 00 	lds	r18, 0x00AB
    25cc:	30 91 ac 00 	lds	r19, 0x00AC
    25d0:	89 85       	ldd	r24, Y+9	; 0x09
    25d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    25d4:	28 17       	cp	r18, r24
    25d6:	39 07       	cpc	r19, r25
    25d8:	08 f4       	brcc	.+2      	; 0x25dc <pvPortMalloc+0x80>
    25da:	a8 c0       	rjmp	.+336    	; 0x272c <pvPortMalloc+0x1d0>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    25dc:	8d e8       	ldi	r24, 0x8D	; 141
    25de:	96 e0       	ldi	r25, 0x06	; 6
    25e0:	9e 83       	std	Y+6, r25	; 0x06
    25e2:	8d 83       	std	Y+5, r24	; 0x05
				pxBlock = xStart.pxNextFreeBlock;
    25e4:	80 91 8d 06 	lds	r24, 0x068D
    25e8:	90 91 8e 06 	lds	r25, 0x068E
    25ec:	98 87       	std	Y+8, r25	; 0x08
    25ee:	8f 83       	std	Y+7, r24	; 0x07
    25f0:	0a c0       	rjmp	.+20     	; 0x2606 <pvPortMalloc+0xaa>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
				{
					pxPreviousBlock = pxBlock;
    25f2:	8f 81       	ldd	r24, Y+7	; 0x07
    25f4:	98 85       	ldd	r25, Y+8	; 0x08
    25f6:	9e 83       	std	Y+6, r25	; 0x06
    25f8:	8d 83       	std	Y+5, r24	; 0x05
					pxBlock = pxBlock->pxNextFreeBlock;
    25fa:	ef 81       	ldd	r30, Y+7	; 0x07
    25fc:	f8 85       	ldd	r31, Y+8	; 0x08
    25fe:	80 81       	ld	r24, Z
    2600:	91 81       	ldd	r25, Z+1	; 0x01
    2602:	98 87       	std	Y+8, r25	; 0x08
    2604:	8f 83       	std	Y+7, r24	; 0x07
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    2606:	ef 81       	ldd	r30, Y+7	; 0x07
    2608:	f8 85       	ldd	r31, Y+8	; 0x08
    260a:	22 81       	ldd	r18, Z+2	; 0x02
    260c:	33 81       	ldd	r19, Z+3	; 0x03
    260e:	89 85       	ldd	r24, Y+9	; 0x09
    2610:	9a 85       	ldd	r25, Y+10	; 0x0a
    2612:	28 17       	cp	r18, r24
    2614:	39 07       	cpc	r19, r25
    2616:	30 f4       	brcc	.+12     	; 0x2624 <pvPortMalloc+0xc8>
    2618:	ef 81       	ldd	r30, Y+7	; 0x07
    261a:	f8 85       	ldd	r31, Y+8	; 0x08
    261c:	80 81       	ld	r24, Z
    261e:	91 81       	ldd	r25, Z+1	; 0x01
    2620:	00 97       	sbiw	r24, 0x00	; 0
    2622:	39 f7       	brne	.-50     	; 0x25f2 <pvPortMalloc+0x96>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    2624:	20 91 a9 00 	lds	r18, 0x00A9
    2628:	30 91 aa 00 	lds	r19, 0x00AA
    262c:	8f 81       	ldd	r24, Y+7	; 0x07
    262e:	98 85       	ldd	r25, Y+8	; 0x08
    2630:	82 17       	cp	r24, r18
    2632:	93 07       	cpc	r25, r19
    2634:	09 f4       	brne	.+2      	; 0x2638 <pvPortMalloc+0xdc>
    2636:	7a c0       	rjmp	.+244    	; 0x272c <pvPortMalloc+0x1d0>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    2638:	ed 81       	ldd	r30, Y+5	; 0x05
    263a:	fe 81       	ldd	r31, Y+6	; 0x06
    263c:	20 81       	ld	r18, Z
    263e:	31 81       	ldd	r19, Z+1	; 0x01
    2640:	80 91 a5 00 	lds	r24, 0x00A5
    2644:	90 91 a6 00 	lds	r25, 0x00A6
    2648:	82 0f       	add	r24, r18
    264a:	93 1f       	adc	r25, r19
    264c:	9a 83       	std	Y+2, r25	; 0x02
    264e:	89 83       	std	Y+1, r24	; 0x01

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    2650:	ef 81       	ldd	r30, Y+7	; 0x07
    2652:	f8 85       	ldd	r31, Y+8	; 0x08
    2654:	80 81       	ld	r24, Z
    2656:	91 81       	ldd	r25, Z+1	; 0x01
    2658:	ed 81       	ldd	r30, Y+5	; 0x05
    265a:	fe 81       	ldd	r31, Y+6	; 0x06
    265c:	91 83       	std	Z+1, r25	; 0x01
    265e:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    2660:	ef 81       	ldd	r30, Y+7	; 0x07
    2662:	f8 85       	ldd	r31, Y+8	; 0x08
    2664:	22 81       	ldd	r18, Z+2	; 0x02
    2666:	33 81       	ldd	r19, Z+3	; 0x03
    2668:	89 85       	ldd	r24, Y+9	; 0x09
    266a:	9a 85       	ldd	r25, Y+10	; 0x0a
    266c:	28 1b       	sub	r18, r24
    266e:	39 0b       	sbc	r19, r25
    2670:	80 91 a5 00 	lds	r24, 0x00A5
    2674:	90 91 a6 00 	lds	r25, 0x00A6
    2678:	88 0f       	add	r24, r24
    267a:	99 1f       	adc	r25, r25
    267c:	82 17       	cp	r24, r18
    267e:	93 07       	cpc	r25, r19
    2680:	00 f5       	brcc	.+64     	; 0x26c2 <pvPortMalloc+0x166>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    2682:	2f 81       	ldd	r18, Y+7	; 0x07
    2684:	38 85       	ldd	r19, Y+8	; 0x08
    2686:	89 85       	ldd	r24, Y+9	; 0x09
    2688:	9a 85       	ldd	r25, Y+10	; 0x0a
    268a:	82 0f       	add	r24, r18
    268c:	93 1f       	adc	r25, r19
    268e:	9c 83       	std	Y+4, r25	; 0x04
    2690:	8b 83       	std	Y+3, r24	; 0x03
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    2692:	ef 81       	ldd	r30, Y+7	; 0x07
    2694:	f8 85       	ldd	r31, Y+8	; 0x08
    2696:	22 81       	ldd	r18, Z+2	; 0x02
    2698:	33 81       	ldd	r19, Z+3	; 0x03
    269a:	89 85       	ldd	r24, Y+9	; 0x09
    269c:	9a 85       	ldd	r25, Y+10	; 0x0a
    269e:	a9 01       	movw	r20, r18
    26a0:	48 1b       	sub	r20, r24
    26a2:	59 0b       	sbc	r21, r25
    26a4:	ca 01       	movw	r24, r20
    26a6:	eb 81       	ldd	r30, Y+3	; 0x03
    26a8:	fc 81       	ldd	r31, Y+4	; 0x04
    26aa:	93 83       	std	Z+3, r25	; 0x03
    26ac:	82 83       	std	Z+2, r24	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    26ae:	ef 81       	ldd	r30, Y+7	; 0x07
    26b0:	f8 85       	ldd	r31, Y+8	; 0x08
    26b2:	89 85       	ldd	r24, Y+9	; 0x09
    26b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    26b6:	93 83       	std	Z+3, r25	; 0x03
    26b8:	82 83       	std	Z+2, r24	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    26ba:	8b 81       	ldd	r24, Y+3	; 0x03
    26bc:	9c 81       	ldd	r25, Y+4	; 0x04
    26be:	0e 94 ba 14 	call	0x2974	; 0x2974 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    26c2:	20 91 ab 00 	lds	r18, 0x00AB
    26c6:	30 91 ac 00 	lds	r19, 0x00AC
    26ca:	ef 81       	ldd	r30, Y+7	; 0x07
    26cc:	f8 85       	ldd	r31, Y+8	; 0x08
    26ce:	82 81       	ldd	r24, Z+2	; 0x02
    26d0:	93 81       	ldd	r25, Z+3	; 0x03
    26d2:	a9 01       	movw	r20, r18
    26d4:	48 1b       	sub	r20, r24
    26d6:	59 0b       	sbc	r21, r25
    26d8:	ca 01       	movw	r24, r20
    26da:	90 93 ac 00 	sts	0x00AC, r25
    26de:	80 93 ab 00 	sts	0x00AB, r24

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    26e2:	20 91 ab 00 	lds	r18, 0x00AB
    26e6:	30 91 ac 00 	lds	r19, 0x00AC
    26ea:	80 91 ad 00 	lds	r24, 0x00AD
    26ee:	90 91 ae 00 	lds	r25, 0x00AE
    26f2:	28 17       	cp	r18, r24
    26f4:	39 07       	cpc	r19, r25
    26f6:	40 f4       	brcc	.+16     	; 0x2708 <pvPortMalloc+0x1ac>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    26f8:	80 91 ab 00 	lds	r24, 0x00AB
    26fc:	90 91 ac 00 	lds	r25, 0x00AC
    2700:	90 93 ae 00 	sts	0x00AE, r25
    2704:	80 93 ad 00 	sts	0x00AD, r24
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    2708:	ef 81       	ldd	r30, Y+7	; 0x07
    270a:	f8 85       	ldd	r31, Y+8	; 0x08
    270c:	22 81       	ldd	r18, Z+2	; 0x02
    270e:	33 81       	ldd	r19, Z+3	; 0x03
    2710:	80 91 af 00 	lds	r24, 0x00AF
    2714:	90 91 b0 00 	lds	r25, 0x00B0
    2718:	82 2b       	or	r24, r18
    271a:	93 2b       	or	r25, r19
    271c:	ef 81       	ldd	r30, Y+7	; 0x07
    271e:	f8 85       	ldd	r31, Y+8	; 0x08
    2720:	93 83       	std	Z+3, r25	; 0x03
    2722:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    2724:	ef 81       	ldd	r30, Y+7	; 0x07
    2726:	f8 85       	ldd	r31, Y+8	; 0x08
    2728:	11 82       	std	Z+1, r1	; 0x01
    272a:	10 82       	st	Z, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    272c:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
		}
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
    2730:	89 81       	ldd	r24, Y+1	; 0x01
    2732:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2734:	2a 96       	adiw	r28, 0x0a	; 10
    2736:	0f b6       	in	r0, 0x3f	; 63
    2738:	f8 94       	cli
    273a:	de bf       	out	0x3e, r29	; 62
    273c:	0f be       	out	0x3f, r0	; 63
    273e:	cd bf       	out	0x3d, r28	; 61
    2740:	cf 91       	pop	r28
    2742:	df 91       	pop	r29
    2744:	08 95       	ret

00002746 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2746:	df 93       	push	r29
    2748:	cf 93       	push	r28
    274a:	00 d0       	rcall	.+0      	; 0x274c <vPortFree+0x6>
    274c:	00 d0       	rcall	.+0      	; 0x274e <vPortFree+0x8>
    274e:	00 d0       	rcall	.+0      	; 0x2750 <vPortFree+0xa>
    2750:	cd b7       	in	r28, 0x3d	; 61
    2752:	de b7       	in	r29, 0x3e	; 62
    2754:	9e 83       	std	Y+6, r25	; 0x06
    2756:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t *puc = ( uint8_t * ) pv;
    2758:	8d 81       	ldd	r24, Y+5	; 0x05
    275a:	9e 81       	ldd	r25, Y+6	; 0x06
    275c:	9c 83       	std	Y+4, r25	; 0x04
    275e:	8b 83       	std	Y+3, r24	; 0x03
	BlockLink_t *pxLink;

	if( pv != NULL )
    2760:	8d 81       	ldd	r24, Y+5	; 0x05
    2762:	9e 81       	ldd	r25, Y+6	; 0x06
    2764:	00 97       	sbiw	r24, 0x00	; 0
    2766:	09 f4       	brne	.+2      	; 0x276a <vPortFree+0x24>
    2768:	4a c0       	rjmp	.+148    	; 0x27fe <vPortFree+0xb8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    276a:	80 91 a5 00 	lds	r24, 0x00A5
    276e:	90 91 a6 00 	lds	r25, 0x00A6
    2772:	22 27       	eor	r18, r18
    2774:	33 27       	eor	r19, r19
    2776:	28 1b       	sub	r18, r24
    2778:	39 0b       	sbc	r19, r25
    277a:	8b 81       	ldd	r24, Y+3	; 0x03
    277c:	9c 81       	ldd	r25, Y+4	; 0x04
    277e:	82 0f       	add	r24, r18
    2780:	93 1f       	adc	r25, r19
    2782:	9c 83       	std	Y+4, r25	; 0x04
    2784:	8b 83       	std	Y+3, r24	; 0x03

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
    2786:	8b 81       	ldd	r24, Y+3	; 0x03
    2788:	9c 81       	ldd	r25, Y+4	; 0x04
    278a:	9a 83       	std	Y+2, r25	; 0x02
    278c:	89 83       	std	Y+1, r24	; 0x01

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    278e:	e9 81       	ldd	r30, Y+1	; 0x01
    2790:	fa 81       	ldd	r31, Y+2	; 0x02
    2792:	22 81       	ldd	r18, Z+2	; 0x02
    2794:	33 81       	ldd	r19, Z+3	; 0x03
    2796:	80 91 af 00 	lds	r24, 0x00AF
    279a:	90 91 b0 00 	lds	r25, 0x00B0
    279e:	82 23       	and	r24, r18
    27a0:	93 23       	and	r25, r19
    27a2:	00 97       	sbiw	r24, 0x00	; 0
    27a4:	61 f1       	breq	.+88     	; 0x27fe <vPortFree+0xb8>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    27a6:	e9 81       	ldd	r30, Y+1	; 0x01
    27a8:	fa 81       	ldd	r31, Y+2	; 0x02
    27aa:	80 81       	ld	r24, Z
    27ac:	91 81       	ldd	r25, Z+1	; 0x01
    27ae:	00 97       	sbiw	r24, 0x00	; 0
    27b0:	31 f5       	brne	.+76     	; 0x27fe <vPortFree+0xb8>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    27b2:	e9 81       	ldd	r30, Y+1	; 0x01
    27b4:	fa 81       	ldd	r31, Y+2	; 0x02
    27b6:	22 81       	ldd	r18, Z+2	; 0x02
    27b8:	33 81       	ldd	r19, Z+3	; 0x03
    27ba:	80 91 af 00 	lds	r24, 0x00AF
    27be:	90 91 b0 00 	lds	r25, 0x00B0
    27c2:	80 95       	com	r24
    27c4:	90 95       	com	r25
    27c6:	82 23       	and	r24, r18
    27c8:	93 23       	and	r25, r19
    27ca:	e9 81       	ldd	r30, Y+1	; 0x01
    27cc:	fa 81       	ldd	r31, Y+2	; 0x02
    27ce:	93 83       	std	Z+3, r25	; 0x03
    27d0:	82 83       	std	Z+2, r24	; 0x02

				vTaskSuspendAll();
    27d2:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    27d6:	e9 81       	ldd	r30, Y+1	; 0x01
    27d8:	fa 81       	ldd	r31, Y+2	; 0x02
    27da:	22 81       	ldd	r18, Z+2	; 0x02
    27dc:	33 81       	ldd	r19, Z+3	; 0x03
    27de:	80 91 ab 00 	lds	r24, 0x00AB
    27e2:	90 91 ac 00 	lds	r25, 0x00AC
    27e6:	82 0f       	add	r24, r18
    27e8:	93 1f       	adc	r25, r19
    27ea:	90 93 ac 00 	sts	0x00AC, r25
    27ee:	80 93 ab 00 	sts	0x00AB, r24
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	9a 81       	ldd	r25, Y+2	; 0x02
    27f6:	0e 94 ba 14 	call	0x2974	; 0x2974 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
    27fa:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    27fe:	26 96       	adiw	r28, 0x06	; 6
    2800:	0f b6       	in	r0, 0x3f	; 63
    2802:	f8 94       	cli
    2804:	de bf       	out	0x3e, r29	; 62
    2806:	0f be       	out	0x3f, r0	; 63
    2808:	cd bf       	out	0x3d, r28	; 61
    280a:	cf 91       	pop	r28
    280c:	df 91       	pop	r29
    280e:	08 95       	ret

00002810 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2810:	df 93       	push	r29
    2812:	cf 93       	push	r28
    2814:	cd b7       	in	r28, 0x3d	; 61
    2816:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    2818:	80 91 ab 00 	lds	r24, 0x00AB
    281c:	90 91 ac 00 	lds	r25, 0x00AC
}
    2820:	cf 91       	pop	r28
    2822:	df 91       	pop	r29
    2824:	08 95       	ret

00002826 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    2826:	df 93       	push	r29
    2828:	cf 93       	push	r28
    282a:	cd b7       	in	r28, 0x3d	; 61
    282c:	de b7       	in	r29, 0x3e	; 62
	return xMinimumEverFreeBytesRemaining;
    282e:	80 91 ad 00 	lds	r24, 0x00AD
    2832:	90 91 ae 00 	lds	r25, 0x00AE
}
    2836:	cf 91       	pop	r28
    2838:	df 91       	pop	r29
    283a:	08 95       	ret

0000283c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    283c:	df 93       	push	r29
    283e:	cf 93       	push	r28
    2840:	cd b7       	in	r28, 0x3d	; 61
    2842:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    2844:	cf 91       	pop	r28
    2846:	df 91       	pop	r29
    2848:	08 95       	ret

0000284a <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    284a:	df 93       	push	r29
    284c:	cf 93       	push	r28
    284e:	cd b7       	in	r28, 0x3d	; 61
    2850:	de b7       	in	r29, 0x3e	; 62
    2852:	2a 97       	sbiw	r28, 0x0a	; 10
    2854:	0f b6       	in	r0, 0x3f	; 63
    2856:	f8 94       	cli
    2858:	de bf       	out	0x3e, r29	; 62
    285a:	0f be       	out	0x3f, r0	; 63
    285c:	cd bf       	out	0x3d, r28	; 61
	BlockLink_t *pxFirstFreeBlock;
	uint8_t *pucAlignedHeap;
	uint32_t ulAddress;
	size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    285e:	8c ed       	ldi	r24, 0xDC	; 220
    2860:	95 e0       	ldi	r25, 0x05	; 5
    2862:	9a 83       	std	Y+2, r25	; 0x02
    2864:	89 83       	std	Y+1, r24	; 0x01

	/* Ensure the heap starts on a correctly aligned boundary. */
	ulAddress = ( uint16_t ) ucHeap;
    2866:	81 eb       	ldi	r24, 0xB1	; 177
    2868:	90 e0       	ldi	r25, 0x00	; 0
    286a:	cc 01       	movw	r24, r24
    286c:	a0 e0       	ldi	r26, 0x00	; 0
    286e:	b0 e0       	ldi	r27, 0x00	; 0
    2870:	8b 83       	std	Y+3, r24	; 0x03
    2872:	9c 83       	std	Y+4, r25	; 0x04
    2874:	ad 83       	std	Y+5, r26	; 0x05
    2876:	be 83       	std	Y+6, r27	; 0x06
		ulAddress += ( portBYTE_ALIGNMENT - 1 );
		ulAddress &= ~portBYTE_ALIGNMENT_MASK;
		xTotalHeapSize -= ulAddress - ( uint16_t ) ucHeap;
	}

	pucAlignedHeap = ( uint8_t * ) ulAddress;
    2878:	8b 81       	ldd	r24, Y+3	; 0x03
    287a:	9c 81       	ldd	r25, Y+4	; 0x04
    287c:	98 87       	std	Y+8, r25	; 0x08
    287e:	8f 83       	std	Y+7, r24	; 0x07

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    2880:	8f 81       	ldd	r24, Y+7	; 0x07
    2882:	98 85       	ldd	r25, Y+8	; 0x08
    2884:	90 93 8e 06 	sts	0x068E, r25
    2888:	80 93 8d 06 	sts	0x068D, r24
	xStart.xBlockSize = ( size_t ) 0;
    288c:	10 92 90 06 	sts	0x0690, r1
    2890:	10 92 8f 06 	sts	0x068F, r1

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
    2894:	8f 81       	ldd	r24, Y+7	; 0x07
    2896:	98 85       	ldd	r25, Y+8	; 0x08
    2898:	9c 01       	movw	r18, r24
    289a:	44 27       	eor	r20, r20
    289c:	37 fd       	sbrc	r19, 7
    289e:	40 95       	com	r20
    28a0:	54 2f       	mov	r21, r20
    28a2:	89 81       	ldd	r24, Y+1	; 0x01
    28a4:	9a 81       	ldd	r25, Y+2	; 0x02
    28a6:	cc 01       	movw	r24, r24
    28a8:	a0 e0       	ldi	r26, 0x00	; 0
    28aa:	b0 e0       	ldi	r27, 0x00	; 0
    28ac:	82 0f       	add	r24, r18
    28ae:	93 1f       	adc	r25, r19
    28b0:	a4 1f       	adc	r26, r20
    28b2:	b5 1f       	adc	r27, r21
    28b4:	8b 83       	std	Y+3, r24	; 0x03
    28b6:	9c 83       	std	Y+4, r25	; 0x04
    28b8:	ad 83       	std	Y+5, r26	; 0x05
    28ba:	be 83       	std	Y+6, r27	; 0x06
	ulAddress -= xHeapStructSize;
    28bc:	80 91 a5 00 	lds	r24, 0x00A5
    28c0:	90 91 a6 00 	lds	r25, 0x00A6
    28c4:	9c 01       	movw	r18, r24
    28c6:	40 e0       	ldi	r20, 0x00	; 0
    28c8:	50 e0       	ldi	r21, 0x00	; 0
    28ca:	8b 81       	ldd	r24, Y+3	; 0x03
    28cc:	9c 81       	ldd	r25, Y+4	; 0x04
    28ce:	ad 81       	ldd	r26, Y+5	; 0x05
    28d0:	be 81       	ldd	r27, Y+6	; 0x06
    28d2:	82 1b       	sub	r24, r18
    28d4:	93 0b       	sbc	r25, r19
    28d6:	a4 0b       	sbc	r26, r20
    28d8:	b5 0b       	sbc	r27, r21
    28da:	8b 83       	std	Y+3, r24	; 0x03
    28dc:	9c 83       	std	Y+4, r25	; 0x04
    28de:	ad 83       	std	Y+5, r26	; 0x05
    28e0:	be 83       	std	Y+6, r27	; 0x06
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
	pxEnd = ( void * ) ulAddress;
    28e2:	8b 81       	ldd	r24, Y+3	; 0x03
    28e4:	9c 81       	ldd	r25, Y+4	; 0x04
    28e6:	90 93 aa 00 	sts	0x00AA, r25
    28ea:	80 93 a9 00 	sts	0x00A9, r24
	pxEnd->xBlockSize = 0;
    28ee:	e0 91 a9 00 	lds	r30, 0x00A9
    28f2:	f0 91 aa 00 	lds	r31, 0x00AA
    28f6:	13 82       	std	Z+3, r1	; 0x03
    28f8:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    28fa:	e0 91 a9 00 	lds	r30, 0x00A9
    28fe:	f0 91 aa 00 	lds	r31, 0x00AA
    2902:	11 82       	std	Z+1, r1	; 0x01
    2904:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    2906:	8f 81       	ldd	r24, Y+7	; 0x07
    2908:	98 85       	ldd	r25, Y+8	; 0x08
    290a:	9a 87       	std	Y+10, r25	; 0x0a
    290c:	89 87       	std	Y+9, r24	; 0x09
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint16_t ) pxFirstFreeBlock;
    290e:	2b 81       	ldd	r18, Y+3	; 0x03
    2910:	3c 81       	ldd	r19, Y+4	; 0x04
    2912:	89 85       	ldd	r24, Y+9	; 0x09
    2914:	9a 85       	ldd	r25, Y+10	; 0x0a
    2916:	a9 01       	movw	r20, r18
    2918:	48 1b       	sub	r20, r24
    291a:	59 0b       	sbc	r21, r25
    291c:	ca 01       	movw	r24, r20
    291e:	e9 85       	ldd	r30, Y+9	; 0x09
    2920:	fa 85       	ldd	r31, Y+10	; 0x0a
    2922:	93 83       	std	Z+3, r25	; 0x03
    2924:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    2926:	80 91 a9 00 	lds	r24, 0x00A9
    292a:	90 91 aa 00 	lds	r25, 0x00AA
    292e:	e9 85       	ldd	r30, Y+9	; 0x09
    2930:	fa 85       	ldd	r31, Y+10	; 0x0a
    2932:	91 83       	std	Z+1, r25	; 0x01
    2934:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    2936:	e9 85       	ldd	r30, Y+9	; 0x09
    2938:	fa 85       	ldd	r31, Y+10	; 0x0a
    293a:	82 81       	ldd	r24, Z+2	; 0x02
    293c:	93 81       	ldd	r25, Z+3	; 0x03
    293e:	90 93 ae 00 	sts	0x00AE, r25
    2942:	80 93 ad 00 	sts	0x00AD, r24
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    2946:	e9 85       	ldd	r30, Y+9	; 0x09
    2948:	fa 85       	ldd	r31, Y+10	; 0x0a
    294a:	82 81       	ldd	r24, Z+2	; 0x02
    294c:	93 81       	ldd	r25, Z+3	; 0x03
    294e:	90 93 ac 00 	sts	0x00AC, r25
    2952:	80 93 ab 00 	sts	0x00AB, r24

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    2956:	80 e0       	ldi	r24, 0x00	; 0
    2958:	90 e8       	ldi	r25, 0x80	; 128
    295a:	90 93 b0 00 	sts	0x00B0, r25
    295e:	80 93 af 00 	sts	0x00AF, r24
}
    2962:	2a 96       	adiw	r28, 0x0a	; 10
    2964:	0f b6       	in	r0, 0x3f	; 63
    2966:	f8 94       	cli
    2968:	de bf       	out	0x3e, r29	; 62
    296a:	0f be       	out	0x3f, r0	; 63
    296c:	cd bf       	out	0x3d, r28	; 61
    296e:	cf 91       	pop	r28
    2970:	df 91       	pop	r29
    2972:	08 95       	ret

00002974 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    2974:	df 93       	push	r29
    2976:	cf 93       	push	r28
    2978:	00 d0       	rcall	.+0      	; 0x297a <prvInsertBlockIntoFreeList+0x6>
    297a:	00 d0       	rcall	.+0      	; 0x297c <prvInsertBlockIntoFreeList+0x8>
    297c:	00 d0       	rcall	.+0      	; 0x297e <prvInsertBlockIntoFreeList+0xa>
    297e:	cd b7       	in	r28, 0x3d	; 61
    2980:	de b7       	in	r29, 0x3e	; 62
    2982:	9e 83       	std	Y+6, r25	; 0x06
    2984:	8d 83       	std	Y+5, r24	; 0x05
	BlockLink_t *pxIterator;
	uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    2986:	8d e8       	ldi	r24, 0x8D	; 141
    2988:	96 e0       	ldi	r25, 0x06	; 6
    298a:	9c 83       	std	Y+4, r25	; 0x04
    298c:	8b 83       	std	Y+3, r24	; 0x03
    298e:	06 c0       	rjmp	.+12     	; 0x299c <prvInsertBlockIntoFreeList+0x28>
    2990:	eb 81       	ldd	r30, Y+3	; 0x03
    2992:	fc 81       	ldd	r31, Y+4	; 0x04
    2994:	80 81       	ld	r24, Z
    2996:	91 81       	ldd	r25, Z+1	; 0x01
    2998:	9c 83       	std	Y+4, r25	; 0x04
    299a:	8b 83       	std	Y+3, r24	; 0x03
    299c:	eb 81       	ldd	r30, Y+3	; 0x03
    299e:	fc 81       	ldd	r31, Y+4	; 0x04
    29a0:	20 81       	ld	r18, Z
    29a2:	31 81       	ldd	r19, Z+1	; 0x01
    29a4:	8d 81       	ldd	r24, Y+5	; 0x05
    29a6:	9e 81       	ldd	r25, Y+6	; 0x06
    29a8:	28 17       	cp	r18, r24
    29aa:	39 07       	cpc	r19, r25
    29ac:	88 f3       	brcs	.-30     	; 0x2990 <prvInsertBlockIntoFreeList+0x1c>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
    29ae:	8b 81       	ldd	r24, Y+3	; 0x03
    29b0:	9c 81       	ldd	r25, Y+4	; 0x04
    29b2:	9a 83       	std	Y+2, r25	; 0x02
    29b4:	89 83       	std	Y+1, r24	; 0x01
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    29b6:	eb 81       	ldd	r30, Y+3	; 0x03
    29b8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ba:	22 81       	ldd	r18, Z+2	; 0x02
    29bc:	33 81       	ldd	r19, Z+3	; 0x03
    29be:	89 81       	ldd	r24, Y+1	; 0x01
    29c0:	9a 81       	ldd	r25, Y+2	; 0x02
    29c2:	28 0f       	add	r18, r24
    29c4:	39 1f       	adc	r19, r25
    29c6:	8d 81       	ldd	r24, Y+5	; 0x05
    29c8:	9e 81       	ldd	r25, Y+6	; 0x06
    29ca:	28 17       	cp	r18, r24
    29cc:	39 07       	cpc	r19, r25
    29ce:	91 f4       	brne	.+36     	; 0x29f4 <prvInsertBlockIntoFreeList+0x80>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    29d0:	eb 81       	ldd	r30, Y+3	; 0x03
    29d2:	fc 81       	ldd	r31, Y+4	; 0x04
    29d4:	22 81       	ldd	r18, Z+2	; 0x02
    29d6:	33 81       	ldd	r19, Z+3	; 0x03
    29d8:	ed 81       	ldd	r30, Y+5	; 0x05
    29da:	fe 81       	ldd	r31, Y+6	; 0x06
    29dc:	82 81       	ldd	r24, Z+2	; 0x02
    29de:	93 81       	ldd	r25, Z+3	; 0x03
    29e0:	82 0f       	add	r24, r18
    29e2:	93 1f       	adc	r25, r19
    29e4:	eb 81       	ldd	r30, Y+3	; 0x03
    29e6:	fc 81       	ldd	r31, Y+4	; 0x04
    29e8:	93 83       	std	Z+3, r25	; 0x03
    29ea:	82 83       	std	Z+2, r24	; 0x02
		pxBlockToInsert = pxIterator;
    29ec:	8b 81       	ldd	r24, Y+3	; 0x03
    29ee:	9c 81       	ldd	r25, Y+4	; 0x04
    29f0:	9e 83       	std	Y+6, r25	; 0x06
    29f2:	8d 83       	std	Y+5, r24	; 0x05
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
    29f4:	8d 81       	ldd	r24, Y+5	; 0x05
    29f6:	9e 81       	ldd	r25, Y+6	; 0x06
    29f8:	9a 83       	std	Y+2, r25	; 0x02
    29fa:	89 83       	std	Y+1, r24	; 0x01
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    29fc:	ed 81       	ldd	r30, Y+5	; 0x05
    29fe:	fe 81       	ldd	r31, Y+6	; 0x06
    2a00:	22 81       	ldd	r18, Z+2	; 0x02
    2a02:	33 81       	ldd	r19, Z+3	; 0x03
    2a04:	89 81       	ldd	r24, Y+1	; 0x01
    2a06:	9a 81       	ldd	r25, Y+2	; 0x02
    2a08:	28 0f       	add	r18, r24
    2a0a:	39 1f       	adc	r19, r25
    2a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a10:	80 81       	ld	r24, Z
    2a12:	91 81       	ldd	r25, Z+1	; 0x01
    2a14:	28 17       	cp	r18, r24
    2a16:	39 07       	cpc	r19, r25
    2a18:	89 f5       	brne	.+98     	; 0x2a7c <prvInsertBlockIntoFreeList+0x108>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    2a1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1e:	20 81       	ld	r18, Z
    2a20:	31 81       	ldd	r19, Z+1	; 0x01
    2a22:	80 91 a9 00 	lds	r24, 0x00A9
    2a26:	90 91 aa 00 	lds	r25, 0x00AA
    2a2a:	28 17       	cp	r18, r24
    2a2c:	39 07       	cpc	r19, r25
    2a2e:	e9 f0       	breq	.+58     	; 0x2a6a <prvInsertBlockIntoFreeList+0xf6>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    2a30:	ed 81       	ldd	r30, Y+5	; 0x05
    2a32:	fe 81       	ldd	r31, Y+6	; 0x06
    2a34:	22 81       	ldd	r18, Z+2	; 0x02
    2a36:	33 81       	ldd	r19, Z+3	; 0x03
    2a38:	eb 81       	ldd	r30, Y+3	; 0x03
    2a3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a3c:	01 90       	ld	r0, Z+
    2a3e:	f0 81       	ld	r31, Z
    2a40:	e0 2d       	mov	r30, r0
    2a42:	82 81       	ldd	r24, Z+2	; 0x02
    2a44:	93 81       	ldd	r25, Z+3	; 0x03
    2a46:	82 0f       	add	r24, r18
    2a48:	93 1f       	adc	r25, r19
    2a4a:	ed 81       	ldd	r30, Y+5	; 0x05
    2a4c:	fe 81       	ldd	r31, Y+6	; 0x06
    2a4e:	93 83       	std	Z+3, r25	; 0x03
    2a50:	82 83       	std	Z+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    2a52:	eb 81       	ldd	r30, Y+3	; 0x03
    2a54:	fc 81       	ldd	r31, Y+4	; 0x04
    2a56:	01 90       	ld	r0, Z+
    2a58:	f0 81       	ld	r31, Z
    2a5a:	e0 2d       	mov	r30, r0
    2a5c:	80 81       	ld	r24, Z
    2a5e:	91 81       	ldd	r25, Z+1	; 0x01
    2a60:	ed 81       	ldd	r30, Y+5	; 0x05
    2a62:	fe 81       	ldd	r31, Y+6	; 0x06
    2a64:	91 83       	std	Z+1, r25	; 0x01
    2a66:	80 83       	st	Z, r24
    2a68:	11 c0       	rjmp	.+34     	; 0x2a8c <prvInsertBlockIntoFreeList+0x118>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    2a6a:	80 91 a9 00 	lds	r24, 0x00A9
    2a6e:	90 91 aa 00 	lds	r25, 0x00AA
    2a72:	ed 81       	ldd	r30, Y+5	; 0x05
    2a74:	fe 81       	ldd	r31, Y+6	; 0x06
    2a76:	91 83       	std	Z+1, r25	; 0x01
    2a78:	80 83       	st	Z, r24
    2a7a:	08 c0       	rjmp	.+16     	; 0x2a8c <prvInsertBlockIntoFreeList+0x118>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    2a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a80:	80 81       	ld	r24, Z
    2a82:	91 81       	ldd	r25, Z+1	; 0x01
    2a84:	ed 81       	ldd	r30, Y+5	; 0x05
    2a86:	fe 81       	ldd	r31, Y+6	; 0x06
    2a88:	91 83       	std	Z+1, r25	; 0x01
    2a8a:	80 83       	st	Z, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    2a8c:	2b 81       	ldd	r18, Y+3	; 0x03
    2a8e:	3c 81       	ldd	r19, Y+4	; 0x04
    2a90:	8d 81       	ldd	r24, Y+5	; 0x05
    2a92:	9e 81       	ldd	r25, Y+6	; 0x06
    2a94:	28 17       	cp	r18, r24
    2a96:	39 07       	cpc	r19, r25
    2a98:	31 f0       	breq	.+12     	; 0x2aa6 <prvInsertBlockIntoFreeList+0x132>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    2a9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9e:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa0:	9e 81       	ldd	r25, Y+6	; 0x06
    2aa2:	91 83       	std	Z+1, r25	; 0x01
    2aa4:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2aa6:	26 96       	adiw	r28, 0x06	; 6
    2aa8:	0f b6       	in	r0, 0x3f	; 63
    2aaa:	f8 94       	cli
    2aac:	de bf       	out	0x3e, r29	; 62
    2aae:	0f be       	out	0x3f, r0	; 63
    2ab0:	cd bf       	out	0x3d, r28	; 61
    2ab2:	cf 91       	pop	r28
    2ab4:	df 91       	pop	r29
    2ab6:	08 95       	ret

00002ab8 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2ab8:	df 93       	push	r29
    2aba:	cf 93       	push	r28
    2abc:	00 d0       	rcall	.+0      	; 0x2abe <vListInitialise+0x6>
    2abe:	cd b7       	in	r28, 0x3d	; 61
    2ac0:	de b7       	in	r29, 0x3e	; 62
    2ac2:	9a 83       	std	Y+2, r25	; 0x02
    2ac4:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2ac6:	89 81       	ldd	r24, Y+1	; 0x01
    2ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aca:	03 96       	adiw	r24, 0x03	; 3
    2acc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ace:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad0:	92 83       	std	Z+2, r25	; 0x02
    2ad2:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad8:	8f ef       	ldi	r24, 0xFF	; 255
    2ada:	9f ef       	ldi	r25, 0xFF	; 255
    2adc:	94 83       	std	Z+4, r25	; 0x04
    2ade:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2ae0:	89 81       	ldd	r24, Y+1	; 0x01
    2ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae4:	03 96       	adiw	r24, 0x03	; 3
    2ae6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aea:	96 83       	std	Z+6, r25	; 0x06
    2aec:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2aee:	89 81       	ldd	r24, Y+1	; 0x01
    2af0:	9a 81       	ldd	r25, Y+2	; 0x02
    2af2:	03 96       	adiw	r24, 0x03	; 3
    2af4:	e9 81       	ldd	r30, Y+1	; 0x01
    2af6:	fa 81       	ldd	r31, Y+2	; 0x02
    2af8:	90 87       	std	Z+8, r25	; 0x08
    2afa:	87 83       	std	Z+7, r24	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2afc:	e9 81       	ldd	r30, Y+1	; 0x01
    2afe:	fa 81       	ldd	r31, Y+2	; 0x02
    2b00:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2b02:	0f 90       	pop	r0
    2b04:	0f 90       	pop	r0
    2b06:	cf 91       	pop	r28
    2b08:	df 91       	pop	r29
    2b0a:	08 95       	ret

00002b0c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    2b0c:	df 93       	push	r29
    2b0e:	cf 93       	push	r28
    2b10:	00 d0       	rcall	.+0      	; 0x2b12 <vListInitialiseItem+0x6>
    2b12:	cd b7       	in	r28, 0x3d	; 61
    2b14:	de b7       	in	r29, 0x3e	; 62
    2b16:	9a 83       	std	Y+2, r25	; 0x02
    2b18:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2b1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b1e:	11 86       	std	Z+9, r1	; 0x09
    2b20:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2b22:	0f 90       	pop	r0
    2b24:	0f 90       	pop	r0
    2b26:	cf 91       	pop	r28
    2b28:	df 91       	pop	r29
    2b2a:	08 95       	ret

00002b2c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    2b2c:	df 93       	push	r29
    2b2e:	cf 93       	push	r28
    2b30:	00 d0       	rcall	.+0      	; 0x2b32 <vListInsertEnd+0x6>
    2b32:	00 d0       	rcall	.+0      	; 0x2b34 <vListInsertEnd+0x8>
    2b34:	00 d0       	rcall	.+0      	; 0x2b36 <vListInsertEnd+0xa>
    2b36:	cd b7       	in	r28, 0x3d	; 61
    2b38:	de b7       	in	r29, 0x3e	; 62
    2b3a:	9c 83       	std	Y+4, r25	; 0x04
    2b3c:	8b 83       	std	Y+3, r24	; 0x03
    2b3e:	7e 83       	std	Y+6, r23	; 0x06
    2b40:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    2b42:	eb 81       	ldd	r30, Y+3	; 0x03
    2b44:	fc 81       	ldd	r31, Y+4	; 0x04
    2b46:	81 81       	ldd	r24, Z+1	; 0x01
    2b48:	92 81       	ldd	r25, Z+2	; 0x02
    2b4a:	9a 83       	std	Y+2, r25	; 0x02
    2b4c:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    2b4e:	ed 81       	ldd	r30, Y+5	; 0x05
    2b50:	fe 81       	ldd	r31, Y+6	; 0x06
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	9a 81       	ldd	r25, Y+2	; 0x02
    2b56:	93 83       	std	Z+3, r25	; 0x03
    2b58:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2b5a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b5e:	84 81       	ldd	r24, Z+4	; 0x04
    2b60:	95 81       	ldd	r25, Z+5	; 0x05
    2b62:	ed 81       	ldd	r30, Y+5	; 0x05
    2b64:	fe 81       	ldd	r31, Y+6	; 0x06
    2b66:	95 83       	std	Z+5, r25	; 0x05
    2b68:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6e:	04 80       	ldd	r0, Z+4	; 0x04
    2b70:	f5 81       	ldd	r31, Z+5	; 0x05
    2b72:	e0 2d       	mov	r30, r0
    2b74:	8d 81       	ldd	r24, Y+5	; 0x05
    2b76:	9e 81       	ldd	r25, Y+6	; 0x06
    2b78:	93 83       	std	Z+3, r25	; 0x03
    2b7a:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    2b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b80:	8d 81       	ldd	r24, Y+5	; 0x05
    2b82:	9e 81       	ldd	r25, Y+6	; 0x06
    2b84:	95 83       	std	Z+5, r25	; 0x05
    2b86:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2b88:	ed 81       	ldd	r30, Y+5	; 0x05
    2b8a:	fe 81       	ldd	r31, Y+6	; 0x06
    2b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b90:	91 87       	std	Z+9, r25	; 0x09
    2b92:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2b94:	eb 81       	ldd	r30, Y+3	; 0x03
    2b96:	fc 81       	ldd	r31, Y+4	; 0x04
    2b98:	80 81       	ld	r24, Z
    2b9a:	8f 5f       	subi	r24, 0xFF	; 255
    2b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ba0:	80 83       	st	Z, r24
}
    2ba2:	26 96       	adiw	r28, 0x06	; 6
    2ba4:	0f b6       	in	r0, 0x3f	; 63
    2ba6:	f8 94       	cli
    2ba8:	de bf       	out	0x3e, r29	; 62
    2baa:	0f be       	out	0x3f, r0	; 63
    2bac:	cd bf       	out	0x3d, r28	; 61
    2bae:	cf 91       	pop	r28
    2bb0:	df 91       	pop	r29
    2bb2:	08 95       	ret

00002bb4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    2bb4:	df 93       	push	r29
    2bb6:	cf 93       	push	r28
    2bb8:	cd b7       	in	r28, 0x3d	; 61
    2bba:	de b7       	in	r29, 0x3e	; 62
    2bbc:	28 97       	sbiw	r28, 0x08	; 8
    2bbe:	0f b6       	in	r0, 0x3f	; 63
    2bc0:	f8 94       	cli
    2bc2:	de bf       	out	0x3e, r29	; 62
    2bc4:	0f be       	out	0x3f, r0	; 63
    2bc6:	cd bf       	out	0x3d, r28	; 61
    2bc8:	9e 83       	std	Y+6, r25	; 0x06
    2bca:	8d 83       	std	Y+5, r24	; 0x05
    2bcc:	78 87       	std	Y+8, r23	; 0x08
    2bce:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2bd0:	ef 81       	ldd	r30, Y+7	; 0x07
    2bd2:	f8 85       	ldd	r31, Y+8	; 0x08
    2bd4:	80 81       	ld	r24, Z
    2bd6:	91 81       	ldd	r25, Z+1	; 0x01
    2bd8:	9a 83       	std	Y+2, r25	; 0x02
    2bda:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2bdc:	89 81       	ldd	r24, Y+1	; 0x01
    2bde:	9a 81       	ldd	r25, Y+2	; 0x02
    2be0:	2f ef       	ldi	r18, 0xFF	; 255
    2be2:	8f 3f       	cpi	r24, 0xFF	; 255
    2be4:	92 07       	cpc	r25, r18
    2be6:	39 f4       	brne	.+14     	; 0x2bf6 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2be8:	ed 81       	ldd	r30, Y+5	; 0x05
    2bea:	fe 81       	ldd	r31, Y+6	; 0x06
    2bec:	87 81       	ldd	r24, Z+7	; 0x07
    2bee:	90 85       	ldd	r25, Z+8	; 0x08
    2bf0:	9c 83       	std	Y+4, r25	; 0x04
    2bf2:	8b 83       	std	Y+3, r24	; 0x03
    2bf4:	18 c0       	rjmp	.+48     	; 0x2c26 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2bf6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bf8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bfa:	03 96       	adiw	r24, 0x03	; 3
    2bfc:	9c 83       	std	Y+4, r25	; 0x04
    2bfe:	8b 83       	std	Y+3, r24	; 0x03
    2c00:	06 c0       	rjmp	.+12     	; 0x2c0e <vListInsert+0x5a>
    2c02:	eb 81       	ldd	r30, Y+3	; 0x03
    2c04:	fc 81       	ldd	r31, Y+4	; 0x04
    2c06:	82 81       	ldd	r24, Z+2	; 0x02
    2c08:	93 81       	ldd	r25, Z+3	; 0x03
    2c0a:	9c 83       	std	Y+4, r25	; 0x04
    2c0c:	8b 83       	std	Y+3, r24	; 0x03
    2c0e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c10:	fc 81       	ldd	r31, Y+4	; 0x04
    2c12:	02 80       	ldd	r0, Z+2	; 0x02
    2c14:	f3 81       	ldd	r31, Z+3	; 0x03
    2c16:	e0 2d       	mov	r30, r0
    2c18:	20 81       	ld	r18, Z
    2c1a:	31 81       	ldd	r19, Z+1	; 0x01
    2c1c:	89 81       	ldd	r24, Y+1	; 0x01
    2c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c20:	82 17       	cp	r24, r18
    2c22:	93 07       	cpc	r25, r19
    2c24:	70 f7       	brcc	.-36     	; 0x2c02 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2c26:	eb 81       	ldd	r30, Y+3	; 0x03
    2c28:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2a:	82 81       	ldd	r24, Z+2	; 0x02
    2c2c:	93 81       	ldd	r25, Z+3	; 0x03
    2c2e:	ef 81       	ldd	r30, Y+7	; 0x07
    2c30:	f8 85       	ldd	r31, Y+8	; 0x08
    2c32:	93 83       	std	Z+3, r25	; 0x03
    2c34:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2c36:	ef 81       	ldd	r30, Y+7	; 0x07
    2c38:	f8 85       	ldd	r31, Y+8	; 0x08
    2c3a:	02 80       	ldd	r0, Z+2	; 0x02
    2c3c:	f3 81       	ldd	r31, Z+3	; 0x03
    2c3e:	e0 2d       	mov	r30, r0
    2c40:	8f 81       	ldd	r24, Y+7	; 0x07
    2c42:	98 85       	ldd	r25, Y+8	; 0x08
    2c44:	95 83       	std	Z+5, r25	; 0x05
    2c46:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2c48:	ef 81       	ldd	r30, Y+7	; 0x07
    2c4a:	f8 85       	ldd	r31, Y+8	; 0x08
    2c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c50:	95 83       	std	Z+5, r25	; 0x05
    2c52:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2c54:	eb 81       	ldd	r30, Y+3	; 0x03
    2c56:	fc 81       	ldd	r31, Y+4	; 0x04
    2c58:	8f 81       	ldd	r24, Y+7	; 0x07
    2c5a:	98 85       	ldd	r25, Y+8	; 0x08
    2c5c:	93 83       	std	Z+3, r25	; 0x03
    2c5e:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    2c60:	ef 81       	ldd	r30, Y+7	; 0x07
    2c62:	f8 85       	ldd	r31, Y+8	; 0x08
    2c64:	8d 81       	ldd	r24, Y+5	; 0x05
    2c66:	9e 81       	ldd	r25, Y+6	; 0x06
    2c68:	91 87       	std	Z+9, r25	; 0x09
    2c6a:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2c6c:	ed 81       	ldd	r30, Y+5	; 0x05
    2c6e:	fe 81       	ldd	r31, Y+6	; 0x06
    2c70:	80 81       	ld	r24, Z
    2c72:	8f 5f       	subi	r24, 0xFF	; 255
    2c74:	ed 81       	ldd	r30, Y+5	; 0x05
    2c76:	fe 81       	ldd	r31, Y+6	; 0x06
    2c78:	80 83       	st	Z, r24
}
    2c7a:	28 96       	adiw	r28, 0x08	; 8
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	f8 94       	cli
    2c80:	de bf       	out	0x3e, r29	; 62
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	cd bf       	out	0x3d, r28	; 61
    2c86:	cf 91       	pop	r28
    2c88:	df 91       	pop	r29
    2c8a:	08 95       	ret

00002c8c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2c8c:	df 93       	push	r29
    2c8e:	cf 93       	push	r28
    2c90:	00 d0       	rcall	.+0      	; 0x2c92 <uxListRemove+0x6>
    2c92:	00 d0       	rcall	.+0      	; 0x2c94 <uxListRemove+0x8>
    2c94:	cd b7       	in	r28, 0x3d	; 61
    2c96:	de b7       	in	r29, 0x3e	; 62
    2c98:	9c 83       	std	Y+4, r25	; 0x04
    2c9a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    2c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca0:	80 85       	ldd	r24, Z+8	; 0x08
    2ca2:	91 85       	ldd	r25, Z+9	; 0x09
    2ca4:	9a 83       	std	Y+2, r25	; 0x02
    2ca6:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    2caa:	fc 81       	ldd	r31, Y+4	; 0x04
    2cac:	a2 81       	ldd	r26, Z+2	; 0x02
    2cae:	b3 81       	ldd	r27, Z+3	; 0x03
    2cb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb4:	84 81       	ldd	r24, Z+4	; 0x04
    2cb6:	95 81       	ldd	r25, Z+5	; 0x05
    2cb8:	15 96       	adiw	r26, 0x05	; 5
    2cba:	9c 93       	st	X, r25
    2cbc:	8e 93       	st	-X, r24
    2cbe:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc4:	a4 81       	ldd	r26, Z+4	; 0x04
    2cc6:	b5 81       	ldd	r27, Z+5	; 0x05
    2cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cca:	fc 81       	ldd	r31, Y+4	; 0x04
    2ccc:	82 81       	ldd	r24, Z+2	; 0x02
    2cce:	93 81       	ldd	r25, Z+3	; 0x03
    2cd0:	13 96       	adiw	r26, 0x03	; 3
    2cd2:	9c 93       	st	X, r25
    2cd4:	8e 93       	st	-X, r24
    2cd6:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2cda:	fa 81       	ldd	r31, Y+2	; 0x02
    2cdc:	21 81       	ldd	r18, Z+1	; 0x01
    2cde:	32 81       	ldd	r19, Z+2	; 0x02
    2ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce4:	28 17       	cp	r18, r24
    2ce6:	39 07       	cpc	r19, r25
    2ce8:	41 f4       	brne	.+16     	; 0x2cfa <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2cea:	eb 81       	ldd	r30, Y+3	; 0x03
    2cec:	fc 81       	ldd	r31, Y+4	; 0x04
    2cee:	84 81       	ldd	r24, Z+4	; 0x04
    2cf0:	95 81       	ldd	r25, Z+5	; 0x05
    2cf2:	e9 81       	ldd	r30, Y+1	; 0x01
    2cf4:	fa 81       	ldd	r31, Y+2	; 0x02
    2cf6:	92 83       	std	Z+2, r25	; 0x02
    2cf8:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    2cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfe:	11 86       	std	Z+9, r1	; 0x09
    2d00:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2d02:	e9 81       	ldd	r30, Y+1	; 0x01
    2d04:	fa 81       	ldd	r31, Y+2	; 0x02
    2d06:	80 81       	ld	r24, Z
    2d08:	81 50       	subi	r24, 0x01	; 1
    2d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d0e:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    2d10:	e9 81       	ldd	r30, Y+1	; 0x01
    2d12:	fa 81       	ldd	r31, Y+2	; 0x02
    2d14:	80 81       	ld	r24, Z
}
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	0f 90       	pop	r0
    2d1c:	0f 90       	pop	r0
    2d1e:	cf 91       	pop	r28
    2d20:	df 91       	pop	r29
    2d22:	08 95       	ret

00002d24 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2d24:	df 93       	push	r29
    2d26:	cf 93       	push	r28
    2d28:	cd b7       	in	r28, 0x3d	; 61
    2d2a:	de b7       	in	r29, 0x3e	; 62
    2d2c:	28 97       	sbiw	r28, 0x08	; 8
    2d2e:	0f b6       	in	r0, 0x3f	; 63
    2d30:	f8 94       	cli
    2d32:	de bf       	out	0x3e, r29	; 62
    2d34:	0f be       	out	0x3f, r0	; 63
    2d36:	cd bf       	out	0x3d, r28	; 61
    2d38:	9c 83       	std	Y+4, r25	; 0x04
    2d3a:	8b 83       	std	Y+3, r24	; 0x03
    2d3c:	7e 83       	std	Y+6, r23	; 0x06
    2d3e:	6d 83       	std	Y+5, r22	; 0x05
    2d40:	58 87       	std	Y+8, r21	; 0x08
    2d42:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2d44:	eb 81       	ldd	r30, Y+3	; 0x03
    2d46:	fc 81       	ldd	r31, Y+4	; 0x04
    2d48:	81 e1       	ldi	r24, 0x11	; 17
    2d4a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d50:	01 97       	sbiw	r24, 0x01	; 1
    2d52:	9c 83       	std	Y+4, r25	; 0x04
    2d54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2d56:	eb 81       	ldd	r30, Y+3	; 0x03
    2d58:	fc 81       	ldd	r31, Y+4	; 0x04
    2d5a:	82 e2       	ldi	r24, 0x22	; 34
    2d5c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d60:	9c 81       	ldd	r25, Y+4	; 0x04
    2d62:	01 97       	sbiw	r24, 0x01	; 1
    2d64:	9c 83       	std	Y+4, r25	; 0x04
    2d66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2d68:	eb 81       	ldd	r30, Y+3	; 0x03
    2d6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d6c:	83 e3       	ldi	r24, 0x33	; 51
    2d6e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d70:	8b 81       	ldd	r24, Y+3	; 0x03
    2d72:	9c 81       	ldd	r25, Y+4	; 0x04
    2d74:	01 97       	sbiw	r24, 0x01	; 1
    2d76:	9c 83       	std	Y+4, r25	; 0x04
    2d78:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2d7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d7e:	9a 83       	std	Y+2, r25	; 0x02
    2d80:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d82:	89 81       	ldd	r24, Y+1	; 0x01
    2d84:	eb 81       	ldd	r30, Y+3	; 0x03
    2d86:	fc 81       	ldd	r31, Y+4	; 0x04
    2d88:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8e:	01 97       	sbiw	r24, 0x01	; 1
    2d90:	9c 83       	std	Y+4, r25	; 0x04
    2d92:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2d94:	89 81       	ldd	r24, Y+1	; 0x01
    2d96:	9a 81       	ldd	r25, Y+2	; 0x02
    2d98:	89 2f       	mov	r24, r25
    2d9a:	99 27       	eor	r25, r25
    2d9c:	9a 83       	std	Y+2, r25	; 0x02
    2d9e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2da0:	89 81       	ldd	r24, Y+1	; 0x01
    2da2:	eb 81       	ldd	r30, Y+3	; 0x03
    2da4:	fc 81       	ldd	r31, Y+4	; 0x04
    2da6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2da8:	8b 81       	ldd	r24, Y+3	; 0x03
    2daa:	9c 81       	ldd	r25, Y+4	; 0x04
    2dac:	01 97       	sbiw	r24, 0x01	; 1
    2dae:	9c 83       	std	Y+4, r25	; 0x04
    2db0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2db2:	eb 81       	ldd	r30, Y+3	; 0x03
    2db4:	fc 81       	ldd	r31, Y+4	; 0x04
    2db6:	10 82       	st	Z, r1
	pxTopOfStack--;
    2db8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dba:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbc:	01 97       	sbiw	r24, 0x01	; 1
    2dbe:	9c 83       	std	Y+4, r25	; 0x04
    2dc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2dc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2dc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2dc6:	80 e8       	ldi	r24, 0x80	; 128
    2dc8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dca:	8b 81       	ldd	r24, Y+3	; 0x03
    2dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dce:	01 97       	sbiw	r24, 0x01	; 1
    2dd0:	9c 83       	std	Y+4, r25	; 0x04
    2dd2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2dd4:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd6:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd8:	10 82       	st	Z, r1
	pxTopOfStack--;
    2dda:	8b 81       	ldd	r24, Y+3	; 0x03
    2ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dde:	01 97       	sbiw	r24, 0x01	; 1
    2de0:	9c 83       	std	Y+4, r25	; 0x04
    2de2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2de4:	eb 81       	ldd	r30, Y+3	; 0x03
    2de6:	fc 81       	ldd	r31, Y+4	; 0x04
    2de8:	82 e0       	ldi	r24, 0x02	; 2
    2dea:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dec:	8b 81       	ldd	r24, Y+3	; 0x03
    2dee:	9c 81       	ldd	r25, Y+4	; 0x04
    2df0:	01 97       	sbiw	r24, 0x01	; 1
    2df2:	9c 83       	std	Y+4, r25	; 0x04
    2df4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2df6:	eb 81       	ldd	r30, Y+3	; 0x03
    2df8:	fc 81       	ldd	r31, Y+4	; 0x04
    2dfa:	83 e0       	ldi	r24, 0x03	; 3
    2dfc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2e00:	9c 81       	ldd	r25, Y+4	; 0x04
    2e02:	01 97       	sbiw	r24, 0x01	; 1
    2e04:	9c 83       	std	Y+4, r25	; 0x04
    2e06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2e08:	eb 81       	ldd	r30, Y+3	; 0x03
    2e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e0c:	84 e0       	ldi	r24, 0x04	; 4
    2e0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e10:	8b 81       	ldd	r24, Y+3	; 0x03
    2e12:	9c 81       	ldd	r25, Y+4	; 0x04
    2e14:	01 97       	sbiw	r24, 0x01	; 1
    2e16:	9c 83       	std	Y+4, r25	; 0x04
    2e18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e1e:	85 e0       	ldi	r24, 0x05	; 5
    2e20:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
    2e24:	9c 81       	ldd	r25, Y+4	; 0x04
    2e26:	01 97       	sbiw	r24, 0x01	; 1
    2e28:	9c 83       	std	Y+4, r25	; 0x04
    2e2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e30:	86 e0       	ldi	r24, 0x06	; 6
    2e32:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e34:	8b 81       	ldd	r24, Y+3	; 0x03
    2e36:	9c 81       	ldd	r25, Y+4	; 0x04
    2e38:	01 97       	sbiw	r24, 0x01	; 1
    2e3a:	9c 83       	std	Y+4, r25	; 0x04
    2e3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e40:	fc 81       	ldd	r31, Y+4	; 0x04
    2e42:	87 e0       	ldi	r24, 0x07	; 7
    2e44:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e46:	8b 81       	ldd	r24, Y+3	; 0x03
    2e48:	9c 81       	ldd	r25, Y+4	; 0x04
    2e4a:	01 97       	sbiw	r24, 0x01	; 1
    2e4c:	9c 83       	std	Y+4, r25	; 0x04
    2e4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2e50:	eb 81       	ldd	r30, Y+3	; 0x03
    2e52:	fc 81       	ldd	r31, Y+4	; 0x04
    2e54:	88 e0       	ldi	r24, 0x08	; 8
    2e56:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e58:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5c:	01 97       	sbiw	r24, 0x01	; 1
    2e5e:	9c 83       	std	Y+4, r25	; 0x04
    2e60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2e62:	eb 81       	ldd	r30, Y+3	; 0x03
    2e64:	fc 81       	ldd	r31, Y+4	; 0x04
    2e66:	89 e0       	ldi	r24, 0x09	; 9
    2e68:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6e:	01 97       	sbiw	r24, 0x01	; 1
    2e70:	9c 83       	std	Y+4, r25	; 0x04
    2e72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2e74:	eb 81       	ldd	r30, Y+3	; 0x03
    2e76:	fc 81       	ldd	r31, Y+4	; 0x04
    2e78:	80 e1       	ldi	r24, 0x10	; 16
    2e7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e80:	01 97       	sbiw	r24, 0x01	; 1
    2e82:	9c 83       	std	Y+4, r25	; 0x04
    2e84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2e86:	eb 81       	ldd	r30, Y+3	; 0x03
    2e88:	fc 81       	ldd	r31, Y+4	; 0x04
    2e8a:	81 e1       	ldi	r24, 0x11	; 17
    2e8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e90:	9c 81       	ldd	r25, Y+4	; 0x04
    2e92:	01 97       	sbiw	r24, 0x01	; 1
    2e94:	9c 83       	std	Y+4, r25	; 0x04
    2e96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2e98:	eb 81       	ldd	r30, Y+3	; 0x03
    2e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e9c:	82 e1       	ldi	r24, 0x12	; 18
    2e9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	01 97       	sbiw	r24, 0x01	; 1
    2ea6:	9c 83       	std	Y+4, r25	; 0x04
    2ea8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    2eac:	fc 81       	ldd	r31, Y+4	; 0x04
    2eae:	83 e1       	ldi	r24, 0x13	; 19
    2eb0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb6:	01 97       	sbiw	r24, 0x01	; 1
    2eb8:	9c 83       	std	Y+4, r25	; 0x04
    2eba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2ebc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ebe:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec0:	84 e1       	ldi	r24, 0x14	; 20
    2ec2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec8:	01 97       	sbiw	r24, 0x01	; 1
    2eca:	9c 83       	std	Y+4, r25	; 0x04
    2ecc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2ece:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ed2:	85 e1       	ldi	r24, 0x15	; 21
    2ed4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ed6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eda:	01 97       	sbiw	r24, 0x01	; 1
    2edc:	9c 83       	std	Y+4, r25	; 0x04
    2ede:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee4:	86 e1       	ldi	r24, 0x16	; 22
    2ee6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eea:	9c 81       	ldd	r25, Y+4	; 0x04
    2eec:	01 97       	sbiw	r24, 0x01	; 1
    2eee:	9c 83       	std	Y+4, r25	; 0x04
    2ef0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef6:	87 e1       	ldi	r24, 0x17	; 23
    2ef8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2efa:	8b 81       	ldd	r24, Y+3	; 0x03
    2efc:	9c 81       	ldd	r25, Y+4	; 0x04
    2efe:	01 97       	sbiw	r24, 0x01	; 1
    2f00:	9c 83       	std	Y+4, r25	; 0x04
    2f02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2f04:	eb 81       	ldd	r30, Y+3	; 0x03
    2f06:	fc 81       	ldd	r31, Y+4	; 0x04
    2f08:	88 e1       	ldi	r24, 0x18	; 24
    2f0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f10:	01 97       	sbiw	r24, 0x01	; 1
    2f12:	9c 83       	std	Y+4, r25	; 0x04
    2f14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2f16:	eb 81       	ldd	r30, Y+3	; 0x03
    2f18:	fc 81       	ldd	r31, Y+4	; 0x04
    2f1a:	89 e1       	ldi	r24, 0x19	; 25
    2f1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f20:	9c 81       	ldd	r25, Y+4	; 0x04
    2f22:	01 97       	sbiw	r24, 0x01	; 1
    2f24:	9c 83       	std	Y+4, r25	; 0x04
    2f26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2f28:	eb 81       	ldd	r30, Y+3	; 0x03
    2f2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2c:	80 e2       	ldi	r24, 0x20	; 32
    2f2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f30:	8b 81       	ldd	r24, Y+3	; 0x03
    2f32:	9c 81       	ldd	r25, Y+4	; 0x04
    2f34:	01 97       	sbiw	r24, 0x01	; 1
    2f36:	9c 83       	std	Y+4, r25	; 0x04
    2f38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2f3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f3e:	81 e2       	ldi	r24, 0x21	; 33
    2f40:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f42:	8b 81       	ldd	r24, Y+3	; 0x03
    2f44:	9c 81       	ldd	r25, Y+4	; 0x04
    2f46:	01 97       	sbiw	r24, 0x01	; 1
    2f48:	9c 83       	std	Y+4, r25	; 0x04
    2f4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2f4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f50:	82 e2       	ldi	r24, 0x22	; 34
    2f52:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f54:	8b 81       	ldd	r24, Y+3	; 0x03
    2f56:	9c 81       	ldd	r25, Y+4	; 0x04
    2f58:	01 97       	sbiw	r24, 0x01	; 1
    2f5a:	9c 83       	std	Y+4, r25	; 0x04
    2f5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2f5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f60:	fc 81       	ldd	r31, Y+4	; 0x04
    2f62:	83 e2       	ldi	r24, 0x23	; 35
    2f64:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f66:	8b 81       	ldd	r24, Y+3	; 0x03
    2f68:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6a:	01 97       	sbiw	r24, 0x01	; 1
    2f6c:	9c 83       	std	Y+4, r25	; 0x04
    2f6e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2f70:	8f 81       	ldd	r24, Y+7	; 0x07
    2f72:	98 85       	ldd	r25, Y+8	; 0x08
    2f74:	9a 83       	std	Y+2, r25	; 0x02
    2f76:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2f78:	89 81       	ldd	r24, Y+1	; 0x01
    2f7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f80:	8b 81       	ldd	r24, Y+3	; 0x03
    2f82:	9c 81       	ldd	r25, Y+4	; 0x04
    2f84:	01 97       	sbiw	r24, 0x01	; 1
    2f86:	9c 83       	std	Y+4, r25	; 0x04
    2f88:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2f8a:	89 81       	ldd	r24, Y+1	; 0x01
    2f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f8e:	89 2f       	mov	r24, r25
    2f90:	99 27       	eor	r25, r25
    2f92:	9a 83       	std	Y+2, r25	; 0x02
    2f94:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2f96:	89 81       	ldd	r24, Y+1	; 0x01
    2f98:	eb 81       	ldd	r30, Y+3	; 0x03
    2f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa2:	01 97       	sbiw	r24, 0x01	; 1
    2fa4:	9c 83       	std	Y+4, r25	; 0x04
    2fa6:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2fa8:	eb 81       	ldd	r30, Y+3	; 0x03
    2faa:	fc 81       	ldd	r31, Y+4	; 0x04
    2fac:	86 e2       	ldi	r24, 0x26	; 38
    2fae:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb4:	01 97       	sbiw	r24, 0x01	; 1
    2fb6:	9c 83       	std	Y+4, r25	; 0x04
    2fb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2fba:	eb 81       	ldd	r30, Y+3	; 0x03
    2fbc:	fc 81       	ldd	r31, Y+4	; 0x04
    2fbe:	87 e2       	ldi	r24, 0x27	; 39
    2fc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc6:	01 97       	sbiw	r24, 0x01	; 1
    2fc8:	9c 83       	std	Y+4, r25	; 0x04
    2fca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2fcc:	eb 81       	ldd	r30, Y+3	; 0x03
    2fce:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd0:	88 e2       	ldi	r24, 0x28	; 40
    2fd2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd8:	01 97       	sbiw	r24, 0x01	; 1
    2fda:	9c 83       	std	Y+4, r25	; 0x04
    2fdc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2fde:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe2:	89 e2       	ldi	r24, 0x29	; 41
    2fe4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fea:	01 97       	sbiw	r24, 0x01	; 1
    2fec:	9c 83       	std	Y+4, r25	; 0x04
    2fee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff4:	80 e3       	ldi	r24, 0x30	; 48
    2ff6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    2ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    2ffc:	01 97       	sbiw	r24, 0x01	; 1
    2ffe:	9c 83       	std	Y+4, r25	; 0x04
    3000:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3002:	eb 81       	ldd	r30, Y+3	; 0x03
    3004:	fc 81       	ldd	r31, Y+4	; 0x04
    3006:	81 e3       	ldi	r24, 0x31	; 49
    3008:	80 83       	st	Z, r24
	pxTopOfStack--;
    300a:	8b 81       	ldd	r24, Y+3	; 0x03
    300c:	9c 81       	ldd	r25, Y+4	; 0x04
    300e:	01 97       	sbiw	r24, 0x01	; 1
    3010:	9c 83       	std	Y+4, r25	; 0x04
    3012:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3014:	8b 81       	ldd	r24, Y+3	; 0x03
    3016:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3018:	28 96       	adiw	r28, 0x08	; 8
    301a:	0f b6       	in	r0, 0x3f	; 63
    301c:	f8 94       	cli
    301e:	de bf       	out	0x3e, r29	; 62
    3020:	0f be       	out	0x3f, r0	; 63
    3022:	cd bf       	out	0x3d, r28	; 61
    3024:	cf 91       	pop	r28
    3026:	df 91       	pop	r29
    3028:	08 95       	ret

0000302a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    302a:	df 93       	push	r29
    302c:	cf 93       	push	r28
    302e:	cd b7       	in	r28, 0x3d	; 61
    3030:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3032:	0e 94 07 19 	call	0x320e	; 0x320e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3036:	a0 91 91 06 	lds	r26, 0x0691
    303a:	b0 91 92 06 	lds	r27, 0x0692
    303e:	cd 91       	ld	r28, X+
    3040:	cd bf       	out	0x3d, r28	; 61
    3042:	dd 91       	ld	r29, X+
    3044:	de bf       	out	0x3e, r29	; 62
    3046:	ff 91       	pop	r31
    3048:	ef 91       	pop	r30
    304a:	df 91       	pop	r29
    304c:	cf 91       	pop	r28
    304e:	bf 91       	pop	r27
    3050:	af 91       	pop	r26
    3052:	9f 91       	pop	r25
    3054:	8f 91       	pop	r24
    3056:	7f 91       	pop	r23
    3058:	6f 91       	pop	r22
    305a:	5f 91       	pop	r21
    305c:	4f 91       	pop	r20
    305e:	3f 91       	pop	r19
    3060:	2f 91       	pop	r18
    3062:	1f 91       	pop	r17
    3064:	0f 91       	pop	r16
    3066:	ff 90       	pop	r15
    3068:	ef 90       	pop	r14
    306a:	df 90       	pop	r13
    306c:	cf 90       	pop	r12
    306e:	bf 90       	pop	r11
    3070:	af 90       	pop	r10
    3072:	9f 90       	pop	r9
    3074:	8f 90       	pop	r8
    3076:	7f 90       	pop	r7
    3078:	6f 90       	pop	r6
    307a:	5f 90       	pop	r5
    307c:	4f 90       	pop	r4
    307e:	3f 90       	pop	r3
    3080:	2f 90       	pop	r2
    3082:	1f 90       	pop	r1
    3084:	0f 90       	pop	r0
    3086:	0f be       	out	0x3f, r0	; 63
    3088:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    308a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    308c:	81 e0       	ldi	r24, 0x01	; 1
}
    308e:	cf 91       	pop	r28
    3090:	df 91       	pop	r29
    3092:	08 95       	ret

00003094 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3094:	df 93       	push	r29
    3096:	cf 93       	push	r28
    3098:	cd b7       	in	r28, 0x3d	; 61
    309a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    309c:	cf 91       	pop	r28
    309e:	df 91       	pop	r29
    30a0:	08 95       	ret

000030a2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    30a2:	0f 92       	push	r0
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	f8 94       	cli
    30a8:	0f 92       	push	r0
    30aa:	1f 92       	push	r1
    30ac:	11 24       	eor	r1, r1
    30ae:	2f 92       	push	r2
    30b0:	3f 92       	push	r3
    30b2:	4f 92       	push	r4
    30b4:	5f 92       	push	r5
    30b6:	6f 92       	push	r6
    30b8:	7f 92       	push	r7
    30ba:	8f 92       	push	r8
    30bc:	9f 92       	push	r9
    30be:	af 92       	push	r10
    30c0:	bf 92       	push	r11
    30c2:	cf 92       	push	r12
    30c4:	df 92       	push	r13
    30c6:	ef 92       	push	r14
    30c8:	ff 92       	push	r15
    30ca:	0f 93       	push	r16
    30cc:	1f 93       	push	r17
    30ce:	2f 93       	push	r18
    30d0:	3f 93       	push	r19
    30d2:	4f 93       	push	r20
    30d4:	5f 93       	push	r21
    30d6:	6f 93       	push	r22
    30d8:	7f 93       	push	r23
    30da:	8f 93       	push	r24
    30dc:	9f 93       	push	r25
    30de:	af 93       	push	r26
    30e0:	bf 93       	push	r27
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	ef 93       	push	r30
    30e8:	ff 93       	push	r31
    30ea:	a0 91 91 06 	lds	r26, 0x0691
    30ee:	b0 91 92 06 	lds	r27, 0x0692
    30f2:	0d b6       	in	r0, 0x3d	; 61
    30f4:	0d 92       	st	X+, r0
    30f6:	0e b6       	in	r0, 0x3e	; 62
    30f8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    30fa:	0e 94 41 31 	call	0x6282	; 0x6282 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    30fe:	a0 91 91 06 	lds	r26, 0x0691
    3102:	b0 91 92 06 	lds	r27, 0x0692
    3106:	cd 91       	ld	r28, X+
    3108:	cd bf       	out	0x3d, r28	; 61
    310a:	dd 91       	ld	r29, X+
    310c:	de bf       	out	0x3e, r29	; 62
    310e:	ff 91       	pop	r31
    3110:	ef 91       	pop	r30
    3112:	df 91       	pop	r29
    3114:	cf 91       	pop	r28
    3116:	bf 91       	pop	r27
    3118:	af 91       	pop	r26
    311a:	9f 91       	pop	r25
    311c:	8f 91       	pop	r24
    311e:	7f 91       	pop	r23
    3120:	6f 91       	pop	r22
    3122:	5f 91       	pop	r21
    3124:	4f 91       	pop	r20
    3126:	3f 91       	pop	r19
    3128:	2f 91       	pop	r18
    312a:	1f 91       	pop	r17
    312c:	0f 91       	pop	r16
    312e:	ff 90       	pop	r15
    3130:	ef 90       	pop	r14
    3132:	df 90       	pop	r13
    3134:	cf 90       	pop	r12
    3136:	bf 90       	pop	r11
    3138:	af 90       	pop	r10
    313a:	9f 90       	pop	r9
    313c:	8f 90       	pop	r8
    313e:	7f 90       	pop	r7
    3140:	6f 90       	pop	r6
    3142:	5f 90       	pop	r5
    3144:	4f 90       	pop	r4
    3146:	3f 90       	pop	r3
    3148:	2f 90       	pop	r2
    314a:	1f 90       	pop	r1
    314c:	0f 90       	pop	r0
    314e:	0f be       	out	0x3f, r0	; 63
    3150:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3152:	08 95       	ret

00003154 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3154:	0f 92       	push	r0
    3156:	0f b6       	in	r0, 0x3f	; 63
    3158:	f8 94       	cli
    315a:	0f 92       	push	r0
    315c:	1f 92       	push	r1
    315e:	11 24       	eor	r1, r1
    3160:	2f 92       	push	r2
    3162:	3f 92       	push	r3
    3164:	4f 92       	push	r4
    3166:	5f 92       	push	r5
    3168:	6f 92       	push	r6
    316a:	7f 92       	push	r7
    316c:	8f 92       	push	r8
    316e:	9f 92       	push	r9
    3170:	af 92       	push	r10
    3172:	bf 92       	push	r11
    3174:	cf 92       	push	r12
    3176:	df 92       	push	r13
    3178:	ef 92       	push	r14
    317a:	ff 92       	push	r15
    317c:	0f 93       	push	r16
    317e:	1f 93       	push	r17
    3180:	2f 93       	push	r18
    3182:	3f 93       	push	r19
    3184:	4f 93       	push	r20
    3186:	5f 93       	push	r21
    3188:	6f 93       	push	r22
    318a:	7f 93       	push	r23
    318c:	8f 93       	push	r24
    318e:	9f 93       	push	r25
    3190:	af 93       	push	r26
    3192:	bf 93       	push	r27
    3194:	cf 93       	push	r28
    3196:	df 93       	push	r29
    3198:	ef 93       	push	r30
    319a:	ff 93       	push	r31
    319c:	a0 91 91 06 	lds	r26, 0x0691
    31a0:	b0 91 92 06 	lds	r27, 0x0692
    31a4:	0d b6       	in	r0, 0x3d	; 61
    31a6:	0d 92       	st	X+, r0
    31a8:	0e b6       	in	r0, 0x3e	; 62
    31aa:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    31ac:	0e 94 aa 2f 	call	0x5f54	; 0x5f54 <xTaskIncrementTick>
    31b0:	88 23       	and	r24, r24
    31b2:	11 f0       	breq	.+4      	; 0x31b8 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    31b4:	0e 94 41 31 	call	0x6282	; 0x6282 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    31b8:	a0 91 91 06 	lds	r26, 0x0691
    31bc:	b0 91 92 06 	lds	r27, 0x0692
    31c0:	cd 91       	ld	r28, X+
    31c2:	cd bf       	out	0x3d, r28	; 61
    31c4:	dd 91       	ld	r29, X+
    31c6:	de bf       	out	0x3e, r29	; 62
    31c8:	ff 91       	pop	r31
    31ca:	ef 91       	pop	r30
    31cc:	df 91       	pop	r29
    31ce:	cf 91       	pop	r28
    31d0:	bf 91       	pop	r27
    31d2:	af 91       	pop	r26
    31d4:	9f 91       	pop	r25
    31d6:	8f 91       	pop	r24
    31d8:	7f 91       	pop	r23
    31da:	6f 91       	pop	r22
    31dc:	5f 91       	pop	r21
    31de:	4f 91       	pop	r20
    31e0:	3f 91       	pop	r19
    31e2:	2f 91       	pop	r18
    31e4:	1f 91       	pop	r17
    31e6:	0f 91       	pop	r16
    31e8:	ff 90       	pop	r15
    31ea:	ef 90       	pop	r14
    31ec:	df 90       	pop	r13
    31ee:	cf 90       	pop	r12
    31f0:	bf 90       	pop	r11
    31f2:	af 90       	pop	r10
    31f4:	9f 90       	pop	r9
    31f6:	8f 90       	pop	r8
    31f8:	7f 90       	pop	r7
    31fa:	6f 90       	pop	r6
    31fc:	5f 90       	pop	r5
    31fe:	4f 90       	pop	r4
    3200:	3f 90       	pop	r3
    3202:	2f 90       	pop	r2
    3204:	1f 90       	pop	r1
    3206:	0f 90       	pop	r0
    3208:	0f be       	out	0x3f, r0	; 63
    320a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    320c:	08 95       	ret

0000320e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    320e:	df 93       	push	r29
    3210:	cf 93       	push	r28
    3212:	00 d0       	rcall	.+0      	; 0x3214 <prvSetupTimerInterrupt+0x6>
    3214:	00 d0       	rcall	.+0      	; 0x3216 <prvSetupTimerInterrupt+0x8>
    3216:	00 d0       	rcall	.+0      	; 0x3218 <prvSetupTimerInterrupt+0xa>
    3218:	cd b7       	in	r28, 0x3d	; 61
    321a:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    321c:	80 e8       	ldi	r24, 0x80	; 128
    321e:	9e e3       	ldi	r25, 0x3E	; 62
    3220:	a0 e0       	ldi	r26, 0x00	; 0
    3222:	b0 e0       	ldi	r27, 0x00	; 0
    3224:	8b 83       	std	Y+3, r24	; 0x03
    3226:	9c 83       	std	Y+4, r25	; 0x04
    3228:	ad 83       	std	Y+5, r26	; 0x05
    322a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    322c:	8b 81       	ldd	r24, Y+3	; 0x03
    322e:	9c 81       	ldd	r25, Y+4	; 0x04
    3230:	ad 81       	ldd	r26, Y+5	; 0x05
    3232:	be 81       	ldd	r27, Y+6	; 0x06
    3234:	68 94       	set
    3236:	15 f8       	bld	r1, 5
    3238:	b6 95       	lsr	r27
    323a:	a7 95       	ror	r26
    323c:	97 95       	ror	r25
    323e:	87 95       	ror	r24
    3240:	16 94       	lsr	r1
    3242:	d1 f7       	brne	.-12     	; 0x3238 <prvSetupTimerInterrupt+0x2a>
    3244:	8b 83       	std	Y+3, r24	; 0x03
    3246:	9c 83       	std	Y+4, r25	; 0x04
    3248:	ad 83       	std	Y+5, r26	; 0x05
    324a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    324c:	8b 81       	ldd	r24, Y+3	; 0x03
    324e:	9c 81       	ldd	r25, Y+4	; 0x04
    3250:	ad 81       	ldd	r26, Y+5	; 0x05
    3252:	be 81       	ldd	r27, Y+6	; 0x06
    3254:	01 97       	sbiw	r24, 0x01	; 1
    3256:	a1 09       	sbc	r26, r1
    3258:	b1 09       	sbc	r27, r1
    325a:	8b 83       	std	Y+3, r24	; 0x03
    325c:	9c 83       	std	Y+4, r25	; 0x04
    325e:	ad 83       	std	Y+5, r26	; 0x05
    3260:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3262:	8b 81       	ldd	r24, Y+3	; 0x03
    3264:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3266:	8b 81       	ldd	r24, Y+3	; 0x03
    3268:	9c 81       	ldd	r25, Y+4	; 0x04
    326a:	ad 81       	ldd	r26, Y+5	; 0x05
    326c:	be 81       	ldd	r27, Y+6	; 0x06
    326e:	89 2f       	mov	r24, r25
    3270:	9a 2f       	mov	r25, r26
    3272:	ab 2f       	mov	r26, r27
    3274:	bb 27       	eor	r27, r27
    3276:	8b 83       	std	Y+3, r24	; 0x03
    3278:	9c 83       	std	Y+4, r25	; 0x04
    327a:	ad 83       	std	Y+5, r26	; 0x05
    327c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    327e:	8b 81       	ldd	r24, Y+3	; 0x03
    3280:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3282:	eb e4       	ldi	r30, 0x4B	; 75
    3284:	f0 e0       	ldi	r31, 0x00	; 0
    3286:	8a 81       	ldd	r24, Y+2	; 0x02
    3288:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    328a:	ea e4       	ldi	r30, 0x4A	; 74
    328c:	f0 e0       	ldi	r31, 0x00	; 0
    328e:	89 81       	ldd	r24, Y+1	; 0x01
    3290:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3292:	8b e0       	ldi	r24, 0x0B	; 11
    3294:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3296:	ee e4       	ldi	r30, 0x4E	; 78
    3298:	f0 e0       	ldi	r31, 0x00	; 0
    329a:	89 81       	ldd	r24, Y+1	; 0x01
    329c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    329e:	e9 e5       	ldi	r30, 0x59	; 89
    32a0:	f0 e0       	ldi	r31, 0x00	; 0
    32a2:	80 81       	ld	r24, Z
    32a4:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    32a6:	89 81       	ldd	r24, Y+1	; 0x01
    32a8:	80 61       	ori	r24, 0x10	; 16
    32aa:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    32ac:	e9 e5       	ldi	r30, 0x59	; 89
    32ae:	f0 e0       	ldi	r31, 0x00	; 0
    32b0:	89 81       	ldd	r24, Y+1	; 0x01
    32b2:	80 83       	st	Z, r24
}
    32b4:	26 96       	adiw	r28, 0x06	; 6
    32b6:	0f b6       	in	r0, 0x3f	; 63
    32b8:	f8 94       	cli
    32ba:	de bf       	out	0x3e, r29	; 62
    32bc:	0f be       	out	0x3f, r0	; 63
    32be:	cd bf       	out	0x3d, r28	; 61
    32c0:	cf 91       	pop	r28
    32c2:	df 91       	pop	r29
    32c4:	08 95       	ret

000032c6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    32c6:	0e 94 aa 18 	call	0x3154	; 0x3154 <vPortYieldFromTick>
		asm volatile ( "reti" );
    32ca:	18 95       	reti

000032cc <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    32cc:	df 93       	push	r29
    32ce:	cf 93       	push	r28
    32d0:	00 d0       	rcall	.+0      	; 0x32d2 <xQueueGenericReset+0x6>
    32d2:	00 d0       	rcall	.+0      	; 0x32d4 <xQueueGenericReset+0x8>
    32d4:	00 d0       	rcall	.+0      	; 0x32d6 <xQueueGenericReset+0xa>
    32d6:	cd b7       	in	r28, 0x3d	; 61
    32d8:	de b7       	in	r29, 0x3e	; 62
    32da:	9d 83       	std	Y+5, r25	; 0x05
    32dc:	8c 83       	std	Y+4, r24	; 0x04
    32de:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    32e4:	8c 81       	ldd	r24, Y+4	; 0x04
    32e6:	9d 81       	ldd	r25, Y+5	; 0x05
    32e8:	9a 83       	std	Y+2, r25	; 0x02
    32ea:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    32ec:	89 81       	ldd	r24, Y+1	; 0x01
    32ee:	9a 81       	ldd	r25, Y+2	; 0x02
    32f0:	00 97       	sbiw	r24, 0x00	; 0
    32f2:	09 f4       	brne	.+2      	; 0x32f6 <xQueueGenericReset+0x2a>
    32f4:	8b c0       	rjmp	.+278    	; 0x340c <xQueueGenericReset+0x140>
    32f6:	e9 81       	ldd	r30, Y+1	; 0x01
    32f8:	fa 81       	ldd	r31, Y+2	; 0x02
    32fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    32fc:	88 23       	and	r24, r24
    32fe:	09 f4       	brne	.+2      	; 0x3302 <xQueueGenericReset+0x36>
    3300:	85 c0       	rjmp	.+266    	; 0x340c <xQueueGenericReset+0x140>
    3302:	e9 81       	ldd	r30, Y+1	; 0x01
    3304:	fa 81       	ldd	r31, Y+2	; 0x02
    3306:	83 8d       	ldd	r24, Z+27	; 0x1b
    3308:	28 2f       	mov	r18, r24
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	8f ef       	ldi	r24, 0xFF	; 255
    330e:	9f e7       	ldi	r25, 0x7F	; 127
    3310:	b9 01       	movw	r22, r18
    3312:	0e 94 7b 3f 	call	0x7ef6	; 0x7ef6 <__udivmodhi4>
    3316:	cb 01       	movw	r24, r22
    3318:	9c 01       	movw	r18, r24
    331a:	e9 81       	ldd	r30, Y+1	; 0x01
    331c:	fa 81       	ldd	r31, Y+2	; 0x02
    331e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3320:	88 2f       	mov	r24, r24
    3322:	90 e0       	ldi	r25, 0x00	; 0
    3324:	28 17       	cp	r18, r24
    3326:	39 07       	cpc	r19, r25
    3328:	08 f4       	brcc	.+2      	; 0x332c <xQueueGenericReset+0x60>
    332a:	70 c0       	rjmp	.+224    	; 0x340c <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    332c:	0f b6       	in	r0, 0x3f	; 63
    332e:	f8 94       	cli
    3330:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3332:	e9 81       	ldd	r30, Y+1	; 0x01
    3334:	fa 81       	ldd	r31, Y+2	; 0x02
    3336:	40 81       	ld	r20, Z
    3338:	51 81       	ldd	r21, Z+1	; 0x01
    333a:	e9 81       	ldd	r30, Y+1	; 0x01
    333c:	fa 81       	ldd	r31, Y+2	; 0x02
    333e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3340:	28 2f       	mov	r18, r24
    3342:	30 e0       	ldi	r19, 0x00	; 0
    3344:	e9 81       	ldd	r30, Y+1	; 0x01
    3346:	fa 81       	ldd	r31, Y+2	; 0x02
    3348:	84 8d       	ldd	r24, Z+28	; 0x1c
    334a:	88 2f       	mov	r24, r24
    334c:	90 e0       	ldi	r25, 0x00	; 0
    334e:	bc 01       	movw	r22, r24
    3350:	26 9f       	mul	r18, r22
    3352:	c0 01       	movw	r24, r0
    3354:	27 9f       	mul	r18, r23
    3356:	90 0d       	add	r25, r0
    3358:	36 9f       	mul	r19, r22
    335a:	90 0d       	add	r25, r0
    335c:	11 24       	eor	r1, r1
    335e:	84 0f       	add	r24, r20
    3360:	95 1f       	adc	r25, r21
    3362:	e9 81       	ldd	r30, Y+1	; 0x01
    3364:	fa 81       	ldd	r31, Y+2	; 0x02
    3366:	95 83       	std	Z+5, r25	; 0x05
    3368:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    336a:	e9 81       	ldd	r30, Y+1	; 0x01
    336c:	fa 81       	ldd	r31, Y+2	; 0x02
    336e:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3370:	e9 81       	ldd	r30, Y+1	; 0x01
    3372:	fa 81       	ldd	r31, Y+2	; 0x02
    3374:	80 81       	ld	r24, Z
    3376:	91 81       	ldd	r25, Z+1	; 0x01
    3378:	e9 81       	ldd	r30, Y+1	; 0x01
    337a:	fa 81       	ldd	r31, Y+2	; 0x02
    337c:	93 83       	std	Z+3, r25	; 0x03
    337e:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3380:	e9 81       	ldd	r30, Y+1	; 0x01
    3382:	fa 81       	ldd	r31, Y+2	; 0x02
    3384:	40 81       	ld	r20, Z
    3386:	51 81       	ldd	r21, Z+1	; 0x01
    3388:	e9 81       	ldd	r30, Y+1	; 0x01
    338a:	fa 81       	ldd	r31, Y+2	; 0x02
    338c:	83 8d       	ldd	r24, Z+27	; 0x1b
    338e:	88 2f       	mov	r24, r24
    3390:	90 e0       	ldi	r25, 0x00	; 0
    3392:	9c 01       	movw	r18, r24
    3394:	21 50       	subi	r18, 0x01	; 1
    3396:	30 40       	sbci	r19, 0x00	; 0
    3398:	e9 81       	ldd	r30, Y+1	; 0x01
    339a:	fa 81       	ldd	r31, Y+2	; 0x02
    339c:	84 8d       	ldd	r24, Z+28	; 0x1c
    339e:	88 2f       	mov	r24, r24
    33a0:	90 e0       	ldi	r25, 0x00	; 0
    33a2:	bc 01       	movw	r22, r24
    33a4:	26 9f       	mul	r18, r22
    33a6:	c0 01       	movw	r24, r0
    33a8:	27 9f       	mul	r18, r23
    33aa:	90 0d       	add	r25, r0
    33ac:	36 9f       	mul	r19, r22
    33ae:	90 0d       	add	r25, r0
    33b0:	11 24       	eor	r1, r1
    33b2:	84 0f       	add	r24, r20
    33b4:	95 1f       	adc	r25, r21
    33b6:	e9 81       	ldd	r30, Y+1	; 0x01
    33b8:	fa 81       	ldd	r31, Y+2	; 0x02
    33ba:	97 83       	std	Z+7, r25	; 0x07
    33bc:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    33be:	e9 81       	ldd	r30, Y+1	; 0x01
    33c0:	fa 81       	ldd	r31, Y+2	; 0x02
    33c2:	8f ef       	ldi	r24, 0xFF	; 255
    33c4:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    33c6:	e9 81       	ldd	r30, Y+1	; 0x01
    33c8:	fa 81       	ldd	r31, Y+2	; 0x02
    33ca:	8f ef       	ldi	r24, 0xFF	; 255
    33cc:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    33ce:	8e 81       	ldd	r24, Y+6	; 0x06
    33d0:	88 23       	and	r24, r24
    33d2:	79 f4       	brne	.+30     	; 0x33f2 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    33d4:	e9 81       	ldd	r30, Y+1	; 0x01
    33d6:	fa 81       	ldd	r31, Y+2	; 0x02
    33d8:	80 85       	ldd	r24, Z+8	; 0x08
    33da:	88 23       	and	r24, r24
    33dc:	a1 f0       	breq	.+40     	; 0x3406 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    33de:	89 81       	ldd	r24, Y+1	; 0x01
    33e0:	9a 81       	ldd	r25, Y+2	; 0x02
    33e2:	08 96       	adiw	r24, 0x08	; 8
    33e4:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    33e8:	88 23       	and	r24, r24
    33ea:	69 f0       	breq	.+26     	; 0x3406 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    33ec:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    33f0:	0a c0       	rjmp	.+20     	; 0x3406 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    33f2:	89 81       	ldd	r24, Y+1	; 0x01
    33f4:	9a 81       	ldd	r25, Y+2	; 0x02
    33f6:	08 96       	adiw	r24, 0x08	; 8
    33f8:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    33fc:	89 81       	ldd	r24, Y+1	; 0x01
    33fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3400:	41 96       	adiw	r24, 0x11	; 17
    3402:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    3406:	0f 90       	pop	r0
    3408:	0f be       	out	0x3f, r0	; 63
    340a:	01 c0       	rjmp	.+2      	; 0x340e <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    340c:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    340e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3410:	26 96       	adiw	r28, 0x06	; 6
    3412:	0f b6       	in	r0, 0x3f	; 63
    3414:	f8 94       	cli
    3416:	de bf       	out	0x3e, r29	; 62
    3418:	0f be       	out	0x3f, r0	; 63
    341a:	cd bf       	out	0x3d, r28	; 61
    341c:	cf 91       	pop	r28
    341e:	df 91       	pop	r29
    3420:	08 95       	ret

00003422 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    3422:	0f 93       	push	r16
    3424:	1f 93       	push	r17
    3426:	df 93       	push	r29
    3428:	cf 93       	push	r28
    342a:	cd b7       	in	r28, 0x3d	; 61
    342c:	de b7       	in	r29, 0x3e	; 62
    342e:	29 97       	sbiw	r28, 0x09	; 9
    3430:	0f b6       	in	r0, 0x3f	; 63
    3432:	f8 94       	cli
    3434:	de bf       	out	0x3e, r29	; 62
    3436:	0f be       	out	0x3f, r0	; 63
    3438:	cd bf       	out	0x3d, r28	; 61
    343a:	8f 83       	std	Y+7, r24	; 0x07
    343c:	68 87       	std	Y+8, r22	; 0x08
    343e:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    3440:	1e 82       	std	Y+6, r1	; 0x06
    3442:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    3444:	8f 81       	ldd	r24, Y+7	; 0x07
    3446:	88 23       	and	r24, r24
    3448:	09 f4       	brne	.+2      	; 0x344c <xQueueGenericCreate+0x2a>
    344a:	52 c0       	rjmp	.+164    	; 0x34f0 <xQueueGenericCreate+0xce>
    344c:	8f 81       	ldd	r24, Y+7	; 0x07
    344e:	28 2f       	mov	r18, r24
    3450:	30 e0       	ldi	r19, 0x00	; 0
    3452:	8f ef       	ldi	r24, 0xFF	; 255
    3454:	9f e7       	ldi	r25, 0x7F	; 127
    3456:	b9 01       	movw	r22, r18
    3458:	0e 94 7b 3f 	call	0x7ef6	; 0x7ef6 <__udivmodhi4>
    345c:	cb 01       	movw	r24, r22
    345e:	9c 01       	movw	r18, r24
    3460:	88 85       	ldd	r24, Y+8	; 0x08
    3462:	88 2f       	mov	r24, r24
    3464:	90 e0       	ldi	r25, 0x00	; 0
    3466:	28 17       	cp	r18, r24
    3468:	39 07       	cpc	r19, r25
    346a:	08 f4       	brcc	.+2      	; 0x346e <xQueueGenericCreate+0x4c>
    346c:	41 c0       	rjmp	.+130    	; 0x34f0 <xQueueGenericCreate+0xce>
    346e:	8f 81       	ldd	r24, Y+7	; 0x07
    3470:	28 2f       	mov	r18, r24
    3472:	30 e0       	ldi	r19, 0x00	; 0
    3474:	88 85       	ldd	r24, Y+8	; 0x08
    3476:	88 2f       	mov	r24, r24
    3478:	90 e0       	ldi	r25, 0x00	; 0
    347a:	ac 01       	movw	r20, r24
    347c:	24 9f       	mul	r18, r20
    347e:	c0 01       	movw	r24, r0
    3480:	25 9f       	mul	r18, r21
    3482:	90 0d       	add	r25, r0
    3484:	34 9f       	mul	r19, r20
    3486:	90 0d       	add	r25, r0
    3488:	11 24       	eor	r1, r1
    348a:	5f e7       	ldi	r21, 0x7F	; 127
    348c:	81 3e       	cpi	r24, 0xE1	; 225
    348e:	95 07       	cpc	r25, r21
    3490:	78 f5       	brcc	.+94     	; 0x34f0 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3492:	8f 81       	ldd	r24, Y+7	; 0x07
    3494:	28 2f       	mov	r18, r24
    3496:	30 e0       	ldi	r19, 0x00	; 0
    3498:	88 85       	ldd	r24, Y+8	; 0x08
    349a:	88 2f       	mov	r24, r24
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	ac 01       	movw	r20, r24
    34a0:	24 9f       	mul	r18, r20
    34a2:	c0 01       	movw	r24, r0
    34a4:	25 9f       	mul	r18, r21
    34a6:	90 0d       	add	r25, r0
    34a8:	34 9f       	mul	r19, r20
    34aa:	90 0d       	add	r25, r0
    34ac:	11 24       	eor	r1, r1
    34ae:	9c 83       	std	Y+4, r25	; 0x04
    34b0:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    34b2:	8b 81       	ldd	r24, Y+3	; 0x03
    34b4:	9c 81       	ldd	r25, Y+4	; 0x04
    34b6:	4f 96       	adiw	r24, 0x1f	; 31
    34b8:	0e 94 ae 12 	call	0x255c	; 0x255c <pvPortMalloc>
    34bc:	9e 83       	std	Y+6, r25	; 0x06
    34be:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    34c0:	8d 81       	ldd	r24, Y+5	; 0x05
    34c2:	9e 81       	ldd	r25, Y+6	; 0x06
    34c4:	00 97       	sbiw	r24, 0x00	; 0
    34c6:	a1 f0       	breq	.+40     	; 0x34f0 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    34c8:	8d 81       	ldd	r24, Y+5	; 0x05
    34ca:	9e 81       	ldd	r25, Y+6	; 0x06
    34cc:	9a 83       	std	Y+2, r25	; 0x02
    34ce:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    34d0:	89 81       	ldd	r24, Y+1	; 0x01
    34d2:	9a 81       	ldd	r25, Y+2	; 0x02
    34d4:	4f 96       	adiw	r24, 0x1f	; 31
    34d6:	9a 83       	std	Y+2, r25	; 0x02
    34d8:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    34da:	29 81       	ldd	r18, Y+1	; 0x01
    34dc:	3a 81       	ldd	r19, Y+2	; 0x02
    34de:	ed 81       	ldd	r30, Y+5	; 0x05
    34e0:	fe 81       	ldd	r31, Y+6	; 0x06
    34e2:	8f 81       	ldd	r24, Y+7	; 0x07
    34e4:	68 85       	ldd	r22, Y+8	; 0x08
    34e6:	a9 01       	movw	r20, r18
    34e8:	29 85       	ldd	r18, Y+9	; 0x09
    34ea:	8f 01       	movw	r16, r30
    34ec:	0e 94 85 1a 	call	0x350a	; 0x350a <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    34f0:	8d 81       	ldd	r24, Y+5	; 0x05
    34f2:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    34f4:	29 96       	adiw	r28, 0x09	; 9
    34f6:	0f b6       	in	r0, 0x3f	; 63
    34f8:	f8 94       	cli
    34fa:	de bf       	out	0x3e, r29	; 62
    34fc:	0f be       	out	0x3f, r0	; 63
    34fe:	cd bf       	out	0x3d, r28	; 61
    3500:	cf 91       	pop	r28
    3502:	df 91       	pop	r29
    3504:	1f 91       	pop	r17
    3506:	0f 91       	pop	r16
    3508:	08 95       	ret

0000350a <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    350a:	0f 93       	push	r16
    350c:	1f 93       	push	r17
    350e:	df 93       	push	r29
    3510:	cf 93       	push	r28
    3512:	cd b7       	in	r28, 0x3d	; 61
    3514:	de b7       	in	r29, 0x3e	; 62
    3516:	27 97       	sbiw	r28, 0x07	; 7
    3518:	0f b6       	in	r0, 0x3f	; 63
    351a:	f8 94       	cli
    351c:	de bf       	out	0x3e, r29	; 62
    351e:	0f be       	out	0x3f, r0	; 63
    3520:	cd bf       	out	0x3d, r28	; 61
    3522:	89 83       	std	Y+1, r24	; 0x01
    3524:	6a 83       	std	Y+2, r22	; 0x02
    3526:	5c 83       	std	Y+4, r21	; 0x04
    3528:	4b 83       	std	Y+3, r20	; 0x03
    352a:	2d 83       	std	Y+5, r18	; 0x05
    352c:	1f 83       	std	Y+7, r17	; 0x07
    352e:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    3530:	8a 81       	ldd	r24, Y+2	; 0x02
    3532:	88 23       	and	r24, r24
    3534:	39 f4       	brne	.+14     	; 0x3544 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3536:	8e 81       	ldd	r24, Y+6	; 0x06
    3538:	9f 81       	ldd	r25, Y+7	; 0x07
    353a:	ee 81       	ldd	r30, Y+6	; 0x06
    353c:	ff 81       	ldd	r31, Y+7	; 0x07
    353e:	91 83       	std	Z+1, r25	; 0x01
    3540:	80 83       	st	Z, r24
    3542:	06 c0       	rjmp	.+12     	; 0x3550 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3544:	8b 81       	ldd	r24, Y+3	; 0x03
    3546:	9c 81       	ldd	r25, Y+4	; 0x04
    3548:	ee 81       	ldd	r30, Y+6	; 0x06
    354a:	ff 81       	ldd	r31, Y+7	; 0x07
    354c:	91 83       	std	Z+1, r25	; 0x01
    354e:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    3550:	ee 81       	ldd	r30, Y+6	; 0x06
    3552:	ff 81       	ldd	r31, Y+7	; 0x07
    3554:	89 81       	ldd	r24, Y+1	; 0x01
    3556:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    3558:	ee 81       	ldd	r30, Y+6	; 0x06
    355a:	ff 81       	ldd	r31, Y+7	; 0x07
    355c:	8a 81       	ldd	r24, Y+2	; 0x02
    355e:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3560:	8e 81       	ldd	r24, Y+6	; 0x06
    3562:	9f 81       	ldd	r25, Y+7	; 0x07
    3564:	61 e0       	ldi	r22, 0x01	; 1
    3566:	0e 94 66 19 	call	0x32cc	; 0x32cc <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    356a:	27 96       	adiw	r28, 0x07	; 7
    356c:	0f b6       	in	r0, 0x3f	; 63
    356e:	f8 94       	cli
    3570:	de bf       	out	0x3e, r29	; 62
    3572:	0f be       	out	0x3f, r0	; 63
    3574:	cd bf       	out	0x3d, r28	; 61
    3576:	cf 91       	pop	r28
    3578:	df 91       	pop	r29
    357a:	1f 91       	pop	r17
    357c:	0f 91       	pop	r16
    357e:	08 95       	ret

00003580 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    3580:	df 93       	push	r29
    3582:	cf 93       	push	r28
    3584:	cd b7       	in	r28, 0x3d	; 61
    3586:	de b7       	in	r29, 0x3e	; 62
    3588:	2f 97       	sbiw	r28, 0x0f	; 15
    358a:	0f b6       	in	r0, 0x3f	; 63
    358c:	f8 94       	cli
    358e:	de bf       	out	0x3e, r29	; 62
    3590:	0f be       	out	0x3f, r0	; 63
    3592:	cd bf       	out	0x3d, r28	; 61
    3594:	99 87       	std	Y+9, r25	; 0x09
    3596:	88 87       	std	Y+8, r24	; 0x08
    3598:	7b 87       	std	Y+11, r23	; 0x0b
    359a:	6a 87       	std	Y+10, r22	; 0x0a
    359c:	5d 87       	std	Y+13, r21	; 0x0d
    359e:	4c 87       	std	Y+12, r20	; 0x0c
    35a0:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    35a2:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    35a4:	88 85       	ldd	r24, Y+8	; 0x08
    35a6:	99 85       	ldd	r25, Y+9	; 0x09
    35a8:	9a 83       	std	Y+2, r25	; 0x02
    35aa:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    35ac:	0f b6       	in	r0, 0x3f	; 63
    35ae:	f8 94       	cli
    35b0:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    35b2:	e9 81       	ldd	r30, Y+1	; 0x01
    35b4:	fa 81       	ldd	r31, Y+2	; 0x02
    35b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    35b8:	e9 81       	ldd	r30, Y+1	; 0x01
    35ba:	fa 81       	ldd	r31, Y+2	; 0x02
    35bc:	83 8d       	ldd	r24, Z+27	; 0x1b
    35be:	98 17       	cp	r25, r24
    35c0:	18 f0       	brcs	.+6      	; 0x35c8 <xQueueGenericSend+0x48>
    35c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    35c4:	82 30       	cpi	r24, 0x02	; 2
    35c6:	11 f5       	brne	.+68     	; 0x360c <xQueueGenericSend+0x8c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    35c8:	89 81       	ldd	r24, Y+1	; 0x01
    35ca:	9a 81       	ldd	r25, Y+2	; 0x02
    35cc:	2a 85       	ldd	r18, Y+10	; 0x0a
    35ce:	3b 85       	ldd	r19, Y+11	; 0x0b
    35d0:	b9 01       	movw	r22, r18
    35d2:	4e 85       	ldd	r20, Y+14	; 0x0e
    35d4:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <prvCopyDataToQueue>
    35d8:	8b 83       	std	Y+3, r24	; 0x03

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    35da:	e9 81       	ldd	r30, Y+1	; 0x01
    35dc:	fa 81       	ldd	r31, Y+2	; 0x02
    35de:	81 89       	ldd	r24, Z+17	; 0x11
    35e0:	88 23       	and	r24, r24
    35e2:	51 f0       	breq	.+20     	; 0x35f8 <xQueueGenericSend+0x78>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    35e4:	89 81       	ldd	r24, Y+1	; 0x01
    35e6:	9a 81       	ldd	r25, Y+2	; 0x02
    35e8:	41 96       	adiw	r24, 0x11	; 17
    35ea:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    35ee:	88 23       	and	r24, r24
    35f0:	41 f0       	breq	.+16     	; 0x3602 <xQueueGenericSend+0x82>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    35f2:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    35f6:	05 c0       	rjmp	.+10     	; 0x3602 <xQueueGenericSend+0x82>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    35f8:	8b 81       	ldd	r24, Y+3	; 0x03
    35fa:	88 23       	and	r24, r24
    35fc:	11 f0       	breq	.+4      	; 0x3602 <xQueueGenericSend+0x82>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    35fe:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    3602:	0f 90       	pop	r0
    3604:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3606:	81 e0       	ldi	r24, 0x01	; 1
    3608:	8f 87       	std	Y+15, r24	; 0x0f
    360a:	5c c0       	rjmp	.+184    	; 0x36c4 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    360c:	8c 85       	ldd	r24, Y+12	; 0x0c
    360e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3610:	00 97       	sbiw	r24, 0x00	; 0
    3612:	21 f4       	brne	.+8      	; 0x361c <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3614:	0f 90       	pop	r0
    3616:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    3618:	1f 86       	std	Y+15, r1	; 0x0f
    361a:	54 c0       	rjmp	.+168    	; 0x36c4 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    361c:	8c 81       	ldd	r24, Y+4	; 0x04
    361e:	88 23       	and	r24, r24
    3620:	31 f4       	brne	.+12     	; 0x362e <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3622:	ce 01       	movw	r24, r28
    3624:	05 96       	adiw	r24, 0x05	; 5
    3626:	0e 94 a5 34 	call	0x694a	; 0x694a <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    362a:	81 e0       	ldi	r24, 0x01	; 1
    362c:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    362e:	0f 90       	pop	r0
    3630:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3632:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3636:	0f b6       	in	r0, 0x3f	; 63
    3638:	f8 94       	cli
    363a:	0f 92       	push	r0
    363c:	e9 81       	ldd	r30, Y+1	; 0x01
    363e:	fa 81       	ldd	r31, Y+2	; 0x02
    3640:	85 8d       	ldd	r24, Z+29	; 0x1d
    3642:	8f 3f       	cpi	r24, 0xFF	; 255
    3644:	19 f4       	brne	.+6      	; 0x364c <xQueueGenericSend+0xcc>
    3646:	e9 81       	ldd	r30, Y+1	; 0x01
    3648:	fa 81       	ldd	r31, Y+2	; 0x02
    364a:	15 8e       	std	Z+29, r1	; 0x1d
    364c:	e9 81       	ldd	r30, Y+1	; 0x01
    364e:	fa 81       	ldd	r31, Y+2	; 0x02
    3650:	86 8d       	ldd	r24, Z+30	; 0x1e
    3652:	8f 3f       	cpi	r24, 0xFF	; 255
    3654:	19 f4       	brne	.+6      	; 0x365c <xQueueGenericSend+0xdc>
    3656:	e9 81       	ldd	r30, Y+1	; 0x01
    3658:	fa 81       	ldd	r31, Y+2	; 0x02
    365a:	16 8e       	std	Z+30, r1	; 0x1e
    365c:	0f 90       	pop	r0
    365e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3660:	ce 01       	movw	r24, r28
    3662:	05 96       	adiw	r24, 0x05	; 5
    3664:	9e 01       	movw	r18, r28
    3666:	24 5f       	subi	r18, 0xF4	; 244
    3668:	3f 4f       	sbci	r19, 0xFF	; 255
    366a:	b9 01       	movw	r22, r18
    366c:	0e 94 be 34 	call	0x697c	; 0x697c <xTaskCheckForTimeOut>
    3670:	88 23       	and	r24, r24
    3672:	09 f5       	brne	.+66     	; 0x36b6 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3674:	89 81       	ldd	r24, Y+1	; 0x01
    3676:	9a 81       	ldd	r25, Y+2	; 0x02
    3678:	0e 94 a7 20 	call	0x414e	; 0x414e <prvIsQueueFull>
    367c:	88 23       	and	r24, r24
    367e:	a1 f0       	breq	.+40     	; 0x36a8 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	9a 81       	ldd	r25, Y+2	; 0x02
    3684:	08 96       	adiw	r24, 0x08	; 8
    3686:	2c 85       	ldd	r18, Y+12	; 0x0c
    3688:	3d 85       	ldd	r19, Y+13	; 0x0d
    368a:	b9 01       	movw	r22, r18
    368c:	0e 94 ae 31 	call	0x635c	; 0x635c <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    3690:	89 81       	ldd	r24, Y+1	; 0x01
    3692:	9a 81       	ldd	r25, Y+2	; 0x02
    3694:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    3698:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    369c:	88 23       	and	r24, r24
    369e:	09 f0       	breq	.+2      	; 0x36a2 <xQueueGenericSend+0x122>
    36a0:	85 cf       	rjmp	.-246    	; 0x35ac <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    36a2:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    36a6:	82 cf       	rjmp	.-252    	; 0x35ac <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    36a8:	89 81       	ldd	r24, Y+1	; 0x01
    36aa:	9a 81       	ldd	r25, Y+2	; 0x02
    36ac:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    36b0:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    36b4:	7b cf       	rjmp	.-266    	; 0x35ac <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    36b6:	89 81       	ldd	r24, Y+1	; 0x01
    36b8:	9a 81       	ldd	r25, Y+2	; 0x02
    36ba:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    36be:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    36c2:	1f 86       	std	Y+15, r1	; 0x0f
    36c4:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    36c6:	2f 96       	adiw	r28, 0x0f	; 15
    36c8:	0f b6       	in	r0, 0x3f	; 63
    36ca:	f8 94       	cli
    36cc:	de bf       	out	0x3e, r29	; 62
    36ce:	0f be       	out	0x3f, r0	; 63
    36d0:	cd bf       	out	0x3d, r28	; 61
    36d2:	cf 91       	pop	r28
    36d4:	df 91       	pop	r29
    36d6:	08 95       	ret

000036d8 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    36d8:	df 93       	push	r29
    36da:	cf 93       	push	r28
    36dc:	cd b7       	in	r28, 0x3d	; 61
    36de:	de b7       	in	r29, 0x3e	; 62
    36e0:	2e 97       	sbiw	r28, 0x0e	; 14
    36e2:	0f b6       	in	r0, 0x3f	; 63
    36e4:	f8 94       	cli
    36e6:	de bf       	out	0x3e, r29	; 62
    36e8:	0f be       	out	0x3f, r0	; 63
    36ea:	cd bf       	out	0x3d, r28	; 61
    36ec:	99 87       	std	Y+9, r25	; 0x09
    36ee:	88 87       	std	Y+8, r24	; 0x08
    36f0:	7b 87       	std	Y+11, r23	; 0x0b
    36f2:	6a 87       	std	Y+10, r22	; 0x0a
    36f4:	5d 87       	std	Y+13, r21	; 0x0d
    36f6:	4c 87       	std	Y+12, r20	; 0x0c
    36f8:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    36fa:	88 85       	ldd	r24, Y+8	; 0x08
    36fc:	99 85       	ldd	r25, Y+9	; 0x09
    36fe:	9d 83       	std	Y+5, r25	; 0x05
    3700:	8c 83       	std	Y+4, r24	; 0x04
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3702:	1e 82       	std	Y+6, r1	; 0x06
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3704:	ec 81       	ldd	r30, Y+4	; 0x04
    3706:	fd 81       	ldd	r31, Y+5	; 0x05
    3708:	92 8d       	ldd	r25, Z+26	; 0x1a
    370a:	ec 81       	ldd	r30, Y+4	; 0x04
    370c:	fd 81       	ldd	r31, Y+5	; 0x05
    370e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3710:	98 17       	cp	r25, r24
    3712:	18 f0       	brcs	.+6      	; 0x371a <xQueueGenericSendFromISR+0x42>
    3714:	8e 85       	ldd	r24, Y+14	; 0x0e
    3716:	82 30       	cpi	r24, 0x02	; 2
    3718:	b9 f5       	brne	.+110    	; 0x3788 <xQueueGenericSendFromISR+0xb0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    371a:	ec 81       	ldd	r30, Y+4	; 0x04
    371c:	fd 81       	ldd	r31, Y+5	; 0x05
    371e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3720:	8b 83       	std	Y+3, r24	; 0x03
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    3722:	ec 81       	ldd	r30, Y+4	; 0x04
    3724:	fd 81       	ldd	r31, Y+5	; 0x05
    3726:	82 8d       	ldd	r24, Z+26	; 0x1a
    3728:	8a 83       	std	Y+2, r24	; 0x02
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    372a:	8c 81       	ldd	r24, Y+4	; 0x04
    372c:	9d 81       	ldd	r25, Y+5	; 0x05
    372e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3730:	3b 85       	ldd	r19, Y+11	; 0x0b
    3732:	b9 01       	movw	r22, r18
    3734:	4e 85       	ldd	r20, Y+14	; 0x0e
    3736:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	8f 3f       	cpi	r24, 0xFF	; 255
    373e:	a9 f4       	brne	.+42     	; 0x376a <xQueueGenericSendFromISR+0x92>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3740:	ec 81       	ldd	r30, Y+4	; 0x04
    3742:	fd 81       	ldd	r31, Y+5	; 0x05
    3744:	81 89       	ldd	r24, Z+17	; 0x11
    3746:	88 23       	and	r24, r24
    3748:	e1 f0       	breq	.+56     	; 0x3782 <xQueueGenericSendFromISR+0xaa>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    374a:	8c 81       	ldd	r24, Y+4	; 0x04
    374c:	9d 81       	ldd	r25, Y+5	; 0x05
    374e:	41 96       	adiw	r24, 0x11	; 17
    3750:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    3754:	88 23       	and	r24, r24
    3756:	a9 f0       	breq	.+42     	; 0x3782 <xQueueGenericSendFromISR+0xaa>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3758:	8c 85       	ldd	r24, Y+12	; 0x0c
    375a:	9d 85       	ldd	r25, Y+13	; 0x0d
    375c:	00 97       	sbiw	r24, 0x00	; 0
    375e:	89 f0       	breq	.+34     	; 0x3782 <xQueueGenericSendFromISR+0xaa>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3760:	ec 85       	ldd	r30, Y+12	; 0x0c
    3762:	fd 85       	ldd	r31, Y+13	; 0x0d
    3764:	81 e0       	ldi	r24, 0x01	; 1
    3766:	80 83       	st	Z, r24
    3768:	0c c0       	rjmp	.+24     	; 0x3782 <xQueueGenericSendFromISR+0xaa>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    376a:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <uxTaskGetNumberOfTasks>
    376e:	89 83       	std	Y+1, r24	; 0x01
    3770:	9b 81       	ldd	r25, Y+3	; 0x03
    3772:	89 81       	ldd	r24, Y+1	; 0x01
    3774:	98 17       	cp	r25, r24
    3776:	28 f4       	brcc	.+10     	; 0x3782 <xQueueGenericSendFromISR+0xaa>
    3778:	8b 81       	ldd	r24, Y+3	; 0x03
    377a:	8f 5f       	subi	r24, 0xFF	; 255
    377c:	ec 81       	ldd	r30, Y+4	; 0x04
    377e:	fd 81       	ldd	r31, Y+5	; 0x05
    3780:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    3782:	81 e0       	ldi	r24, 0x01	; 1
    3784:	8f 83       	std	Y+7, r24	; 0x07
    3786:	01 c0       	rjmp	.+2      	; 0x378a <xQueueGenericSendFromISR+0xb2>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3788:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    378a:	8f 81       	ldd	r24, Y+7	; 0x07
}
    378c:	2e 96       	adiw	r28, 0x0e	; 14
    378e:	0f b6       	in	r0, 0x3f	; 63
    3790:	f8 94       	cli
    3792:	de bf       	out	0x3e, r29	; 62
    3794:	0f be       	out	0x3f, r0	; 63
    3796:	cd bf       	out	0x3d, r28	; 61
    3798:	cf 91       	pop	r28
    379a:	df 91       	pop	r29
    379c:	08 95       	ret

0000379e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    379e:	df 93       	push	r29
    37a0:	cf 93       	push	r28
    37a2:	cd b7       	in	r28, 0x3d	; 61
    37a4:	de b7       	in	r29, 0x3e	; 62
    37a6:	2b 97       	sbiw	r28, 0x0b	; 11
    37a8:	0f b6       	in	r0, 0x3f	; 63
    37aa:	f8 94       	cli
    37ac:	de bf       	out	0x3e, r29	; 62
    37ae:	0f be       	out	0x3f, r0	; 63
    37b0:	cd bf       	out	0x3d, r28	; 61
    37b2:	99 87       	std	Y+9, r25	; 0x09
    37b4:	88 87       	std	Y+8, r24	; 0x08
    37b6:	7b 87       	std	Y+11, r23	; 0x0b
    37b8:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    37ba:	88 85       	ldd	r24, Y+8	; 0x08
    37bc:	99 85       	ldd	r25, Y+9	; 0x09
    37be:	9d 83       	std	Y+5, r25	; 0x05
    37c0:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    37c2:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    37c4:	ec 81       	ldd	r30, Y+4	; 0x04
    37c6:	fd 81       	ldd	r31, Y+5	; 0x05
    37c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    37ca:	8b 83       	std	Y+3, r24	; 0x03

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    37cc:	ec 81       	ldd	r30, Y+4	; 0x04
    37ce:	fd 81       	ldd	r31, Y+5	; 0x05
    37d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    37d2:	8b 81       	ldd	r24, Y+3	; 0x03
    37d4:	89 17       	cp	r24, r25
    37d6:	80 f5       	brcc	.+96     	; 0x3838 <xQueueGiveFromISR+0x9a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    37d8:	ec 81       	ldd	r30, Y+4	; 0x04
    37da:	fd 81       	ldd	r31, Y+5	; 0x05
    37dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    37de:	8a 83       	std	Y+2, r24	; 0x02
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    37e0:	8b 81       	ldd	r24, Y+3	; 0x03
    37e2:	8f 5f       	subi	r24, 0xFF	; 255
    37e4:	ec 81       	ldd	r30, Y+4	; 0x04
    37e6:	fd 81       	ldd	r31, Y+5	; 0x05
    37e8:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    37ea:	8a 81       	ldd	r24, Y+2	; 0x02
    37ec:	8f 3f       	cpi	r24, 0xFF	; 255
    37ee:	a9 f4       	brne	.+42     	; 0x381a <xQueueGiveFromISR+0x7c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37f0:	ec 81       	ldd	r30, Y+4	; 0x04
    37f2:	fd 81       	ldd	r31, Y+5	; 0x05
    37f4:	81 89       	ldd	r24, Z+17	; 0x11
    37f6:	88 23       	and	r24, r24
    37f8:	e1 f0       	breq	.+56     	; 0x3832 <xQueueGiveFromISR+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    37fa:	8c 81       	ldd	r24, Y+4	; 0x04
    37fc:	9d 81       	ldd	r25, Y+5	; 0x05
    37fe:	41 96       	adiw	r24, 0x11	; 17
    3800:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    3804:	88 23       	and	r24, r24
    3806:	a9 f0       	breq	.+42     	; 0x3832 <xQueueGiveFromISR+0x94>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3808:	8a 85       	ldd	r24, Y+10	; 0x0a
    380a:	9b 85       	ldd	r25, Y+11	; 0x0b
    380c:	00 97       	sbiw	r24, 0x00	; 0
    380e:	89 f0       	breq	.+34     	; 0x3832 <xQueueGiveFromISR+0x94>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3810:	ea 85       	ldd	r30, Y+10	; 0x0a
    3812:	fb 85       	ldd	r31, Y+11	; 0x0b
    3814:	81 e0       	ldi	r24, 0x01	; 1
    3816:	80 83       	st	Z, r24
    3818:	0c c0       	rjmp	.+24     	; 0x3832 <xQueueGiveFromISR+0x94>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    381a:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <uxTaskGetNumberOfTasks>
    381e:	89 83       	std	Y+1, r24	; 0x01
    3820:	9a 81       	ldd	r25, Y+2	; 0x02
    3822:	89 81       	ldd	r24, Y+1	; 0x01
    3824:	98 17       	cp	r25, r24
    3826:	28 f4       	brcc	.+10     	; 0x3832 <xQueueGiveFromISR+0x94>
    3828:	8a 81       	ldd	r24, Y+2	; 0x02
    382a:	8f 5f       	subi	r24, 0xFF	; 255
    382c:	ec 81       	ldd	r30, Y+4	; 0x04
    382e:	fd 81       	ldd	r31, Y+5	; 0x05
    3830:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    3832:	81 e0       	ldi	r24, 0x01	; 1
    3834:	8f 83       	std	Y+7, r24	; 0x07
    3836:	01 c0       	rjmp	.+2      	; 0x383a <xQueueGiveFromISR+0x9c>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3838:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    383a:	8f 81       	ldd	r24, Y+7	; 0x07
}
    383c:	2b 96       	adiw	r28, 0x0b	; 11
    383e:	0f b6       	in	r0, 0x3f	; 63
    3840:	f8 94       	cli
    3842:	de bf       	out	0x3e, r29	; 62
    3844:	0f be       	out	0x3f, r0	; 63
    3846:	cd bf       	out	0x3d, r28	; 61
    3848:	cf 91       	pop	r28
    384a:	df 91       	pop	r29
    384c:	08 95       	ret

0000384e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    384e:	df 93       	push	r29
    3850:	cf 93       	push	r28
    3852:	cd b7       	in	r28, 0x3d	; 61
    3854:	de b7       	in	r29, 0x3e	; 62
    3856:	2e 97       	sbiw	r28, 0x0e	; 14
    3858:	0f b6       	in	r0, 0x3f	; 63
    385a:	f8 94       	cli
    385c:	de bf       	out	0x3e, r29	; 62
    385e:	0f be       	out	0x3f, r0	; 63
    3860:	cd bf       	out	0x3d, r28	; 61
    3862:	99 87       	std	Y+9, r25	; 0x09
    3864:	88 87       	std	Y+8, r24	; 0x08
    3866:	7b 87       	std	Y+11, r23	; 0x0b
    3868:	6a 87       	std	Y+10, r22	; 0x0a
    386a:	5d 87       	std	Y+13, r21	; 0x0d
    386c:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    386e:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3870:	88 85       	ldd	r24, Y+8	; 0x08
    3872:	99 85       	ldd	r25, Y+9	; 0x09
    3874:	9b 83       	std	Y+3, r25	; 0x03
    3876:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3878:	0f b6       	in	r0, 0x3f	; 63
    387a:	f8 94       	cli
    387c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    387e:	ea 81       	ldd	r30, Y+2	; 0x02
    3880:	fb 81       	ldd	r31, Y+3	; 0x03
    3882:	82 8d       	ldd	r24, Z+26	; 0x1a
    3884:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3886:	89 81       	ldd	r24, Y+1	; 0x01
    3888:	88 23       	and	r24, r24
    388a:	f9 f0       	breq	.+62     	; 0x38ca <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    388c:	8a 81       	ldd	r24, Y+2	; 0x02
    388e:	9b 81       	ldd	r25, Y+3	; 0x03
    3890:	2a 85       	ldd	r18, Y+10	; 0x0a
    3892:	3b 85       	ldd	r19, Y+11	; 0x0b
    3894:	b9 01       	movw	r22, r18
    3896:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    389a:	89 81       	ldd	r24, Y+1	; 0x01
    389c:	81 50       	subi	r24, 0x01	; 1
    389e:	ea 81       	ldd	r30, Y+2	; 0x02
    38a0:	fb 81       	ldd	r31, Y+3	; 0x03
    38a2:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    38a4:	ea 81       	ldd	r30, Y+2	; 0x02
    38a6:	fb 81       	ldd	r31, Y+3	; 0x03
    38a8:	80 85       	ldd	r24, Z+8	; 0x08
    38aa:	88 23       	and	r24, r24
    38ac:	49 f0       	breq	.+18     	; 0x38c0 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    38ae:	8a 81       	ldd	r24, Y+2	; 0x02
    38b0:	9b 81       	ldd	r25, Y+3	; 0x03
    38b2:	08 96       	adiw	r24, 0x08	; 8
    38b4:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    38b8:	88 23       	and	r24, r24
    38ba:	11 f0       	breq	.+4      	; 0x38c0 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    38bc:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    38c0:	0f 90       	pop	r0
    38c2:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    38c4:	81 e0       	ldi	r24, 0x01	; 1
    38c6:	8e 87       	std	Y+14, r24	; 0x0e
    38c8:	63 c0       	rjmp	.+198    	; 0x3990 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    38ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    38cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    38ce:	00 97       	sbiw	r24, 0x00	; 0
    38d0:	21 f4       	brne	.+8      	; 0x38da <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    38d2:	0f 90       	pop	r0
    38d4:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    38d6:	1e 86       	std	Y+14, r1	; 0x0e
    38d8:	5b c0       	rjmp	.+182    	; 0x3990 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    38da:	8c 81       	ldd	r24, Y+4	; 0x04
    38dc:	88 23       	and	r24, r24
    38de:	31 f4       	brne	.+12     	; 0x38ec <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    38e0:	ce 01       	movw	r24, r28
    38e2:	05 96       	adiw	r24, 0x05	; 5
    38e4:	0e 94 a5 34 	call	0x694a	; 0x694a <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    38e8:	81 e0       	ldi	r24, 0x01	; 1
    38ea:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    38ec:	0f 90       	pop	r0
    38ee:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    38f0:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    38f4:	0f b6       	in	r0, 0x3f	; 63
    38f6:	f8 94       	cli
    38f8:	0f 92       	push	r0
    38fa:	ea 81       	ldd	r30, Y+2	; 0x02
    38fc:	fb 81       	ldd	r31, Y+3	; 0x03
    38fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    3900:	8f 3f       	cpi	r24, 0xFF	; 255
    3902:	19 f4       	brne	.+6      	; 0x390a <xQueueReceive+0xbc>
    3904:	ea 81       	ldd	r30, Y+2	; 0x02
    3906:	fb 81       	ldd	r31, Y+3	; 0x03
    3908:	15 8e       	std	Z+29, r1	; 0x1d
    390a:	ea 81       	ldd	r30, Y+2	; 0x02
    390c:	fb 81       	ldd	r31, Y+3	; 0x03
    390e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3910:	8f 3f       	cpi	r24, 0xFF	; 255
    3912:	19 f4       	brne	.+6      	; 0x391a <xQueueReceive+0xcc>
    3914:	ea 81       	ldd	r30, Y+2	; 0x02
    3916:	fb 81       	ldd	r31, Y+3	; 0x03
    3918:	16 8e       	std	Z+30, r1	; 0x1e
    391a:	0f 90       	pop	r0
    391c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    391e:	ce 01       	movw	r24, r28
    3920:	05 96       	adiw	r24, 0x05	; 5
    3922:	9e 01       	movw	r18, r28
    3924:	24 5f       	subi	r18, 0xF4	; 244
    3926:	3f 4f       	sbci	r19, 0xFF	; 255
    3928:	b9 01       	movw	r22, r18
    392a:	0e 94 be 34 	call	0x697c	; 0x697c <xTaskCheckForTimeOut>
    392e:	88 23       	and	r24, r24
    3930:	09 f5       	brne	.+66     	; 0x3974 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3932:	8a 81       	ldd	r24, Y+2	; 0x02
    3934:	9b 81       	ldd	r25, Y+3	; 0x03
    3936:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <prvIsQueueEmpty>
    393a:	88 23       	and	r24, r24
    393c:	a1 f0       	breq	.+40     	; 0x3966 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    393e:	8a 81       	ldd	r24, Y+2	; 0x02
    3940:	9b 81       	ldd	r25, Y+3	; 0x03
    3942:	41 96       	adiw	r24, 0x11	; 17
    3944:	2c 85       	ldd	r18, Y+12	; 0x0c
    3946:	3d 85       	ldd	r19, Y+13	; 0x0d
    3948:	b9 01       	movw	r22, r18
    394a:	0e 94 ae 31 	call	0x635c	; 0x635c <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    394e:	8a 81       	ldd	r24, Y+2	; 0x02
    3950:	9b 81       	ldd	r25, Y+3	; 0x03
    3952:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3956:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    395a:	88 23       	and	r24, r24
    395c:	09 f0       	breq	.+2      	; 0x3960 <xQueueReceive+0x112>
    395e:	8c cf       	rjmp	.-232    	; 0x3878 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    3960:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    3964:	89 cf       	rjmp	.-238    	; 0x3878 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    3966:	8a 81       	ldd	r24, Y+2	; 0x02
    3968:	9b 81       	ldd	r25, Y+3	; 0x03
    396a:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    396e:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    3972:	82 cf       	rjmp	.-252    	; 0x3878 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    3974:	8a 81       	ldd	r24, Y+2	; 0x02
    3976:	9b 81       	ldd	r25, Y+3	; 0x03
    3978:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    397c:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3980:	8a 81       	ldd	r24, Y+2	; 0x02
    3982:	9b 81       	ldd	r25, Y+3	; 0x03
    3984:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <prvIsQueueEmpty>
    3988:	88 23       	and	r24, r24
    398a:	09 f4       	brne	.+2      	; 0x398e <xQueueReceive+0x140>
    398c:	75 cf       	rjmp	.-278    	; 0x3878 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    398e:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3990:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    3992:	2e 96       	adiw	r28, 0x0e	; 14
    3994:	0f b6       	in	r0, 0x3f	; 63
    3996:	f8 94       	cli
    3998:	de bf       	out	0x3e, r29	; 62
    399a:	0f be       	out	0x3f, r0	; 63
    399c:	cd bf       	out	0x3d, r28	; 61
    399e:	cf 91       	pop	r28
    39a0:	df 91       	pop	r29
    39a2:	08 95       	ret

000039a4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    39a4:	df 93       	push	r29
    39a6:	cf 93       	push	r28
    39a8:	cd b7       	in	r28, 0x3d	; 61
    39aa:	de b7       	in	r29, 0x3e	; 62
    39ac:	2c 97       	sbiw	r28, 0x0c	; 12
    39ae:	0f b6       	in	r0, 0x3f	; 63
    39b0:	f8 94       	cli
    39b2:	de bf       	out	0x3e, r29	; 62
    39b4:	0f be       	out	0x3f, r0	; 63
    39b6:	cd bf       	out	0x3d, r28	; 61
    39b8:	99 87       	std	Y+9, r25	; 0x09
    39ba:	88 87       	std	Y+8, r24	; 0x08
    39bc:	7b 87       	std	Y+11, r23	; 0x0b
    39be:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    39c0:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    39c2:	88 85       	ldd	r24, Y+8	; 0x08
    39c4:	99 85       	ldd	r25, Y+9	; 0x09
    39c6:	9b 83       	std	Y+3, r25	; 0x03
    39c8:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    39ca:	0f b6       	in	r0, 0x3f	; 63
    39cc:	f8 94       	cli
    39ce:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    39d0:	ea 81       	ldd	r30, Y+2	; 0x02
    39d2:	fb 81       	ldd	r31, Y+3	; 0x03
    39d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    39d6:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    39d8:	89 81       	ldd	r24, Y+1	; 0x01
    39da:	88 23       	and	r24, r24
    39dc:	c1 f0       	breq	.+48     	; 0x3a0e <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    39de:	89 81       	ldd	r24, Y+1	; 0x01
    39e0:	81 50       	subi	r24, 0x01	; 1
    39e2:	ea 81       	ldd	r30, Y+2	; 0x02
    39e4:	fb 81       	ldd	r31, Y+3	; 0x03
    39e6:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39e8:	ea 81       	ldd	r30, Y+2	; 0x02
    39ea:	fb 81       	ldd	r31, Y+3	; 0x03
    39ec:	80 85       	ldd	r24, Z+8	; 0x08
    39ee:	88 23       	and	r24, r24
    39f0:	49 f0       	breq	.+18     	; 0x3a04 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    39f2:	8a 81       	ldd	r24, Y+2	; 0x02
    39f4:	9b 81       	ldd	r25, Y+3	; 0x03
    39f6:	08 96       	adiw	r24, 0x08	; 8
    39f8:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    39fc:	88 23       	and	r24, r24
    39fe:	11 f0       	breq	.+4      	; 0x3a04 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3a00:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3a04:	0f 90       	pop	r0
    3a06:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3a08:	81 e0       	ldi	r24, 0x01	; 1
    3a0a:	8c 87       	std	Y+12, r24	; 0x0c
    3a0c:	63 c0       	rjmp	.+198    	; 0x3ad4 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3a0e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a10:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a12:	00 97       	sbiw	r24, 0x00	; 0
    3a14:	21 f4       	brne	.+8      	; 0x3a1e <xQueueSemaphoreTake+0x7a>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    3a16:	0f 90       	pop	r0
    3a18:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3a1a:	1c 86       	std	Y+12, r1	; 0x0c
    3a1c:	5b c0       	rjmp	.+182    	; 0x3ad4 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    3a1e:	8c 81       	ldd	r24, Y+4	; 0x04
    3a20:	88 23       	and	r24, r24
    3a22:	31 f4       	brne	.+12     	; 0x3a30 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3a24:	ce 01       	movw	r24, r28
    3a26:	05 96       	adiw	r24, 0x05	; 5
    3a28:	0e 94 a5 34 	call	0x694a	; 0x694a <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3a2c:	81 e0       	ldi	r24, 0x01	; 1
    3a2e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3a30:	0f 90       	pop	r0
    3a32:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3a34:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3a38:	0f b6       	in	r0, 0x3f	; 63
    3a3a:	f8 94       	cli
    3a3c:	0f 92       	push	r0
    3a3e:	ea 81       	ldd	r30, Y+2	; 0x02
    3a40:	fb 81       	ldd	r31, Y+3	; 0x03
    3a42:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a44:	8f 3f       	cpi	r24, 0xFF	; 255
    3a46:	19 f4       	brne	.+6      	; 0x3a4e <xQueueSemaphoreTake+0xaa>
    3a48:	ea 81       	ldd	r30, Y+2	; 0x02
    3a4a:	fb 81       	ldd	r31, Y+3	; 0x03
    3a4c:	15 8e       	std	Z+29, r1	; 0x1d
    3a4e:	ea 81       	ldd	r30, Y+2	; 0x02
    3a50:	fb 81       	ldd	r31, Y+3	; 0x03
    3a52:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a54:	8f 3f       	cpi	r24, 0xFF	; 255
    3a56:	19 f4       	brne	.+6      	; 0x3a5e <xQueueSemaphoreTake+0xba>
    3a58:	ea 81       	ldd	r30, Y+2	; 0x02
    3a5a:	fb 81       	ldd	r31, Y+3	; 0x03
    3a5c:	16 8e       	std	Z+30, r1	; 0x1e
    3a5e:	0f 90       	pop	r0
    3a60:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a62:	ce 01       	movw	r24, r28
    3a64:	05 96       	adiw	r24, 0x05	; 5
    3a66:	9e 01       	movw	r18, r28
    3a68:	26 5f       	subi	r18, 0xF6	; 246
    3a6a:	3f 4f       	sbci	r19, 0xFF	; 255
    3a6c:	b9 01       	movw	r22, r18
    3a6e:	0e 94 be 34 	call	0x697c	; 0x697c <xTaskCheckForTimeOut>
    3a72:	88 23       	and	r24, r24
    3a74:	09 f5       	brne	.+66     	; 0x3ab8 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a76:	8a 81       	ldd	r24, Y+2	; 0x02
    3a78:	9b 81       	ldd	r25, Y+3	; 0x03
    3a7a:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <prvIsQueueEmpty>
    3a7e:	88 23       	and	r24, r24
    3a80:	a1 f0       	breq	.+40     	; 0x3aaa <xQueueSemaphoreTake+0x106>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3a82:	8a 81       	ldd	r24, Y+2	; 0x02
    3a84:	9b 81       	ldd	r25, Y+3	; 0x03
    3a86:	41 96       	adiw	r24, 0x11	; 17
    3a88:	2a 85       	ldd	r18, Y+10	; 0x0a
    3a8a:	3b 85       	ldd	r19, Y+11	; 0x0b
    3a8c:	b9 01       	movw	r22, r18
    3a8e:	0e 94 ae 31 	call	0x635c	; 0x635c <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3a92:	8a 81       	ldd	r24, Y+2	; 0x02
    3a94:	9b 81       	ldd	r25, Y+3	; 0x03
    3a96:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3a9a:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    3a9e:	88 23       	and	r24, r24
    3aa0:	09 f0       	breq	.+2      	; 0x3aa4 <xQueueSemaphoreTake+0x100>
    3aa2:	93 cf       	rjmp	.-218    	; 0x39ca <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    3aa4:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    3aa8:	90 cf       	rjmp	.-224    	; 0x39ca <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    3aaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3aac:	9b 81       	ldd	r25, Y+3	; 0x03
    3aae:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3ab2:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    3ab6:	89 cf       	rjmp	.-238    	; 0x39ca <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    3ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    3aba:	9b 81       	ldd	r25, Y+3	; 0x03
    3abc:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3ac0:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3ac4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ac6:	9b 81       	ldd	r25, Y+3	; 0x03
    3ac8:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <prvIsQueueEmpty>
    3acc:	88 23       	and	r24, r24
    3ace:	09 f4       	brne	.+2      	; 0x3ad2 <xQueueSemaphoreTake+0x12e>
    3ad0:	7c cf       	rjmp	.-264    	; 0x39ca <xQueueSemaphoreTake+0x26>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3ad2:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3ad4:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    3ad6:	2c 96       	adiw	r28, 0x0c	; 12
    3ad8:	0f b6       	in	r0, 0x3f	; 63
    3ada:	f8 94       	cli
    3adc:	de bf       	out	0x3e, r29	; 62
    3ade:	0f be       	out	0x3f, r0	; 63
    3ae0:	cd bf       	out	0x3d, r28	; 61
    3ae2:	cf 91       	pop	r28
    3ae4:	df 91       	pop	r29
    3ae6:	08 95       	ret

00003ae8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    3ae8:	df 93       	push	r29
    3aea:	cf 93       	push	r28
    3aec:	cd b7       	in	r28, 0x3d	; 61
    3aee:	de b7       	in	r29, 0x3e	; 62
    3af0:	60 97       	sbiw	r28, 0x10	; 16
    3af2:	0f b6       	in	r0, 0x3f	; 63
    3af4:	f8 94       	cli
    3af6:	de bf       	out	0x3e, r29	; 62
    3af8:	0f be       	out	0x3f, r0	; 63
    3afa:	cd bf       	out	0x3d, r28	; 61
    3afc:	9b 87       	std	Y+11, r25	; 0x0b
    3afe:	8a 87       	std	Y+10, r24	; 0x0a
    3b00:	7d 87       	std	Y+13, r23	; 0x0d
    3b02:	6c 87       	std	Y+12, r22	; 0x0c
    3b04:	5f 87       	std	Y+15, r21	; 0x0f
    3b06:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    3b08:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3b0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b0e:	9b 83       	std	Y+3, r25	; 0x03
    3b10:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3b12:	0f b6       	in	r0, 0x3f	; 63
    3b14:	f8 94       	cli
    3b16:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3b18:	ea 81       	ldd	r30, Y+2	; 0x02
    3b1a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b1e:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b20:	89 81       	ldd	r24, Y+1	; 0x01
    3b22:	88 23       	and	r24, r24
    3b24:	31 f1       	breq	.+76     	; 0x3b72 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3b26:	ea 81       	ldd	r30, Y+2	; 0x02
    3b28:	fb 81       	ldd	r31, Y+3	; 0x03
    3b2a:	86 81       	ldd	r24, Z+6	; 0x06
    3b2c:	97 81       	ldd	r25, Z+7	; 0x07
    3b2e:	9d 83       	std	Y+5, r25	; 0x05
    3b30:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b32:	8a 81       	ldd	r24, Y+2	; 0x02
    3b34:	9b 81       	ldd	r25, Y+3	; 0x03
    3b36:	2c 85       	ldd	r18, Y+12	; 0x0c
    3b38:	3d 85       	ldd	r19, Y+13	; 0x0d
    3b3a:	b9 01       	movw	r22, r18
    3b3c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3b40:	ea 81       	ldd	r30, Y+2	; 0x02
    3b42:	fb 81       	ldd	r31, Y+3	; 0x03
    3b44:	8c 81       	ldd	r24, Y+4	; 0x04
    3b46:	9d 81       	ldd	r25, Y+5	; 0x05
    3b48:	97 83       	std	Z+7, r25	; 0x07
    3b4a:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b50:	81 89       	ldd	r24, Z+17	; 0x11
    3b52:	88 23       	and	r24, r24
    3b54:	49 f0       	breq	.+18     	; 0x3b68 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3b56:	8a 81       	ldd	r24, Y+2	; 0x02
    3b58:	9b 81       	ldd	r25, Y+3	; 0x03
    3b5a:	41 96       	adiw	r24, 0x11	; 17
    3b5c:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    3b60:	88 23       	and	r24, r24
    3b62:	11 f0       	breq	.+4      	; 0x3b68 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    3b64:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3b68:	0f 90       	pop	r0
    3b6a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3b6c:	81 e0       	ldi	r24, 0x01	; 1
    3b6e:	88 8b       	std	Y+16, r24	; 0x10
    3b70:	63 c0       	rjmp	.+198    	; 0x3c38 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3b72:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b74:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b76:	00 97       	sbiw	r24, 0x00	; 0
    3b78:	21 f4       	brne	.+8      	; 0x3b82 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3b7a:	0f 90       	pop	r0
    3b7c:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3b7e:	18 8a       	std	Y+16, r1	; 0x10
    3b80:	5b c0       	rjmp	.+182    	; 0x3c38 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    3b82:	8e 81       	ldd	r24, Y+6	; 0x06
    3b84:	88 23       	and	r24, r24
    3b86:	31 f4       	brne	.+12     	; 0x3b94 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3b88:	ce 01       	movw	r24, r28
    3b8a:	07 96       	adiw	r24, 0x07	; 7
    3b8c:	0e 94 a5 34 	call	0x694a	; 0x694a <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3b90:	81 e0       	ldi	r24, 0x01	; 1
    3b92:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3b94:	0f 90       	pop	r0
    3b96:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    3b98:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3b9c:	0f b6       	in	r0, 0x3f	; 63
    3b9e:	f8 94       	cli
    3ba0:	0f 92       	push	r0
    3ba2:	ea 81       	ldd	r30, Y+2	; 0x02
    3ba4:	fb 81       	ldd	r31, Y+3	; 0x03
    3ba6:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ba8:	8f 3f       	cpi	r24, 0xFF	; 255
    3baa:	19 f4       	brne	.+6      	; 0x3bb2 <xQueuePeek+0xca>
    3bac:	ea 81       	ldd	r30, Y+2	; 0x02
    3bae:	fb 81       	ldd	r31, Y+3	; 0x03
    3bb0:	15 8e       	std	Z+29, r1	; 0x1d
    3bb2:	ea 81       	ldd	r30, Y+2	; 0x02
    3bb4:	fb 81       	ldd	r31, Y+3	; 0x03
    3bb6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bb8:	8f 3f       	cpi	r24, 0xFF	; 255
    3bba:	19 f4       	brne	.+6      	; 0x3bc2 <xQueuePeek+0xda>
    3bbc:	ea 81       	ldd	r30, Y+2	; 0x02
    3bbe:	fb 81       	ldd	r31, Y+3	; 0x03
    3bc0:	16 8e       	std	Z+30, r1	; 0x1e
    3bc2:	0f 90       	pop	r0
    3bc4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3bc6:	ce 01       	movw	r24, r28
    3bc8:	07 96       	adiw	r24, 0x07	; 7
    3bca:	9e 01       	movw	r18, r28
    3bcc:	22 5f       	subi	r18, 0xF2	; 242
    3bce:	3f 4f       	sbci	r19, 0xFF	; 255
    3bd0:	b9 01       	movw	r22, r18
    3bd2:	0e 94 be 34 	call	0x697c	; 0x697c <xTaskCheckForTimeOut>
    3bd6:	88 23       	and	r24, r24
    3bd8:	09 f5       	brne	.+66     	; 0x3c1c <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3bda:	8a 81       	ldd	r24, Y+2	; 0x02
    3bdc:	9b 81       	ldd	r25, Y+3	; 0x03
    3bde:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <prvIsQueueEmpty>
    3be2:	88 23       	and	r24, r24
    3be4:	a1 f0       	breq	.+40     	; 0x3c0e <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3be6:	8a 81       	ldd	r24, Y+2	; 0x02
    3be8:	9b 81       	ldd	r25, Y+3	; 0x03
    3bea:	41 96       	adiw	r24, 0x11	; 17
    3bec:	2e 85       	ldd	r18, Y+14	; 0x0e
    3bee:	3f 85       	ldd	r19, Y+15	; 0x0f
    3bf0:	b9 01       	movw	r22, r18
    3bf2:	0e 94 ae 31 	call	0x635c	; 0x635c <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3bf6:	8a 81       	ldd	r24, Y+2	; 0x02
    3bf8:	9b 81       	ldd	r25, Y+3	; 0x03
    3bfa:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3bfe:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    3c02:	88 23       	and	r24, r24
    3c04:	09 f0       	breq	.+2      	; 0x3c08 <xQueuePeek+0x120>
    3c06:	85 cf       	rjmp	.-246    	; 0x3b12 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    3c08:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    3c0c:	82 cf       	rjmp	.-252    	; 0x3b12 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    3c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c10:	9b 81       	ldd	r25, Y+3	; 0x03
    3c12:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3c16:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    3c1a:	7b cf       	rjmp	.-266    	; 0x3b12 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    3c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c20:	0e 94 18 20 	call	0x4030	; 0x4030 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3c24:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3c28:	8a 81       	ldd	r24, Y+2	; 0x02
    3c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c2c:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <prvIsQueueEmpty>
    3c30:	88 23       	and	r24, r24
    3c32:	09 f4       	brne	.+2      	; 0x3c36 <xQueuePeek+0x14e>
    3c34:	6e cf       	rjmp	.-292    	; 0x3b12 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3c36:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3c38:	88 89       	ldd	r24, Y+16	; 0x10
}
    3c3a:	60 96       	adiw	r28, 0x10	; 16
    3c3c:	0f b6       	in	r0, 0x3f	; 63
    3c3e:	f8 94       	cli
    3c40:	de bf       	out	0x3e, r29	; 62
    3c42:	0f be       	out	0x3f, r0	; 63
    3c44:	cd bf       	out	0x3d, r28	; 61
    3c46:	cf 91       	pop	r28
    3c48:	df 91       	pop	r29
    3c4a:	08 95       	ret

00003c4c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3c4c:	df 93       	push	r29
    3c4e:	cf 93       	push	r28
    3c50:	cd b7       	in	r28, 0x3d	; 61
    3c52:	de b7       	in	r29, 0x3e	; 62
    3c54:	2d 97       	sbiw	r28, 0x0d	; 13
    3c56:	0f b6       	in	r0, 0x3f	; 63
    3c58:	f8 94       	cli
    3c5a:	de bf       	out	0x3e, r29	; 62
    3c5c:	0f be       	out	0x3f, r0	; 63
    3c5e:	cd bf       	out	0x3d, r28	; 61
    3c60:	99 87       	std	Y+9, r25	; 0x09
    3c62:	88 87       	std	Y+8, r24	; 0x08
    3c64:	7b 87       	std	Y+11, r23	; 0x0b
    3c66:	6a 87       	std	Y+10, r22	; 0x0a
    3c68:	5d 87       	std	Y+13, r21	; 0x0d
    3c6a:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3c6c:	88 85       	ldd	r24, Y+8	; 0x08
    3c6e:	99 85       	ldd	r25, Y+9	; 0x09
    3c70:	9d 83       	std	Y+5, r25	; 0x05
    3c72:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c74:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3c76:	ec 81       	ldd	r30, Y+4	; 0x04
    3c78:	fd 81       	ldd	r31, Y+5	; 0x05
    3c7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c7c:	8b 83       	std	Y+3, r24	; 0x03

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c80:	88 23       	and	r24, r24
    3c82:	b9 f1       	breq	.+110    	; 0x3cf2 <xQueueReceiveFromISR+0xa6>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3c84:	ec 81       	ldd	r30, Y+4	; 0x04
    3c86:	fd 81       	ldd	r31, Y+5	; 0x05
    3c88:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c8a:	8a 83       	std	Y+2, r24	; 0x02

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3c8c:	8c 81       	ldd	r24, Y+4	; 0x04
    3c8e:	9d 81       	ldd	r25, Y+5	; 0x05
    3c90:	2a 85       	ldd	r18, Y+10	; 0x0a
    3c92:	3b 85       	ldd	r19, Y+11	; 0x0b
    3c94:	b9 01       	movw	r22, r18
    3c96:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9c:	81 50       	subi	r24, 0x01	; 1
    3c9e:	ec 81       	ldd	r30, Y+4	; 0x04
    3ca0:	fd 81       	ldd	r31, Y+5	; 0x05
    3ca2:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ca6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ca8:	a9 f4       	brne	.+42     	; 0x3cd4 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3caa:	ec 81       	ldd	r30, Y+4	; 0x04
    3cac:	fd 81       	ldd	r31, Y+5	; 0x05
    3cae:	80 85       	ldd	r24, Z+8	; 0x08
    3cb0:	88 23       	and	r24, r24
    3cb2:	e1 f0       	breq	.+56     	; 0x3cec <xQueueReceiveFromISR+0xa0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3cb4:	8c 81       	ldd	r24, Y+4	; 0x04
    3cb6:	9d 81       	ldd	r25, Y+5	; 0x05
    3cb8:	08 96       	adiw	r24, 0x08	; 8
    3cba:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    3cbe:	88 23       	and	r24, r24
    3cc0:	a9 f0       	breq	.+42     	; 0x3cec <xQueueReceiveFromISR+0xa0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    3cc2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3cc4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3cc6:	00 97       	sbiw	r24, 0x00	; 0
    3cc8:	89 f0       	breq	.+34     	; 0x3cec <xQueueReceiveFromISR+0xa0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    3cca:	ec 85       	ldd	r30, Y+12	; 0x0c
    3ccc:	fd 85       	ldd	r31, Y+13	; 0x0d
    3cce:	81 e0       	ldi	r24, 0x01	; 1
    3cd0:	80 83       	st	Z, r24
    3cd2:	0c c0       	rjmp	.+24     	; 0x3cec <xQueueReceiveFromISR+0xa0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    3cd4:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <uxTaskGetNumberOfTasks>
    3cd8:	89 83       	std	Y+1, r24	; 0x01
    3cda:	9a 81       	ldd	r25, Y+2	; 0x02
    3cdc:	89 81       	ldd	r24, Y+1	; 0x01
    3cde:	98 17       	cp	r25, r24
    3ce0:	28 f4       	brcc	.+10     	; 0x3cec <xQueueReceiveFromISR+0xa0>
    3ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce4:	8f 5f       	subi	r24, 0xFF	; 255
    3ce6:	ec 81       	ldd	r30, Y+4	; 0x04
    3ce8:	fd 81       	ldd	r31, Y+5	; 0x05
    3cea:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    3cec:	81 e0       	ldi	r24, 0x01	; 1
    3cee:	8f 83       	std	Y+7, r24	; 0x07
    3cf0:	01 c0       	rjmp	.+2      	; 0x3cf4 <xQueueReceiveFromISR+0xa8>
        }
        else
        {
            xReturn = pdFAIL;
    3cf2:	1f 82       	std	Y+7, r1	; 0x07
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3cf4:	8f 81       	ldd	r24, Y+7	; 0x07
}
    3cf6:	2d 96       	adiw	r28, 0x0d	; 13
    3cf8:	0f b6       	in	r0, 0x3f	; 63
    3cfa:	f8 94       	cli
    3cfc:	de bf       	out	0x3e, r29	; 62
    3cfe:	0f be       	out	0x3f, r0	; 63
    3d00:	cd bf       	out	0x3d, r28	; 61
    3d02:	cf 91       	pop	r28
    3d04:	df 91       	pop	r29
    3d06:	08 95       	ret

00003d08 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    3d08:	df 93       	push	r29
    3d0a:	cf 93       	push	r28
    3d0c:	cd b7       	in	r28, 0x3d	; 61
    3d0e:	de b7       	in	r29, 0x3e	; 62
    3d10:	2a 97       	sbiw	r28, 0x0a	; 10
    3d12:	0f b6       	in	r0, 0x3f	; 63
    3d14:	f8 94       	cli
    3d16:	de bf       	out	0x3e, r29	; 62
    3d18:	0f be       	out	0x3f, r0	; 63
    3d1a:	cd bf       	out	0x3d, r28	; 61
    3d1c:	98 87       	std	Y+8, r25	; 0x08
    3d1e:	8f 83       	std	Y+7, r24	; 0x07
    3d20:	7a 87       	std	Y+10, r23	; 0x0a
    3d22:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3d24:	8f 81       	ldd	r24, Y+7	; 0x07
    3d26:	98 85       	ldd	r25, Y+8	; 0x08
    3d28:	9a 83       	std	Y+2, r25	; 0x02
    3d2a:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d2c:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3d2e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d30:	fa 81       	ldd	r31, Y+2	; 0x02
    3d32:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d34:	88 23       	and	r24, r24
    3d36:	b1 f0       	breq	.+44     	; 0x3d64 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3d38:	e9 81       	ldd	r30, Y+1	; 0x01
    3d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d3c:	86 81       	ldd	r24, Z+6	; 0x06
    3d3e:	97 81       	ldd	r25, Z+7	; 0x07
    3d40:	9c 83       	std	Y+4, r25	; 0x04
    3d42:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3d44:	89 81       	ldd	r24, Y+1	; 0x01
    3d46:	9a 81       	ldd	r25, Y+2	; 0x02
    3d48:	29 85       	ldd	r18, Y+9	; 0x09
    3d4a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d4c:	b9 01       	movw	r22, r18
    3d4e:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3d52:	e9 81       	ldd	r30, Y+1	; 0x01
    3d54:	fa 81       	ldd	r31, Y+2	; 0x02
    3d56:	8b 81       	ldd	r24, Y+3	; 0x03
    3d58:	9c 81       	ldd	r25, Y+4	; 0x04
    3d5a:	97 83       	std	Z+7, r25	; 0x07
    3d5c:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    3d5e:	81 e0       	ldi	r24, 0x01	; 1
    3d60:	8e 83       	std	Y+6, r24	; 0x06
    3d62:	01 c0       	rjmp	.+2      	; 0x3d66 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    3d64:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3d66:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3d68:	2a 96       	adiw	r28, 0x0a	; 10
    3d6a:	0f b6       	in	r0, 0x3f	; 63
    3d6c:	f8 94       	cli
    3d6e:	de bf       	out	0x3e, r29	; 62
    3d70:	0f be       	out	0x3f, r0	; 63
    3d72:	cd bf       	out	0x3d, r28	; 61
    3d74:	cf 91       	pop	r28
    3d76:	df 91       	pop	r29
    3d78:	08 95       	ret

00003d7a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3d7a:	df 93       	push	r29
    3d7c:	cf 93       	push	r28
    3d7e:	00 d0       	rcall	.+0      	; 0x3d80 <uxQueueMessagesWaiting+0x6>
    3d80:	0f 92       	push	r0
    3d82:	cd b7       	in	r28, 0x3d	; 61
    3d84:	de b7       	in	r29, 0x3e	; 62
    3d86:	9b 83       	std	Y+3, r25	; 0x03
    3d88:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    3d8a:	0f b6       	in	r0, 0x3f	; 63
    3d8c:	f8 94       	cli
    3d8e:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3d90:	ea 81       	ldd	r30, Y+2	; 0x02
    3d92:	fb 81       	ldd	r31, Y+3	; 0x03
    3d94:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d96:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3d98:	0f 90       	pop	r0
    3d9a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3d9c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3d9e:	0f 90       	pop	r0
    3da0:	0f 90       	pop	r0
    3da2:	0f 90       	pop	r0
    3da4:	cf 91       	pop	r28
    3da6:	df 91       	pop	r29
    3da8:	08 95       	ret

00003daa <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3daa:	df 93       	push	r29
    3dac:	cf 93       	push	r28
    3dae:	00 d0       	rcall	.+0      	; 0x3db0 <uxQueueSpacesAvailable+0x6>
    3db0:	00 d0       	rcall	.+0      	; 0x3db2 <uxQueueSpacesAvailable+0x8>
    3db2:	0f 92       	push	r0
    3db4:	cd b7       	in	r28, 0x3d	; 61
    3db6:	de b7       	in	r29, 0x3e	; 62
    3db8:	9d 83       	std	Y+5, r25	; 0x05
    3dba:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3dbc:	8c 81       	ldd	r24, Y+4	; 0x04
    3dbe:	9d 81       	ldd	r25, Y+5	; 0x05
    3dc0:	9a 83       	std	Y+2, r25	; 0x02
    3dc2:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3dc4:	0f b6       	in	r0, 0x3f	; 63
    3dc6:	f8 94       	cli
    3dc8:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3dca:	e9 81       	ldd	r30, Y+1	; 0x01
    3dcc:	fa 81       	ldd	r31, Y+2	; 0x02
    3dce:	93 8d       	ldd	r25, Z+27	; 0x1b
    3dd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3dd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3dd4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3dd6:	29 2f       	mov	r18, r25
    3dd8:	28 1b       	sub	r18, r24
    3dda:	82 2f       	mov	r24, r18
    3ddc:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    3dde:	0f 90       	pop	r0
    3de0:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3de2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3de4:	0f 90       	pop	r0
    3de6:	0f 90       	pop	r0
    3de8:	0f 90       	pop	r0
    3dea:	0f 90       	pop	r0
    3dec:	0f 90       	pop	r0
    3dee:	cf 91       	pop	r28
    3df0:	df 91       	pop	r29
    3df2:	08 95       	ret

00003df4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3df4:	df 93       	push	r29
    3df6:	cf 93       	push	r28
    3df8:	00 d0       	rcall	.+0      	; 0x3dfa <uxQueueMessagesWaitingFromISR+0x6>
    3dfa:	00 d0       	rcall	.+0      	; 0x3dfc <uxQueueMessagesWaitingFromISR+0x8>
    3dfc:	0f 92       	push	r0
    3dfe:	cd b7       	in	r28, 0x3d	; 61
    3e00:	de b7       	in	r29, 0x3e	; 62
    3e02:	9d 83       	std	Y+5, r25	; 0x05
    3e04:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3e06:	8c 81       	ldd	r24, Y+4	; 0x04
    3e08:	9d 81       	ldd	r25, Y+5	; 0x05
    3e0a:	9a 83       	std	Y+2, r25	; 0x02
    3e0c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    3e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e10:	fa 81       	ldd	r31, Y+2	; 0x02
    3e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e14:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    3e16:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3e18:	0f 90       	pop	r0
    3e1a:	0f 90       	pop	r0
    3e1c:	0f 90       	pop	r0
    3e1e:	0f 90       	pop	r0
    3e20:	0f 90       	pop	r0
    3e22:	cf 91       	pop	r28
    3e24:	df 91       	pop	r29
    3e26:	08 95       	ret

00003e28 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3e28:	df 93       	push	r29
    3e2a:	cf 93       	push	r28
    3e2c:	00 d0       	rcall	.+0      	; 0x3e2e <vQueueDelete+0x6>
    3e2e:	00 d0       	rcall	.+0      	; 0x3e30 <vQueueDelete+0x8>
    3e30:	cd b7       	in	r28, 0x3d	; 61
    3e32:	de b7       	in	r29, 0x3e	; 62
    3e34:	9c 83       	std	Y+4, r25	; 0x04
    3e36:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3e38:	8b 81       	ldd	r24, Y+3	; 0x03
    3e3a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e3c:	9a 83       	std	Y+2, r25	; 0x02
    3e3e:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    3e40:	89 81       	ldd	r24, Y+1	; 0x01
    3e42:	9a 81       	ldd	r25, Y+2	; 0x02
    3e44:	0e 94 a3 13 	call	0x2746	; 0x2746 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3e48:	0f 90       	pop	r0
    3e4a:	0f 90       	pop	r0
    3e4c:	0f 90       	pop	r0
    3e4e:	0f 90       	pop	r0
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	08 95       	ret

00003e56 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    3e56:	df 93       	push	r29
    3e58:	cf 93       	push	r28
    3e5a:	cd b7       	in	r28, 0x3d	; 61
    3e5c:	de b7       	in	r29, 0x3e	; 62
    3e5e:	27 97       	sbiw	r28, 0x07	; 7
    3e60:	0f b6       	in	r0, 0x3f	; 63
    3e62:	f8 94       	cli
    3e64:	de bf       	out	0x3e, r29	; 62
    3e66:	0f be       	out	0x3f, r0	; 63
    3e68:	cd bf       	out	0x3d, r28	; 61
    3e6a:	9c 83       	std	Y+4, r25	; 0x04
    3e6c:	8b 83       	std	Y+3, r24	; 0x03
    3e6e:	7e 83       	std	Y+6, r23	; 0x06
    3e70:	6d 83       	std	Y+5, r22	; 0x05
    3e72:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    3e74:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3e76:	eb 81       	ldd	r30, Y+3	; 0x03
    3e78:	fc 81       	ldd	r31, Y+4	; 0x04
    3e7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e7c:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3e7e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e80:	fc 81       	ldd	r31, Y+4	; 0x04
    3e82:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e84:	88 23       	and	r24, r24
    3e86:	09 f4       	brne	.+2      	; 0x3e8a <prvCopyDataToQueue+0x34>
    3e88:	7d c0       	rjmp	.+250    	; 0x3f84 <prvCopyDataToQueue+0x12e>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3e8a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e8c:	88 23       	and	r24, r24
    3e8e:	99 f5       	brne	.+102    	; 0x3ef6 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e90:	eb 81       	ldd	r30, Y+3	; 0x03
    3e92:	fc 81       	ldd	r31, Y+4	; 0x04
    3e94:	62 81       	ldd	r22, Z+2	; 0x02
    3e96:	73 81       	ldd	r23, Z+3	; 0x03
    3e98:	eb 81       	ldd	r30, Y+3	; 0x03
    3e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e9e:	48 2f       	mov	r20, r24
    3ea0:	50 e0       	ldi	r21, 0x00	; 0
    3ea2:	2d 81       	ldd	r18, Y+5	; 0x05
    3ea4:	3e 81       	ldd	r19, Y+6	; 0x06
    3ea6:	cb 01       	movw	r24, r22
    3ea8:	b9 01       	movw	r22, r18
    3eaa:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3eae:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    3eb2:	22 81       	ldd	r18, Z+2	; 0x02
    3eb4:	33 81       	ldd	r19, Z+3	; 0x03
    3eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eba:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ebc:	88 2f       	mov	r24, r24
    3ebe:	90 e0       	ldi	r25, 0x00	; 0
    3ec0:	82 0f       	add	r24, r18
    3ec2:	93 1f       	adc	r25, r19
    3ec4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec8:	93 83       	std	Z+3, r25	; 0x03
    3eca:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3ecc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ece:	fc 81       	ldd	r31, Y+4	; 0x04
    3ed0:	22 81       	ldd	r18, Z+2	; 0x02
    3ed2:	33 81       	ldd	r19, Z+3	; 0x03
    3ed4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ed6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ed8:	84 81       	ldd	r24, Z+4	; 0x04
    3eda:	95 81       	ldd	r25, Z+5	; 0x05
    3edc:	28 17       	cp	r18, r24
    3ede:	39 07       	cpc	r19, r25
    3ee0:	08 f4       	brcc	.+2      	; 0x3ee4 <prvCopyDataToQueue+0x8e>
    3ee2:	50 c0       	rjmp	.+160    	; 0x3f84 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee8:	80 81       	ld	r24, Z
    3eea:	91 81       	ldd	r25, Z+1	; 0x01
    3eec:	eb 81       	ldd	r30, Y+3	; 0x03
    3eee:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef0:	93 83       	std	Z+3, r25	; 0x03
    3ef2:	82 83       	std	Z+2, r24	; 0x02
    3ef4:	47 c0       	rjmp	.+142    	; 0x3f84 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3ef6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef8:	fc 81       	ldd	r31, Y+4	; 0x04
    3efa:	66 81       	ldd	r22, Z+6	; 0x06
    3efc:	77 81       	ldd	r23, Z+7	; 0x07
    3efe:	eb 81       	ldd	r30, Y+3	; 0x03
    3f00:	fc 81       	ldd	r31, Y+4	; 0x04
    3f02:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f04:	48 2f       	mov	r20, r24
    3f06:	50 e0       	ldi	r21, 0x00	; 0
    3f08:	2d 81       	ldd	r18, Y+5	; 0x05
    3f0a:	3e 81       	ldd	r19, Y+6	; 0x06
    3f0c:	cb 01       	movw	r24, r22
    3f0e:	b9 01       	movw	r22, r18
    3f10:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3f14:	eb 81       	ldd	r30, Y+3	; 0x03
    3f16:	fc 81       	ldd	r31, Y+4	; 0x04
    3f18:	26 81       	ldd	r18, Z+6	; 0x06
    3f1a:	37 81       	ldd	r19, Z+7	; 0x07
    3f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3f20:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f22:	88 2f       	mov	r24, r24
    3f24:	90 e0       	ldi	r25, 0x00	; 0
    3f26:	90 95       	com	r25
    3f28:	81 95       	neg	r24
    3f2a:	9f 4f       	sbci	r25, 0xFF	; 255
    3f2c:	82 0f       	add	r24, r18
    3f2e:	93 1f       	adc	r25, r19
    3f30:	eb 81       	ldd	r30, Y+3	; 0x03
    3f32:	fc 81       	ldd	r31, Y+4	; 0x04
    3f34:	97 83       	std	Z+7, r25	; 0x07
    3f36:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3f38:	eb 81       	ldd	r30, Y+3	; 0x03
    3f3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f3c:	26 81       	ldd	r18, Z+6	; 0x06
    3f3e:	37 81       	ldd	r19, Z+7	; 0x07
    3f40:	eb 81       	ldd	r30, Y+3	; 0x03
    3f42:	fc 81       	ldd	r31, Y+4	; 0x04
    3f44:	80 81       	ld	r24, Z
    3f46:	91 81       	ldd	r25, Z+1	; 0x01
    3f48:	28 17       	cp	r18, r24
    3f4a:	39 07       	cpc	r19, r25
    3f4c:	90 f4       	brcc	.+36     	; 0x3f72 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f50:	fc 81       	ldd	r31, Y+4	; 0x04
    3f52:	24 81       	ldd	r18, Z+4	; 0x04
    3f54:	35 81       	ldd	r19, Z+5	; 0x05
    3f56:	eb 81       	ldd	r30, Y+3	; 0x03
    3f58:	fc 81       	ldd	r31, Y+4	; 0x04
    3f5a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f5c:	88 2f       	mov	r24, r24
    3f5e:	90 e0       	ldi	r25, 0x00	; 0
    3f60:	90 95       	com	r25
    3f62:	81 95       	neg	r24
    3f64:	9f 4f       	sbci	r25, 0xFF	; 255
    3f66:	82 0f       	add	r24, r18
    3f68:	93 1f       	adc	r25, r19
    3f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f6e:	97 83       	std	Z+7, r25	; 0x07
    3f70:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3f72:	8f 81       	ldd	r24, Y+7	; 0x07
    3f74:	82 30       	cpi	r24, 0x02	; 2
    3f76:	31 f4       	brne	.+12     	; 0x3f84 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3f78:	89 81       	ldd	r24, Y+1	; 0x01
    3f7a:	88 23       	and	r24, r24
    3f7c:	19 f0       	breq	.+6      	; 0x3f84 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3f7e:	89 81       	ldd	r24, Y+1	; 0x01
    3f80:	81 50       	subi	r24, 0x01	; 1
    3f82:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3f84:	89 81       	ldd	r24, Y+1	; 0x01
    3f86:	8f 5f       	subi	r24, 0xFF	; 255
    3f88:	eb 81       	ldd	r30, Y+3	; 0x03
    3f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f8c:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    3f8e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3f90:	27 96       	adiw	r28, 0x07	; 7
    3f92:	0f b6       	in	r0, 0x3f	; 63
    3f94:	f8 94       	cli
    3f96:	de bf       	out	0x3e, r29	; 62
    3f98:	0f be       	out	0x3f, r0	; 63
    3f9a:	cd bf       	out	0x3d, r28	; 61
    3f9c:	cf 91       	pop	r28
    3f9e:	df 91       	pop	r29
    3fa0:	08 95       	ret

00003fa2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3fa2:	df 93       	push	r29
    3fa4:	cf 93       	push	r28
    3fa6:	00 d0       	rcall	.+0      	; 0x3fa8 <prvCopyDataFromQueue+0x6>
    3fa8:	00 d0       	rcall	.+0      	; 0x3faa <prvCopyDataFromQueue+0x8>
    3faa:	cd b7       	in	r28, 0x3d	; 61
    3fac:	de b7       	in	r29, 0x3e	; 62
    3fae:	9a 83       	std	Y+2, r25	; 0x02
    3fb0:	89 83       	std	Y+1, r24	; 0x01
    3fb2:	7c 83       	std	Y+4, r23	; 0x04
    3fb4:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fba:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fbc:	88 23       	and	r24, r24
    3fbe:	89 f1       	breq	.+98     	; 0x4022 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc4:	26 81       	ldd	r18, Z+6	; 0x06
    3fc6:	37 81       	ldd	r19, Z+7	; 0x07
    3fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fca:	fa 81       	ldd	r31, Y+2	; 0x02
    3fcc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fce:	88 2f       	mov	r24, r24
    3fd0:	90 e0       	ldi	r25, 0x00	; 0
    3fd2:	82 0f       	add	r24, r18
    3fd4:	93 1f       	adc	r25, r19
    3fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fda:	97 83       	std	Z+7, r25	; 0x07
    3fdc:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3fde:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe2:	26 81       	ldd	r18, Z+6	; 0x06
    3fe4:	37 81       	ldd	r19, Z+7	; 0x07
    3fe6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fea:	84 81       	ldd	r24, Z+4	; 0x04
    3fec:	95 81       	ldd	r25, Z+5	; 0x05
    3fee:	28 17       	cp	r18, r24
    3ff0:	39 07       	cpc	r19, r25
    3ff2:	40 f0       	brcs	.+16     	; 0x4004 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3ff4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ff8:	80 81       	ld	r24, Z
    3ffa:	91 81       	ldd	r25, Z+1	; 0x01
    3ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    4000:	97 83       	std	Z+7, r25	; 0x07
    4002:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    4004:	e9 81       	ldd	r30, Y+1	; 0x01
    4006:	fa 81       	ldd	r31, Y+2	; 0x02
    4008:	46 81       	ldd	r20, Z+6	; 0x06
    400a:	57 81       	ldd	r21, Z+7	; 0x07
    400c:	e9 81       	ldd	r30, Y+1	; 0x01
    400e:	fa 81       	ldd	r31, Y+2	; 0x02
    4010:	84 8d       	ldd	r24, Z+28	; 0x1c
    4012:	28 2f       	mov	r18, r24
    4014:	30 e0       	ldi	r19, 0x00	; 0
    4016:	8b 81       	ldd	r24, Y+3	; 0x03
    4018:	9c 81       	ldd	r25, Y+4	; 0x04
    401a:	ba 01       	movw	r22, r20
    401c:	a9 01       	movw	r20, r18
    401e:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>
    }
}
    4022:	0f 90       	pop	r0
    4024:	0f 90       	pop	r0
    4026:	0f 90       	pop	r0
    4028:	0f 90       	pop	r0
    402a:	cf 91       	pop	r28
    402c:	df 91       	pop	r29
    402e:	08 95       	ret

00004030 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    4030:	df 93       	push	r29
    4032:	cf 93       	push	r28
    4034:	00 d0       	rcall	.+0      	; 0x4036 <prvUnlockQueue+0x6>
    4036:	00 d0       	rcall	.+0      	; 0x4038 <prvUnlockQueue+0x8>
    4038:	cd b7       	in	r28, 0x3d	; 61
    403a:	de b7       	in	r29, 0x3e	; 62
    403c:	9c 83       	std	Y+4, r25	; 0x04
    403e:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    4040:	0f b6       	in	r0, 0x3f	; 63
    4042:	f8 94       	cli
    4044:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    4046:	eb 81       	ldd	r30, Y+3	; 0x03
    4048:	fc 81       	ldd	r31, Y+4	; 0x04
    404a:	86 8d       	ldd	r24, Z+30	; 0x1e
    404c:	8a 83       	std	Y+2, r24	; 0x02
    404e:	11 c0       	rjmp	.+34     	; 0x4072 <prvUnlockQueue+0x42>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4050:	eb 81       	ldd	r30, Y+3	; 0x03
    4052:	fc 81       	ldd	r31, Y+4	; 0x04
    4054:	81 89       	ldd	r24, Z+17	; 0x11
    4056:	88 23       	and	r24, r24
    4058:	79 f0       	breq	.+30     	; 0x4078 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    405a:	8b 81       	ldd	r24, Y+3	; 0x03
    405c:	9c 81       	ldd	r25, Y+4	; 0x04
    405e:	41 96       	adiw	r24, 0x11	; 17
    4060:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    4064:	88 23       	and	r24, r24
    4066:	11 f0       	breq	.+4      	; 0x406c <prvUnlockQueue+0x3c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    4068:	0e 94 2f 35 	call	0x6a5e	; 0x6a5e <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    406c:	8a 81       	ldd	r24, Y+2	; 0x02
    406e:	81 50       	subi	r24, 0x01	; 1
    4070:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    4072:	8a 81       	ldd	r24, Y+2	; 0x02
    4074:	18 16       	cp	r1, r24
    4076:	64 f3       	brlt	.-40     	; 0x4050 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    4078:	eb 81       	ldd	r30, Y+3	; 0x03
    407a:	fc 81       	ldd	r31, Y+4	; 0x04
    407c:	8f ef       	ldi	r24, 0xFF	; 255
    407e:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    4080:	0f 90       	pop	r0
    4082:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    4084:	0f b6       	in	r0, 0x3f	; 63
    4086:	f8 94       	cli
    4088:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    408a:	eb 81       	ldd	r30, Y+3	; 0x03
    408c:	fc 81       	ldd	r31, Y+4	; 0x04
    408e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4090:	89 83       	std	Y+1, r24	; 0x01
    4092:	11 c0       	rjmp	.+34     	; 0x40b6 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4094:	eb 81       	ldd	r30, Y+3	; 0x03
    4096:	fc 81       	ldd	r31, Y+4	; 0x04
    4098:	80 85       	ldd	r24, Z+8	; 0x08
    409a:	88 23       	and	r24, r24
    409c:	79 f0       	breq	.+30     	; 0x40bc <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    409e:	8b 81       	ldd	r24, Y+3	; 0x03
    40a0:	9c 81       	ldd	r25, Y+4	; 0x04
    40a2:	08 96       	adiw	r24, 0x08	; 8
    40a4:	0e 94 35 32 	call	0x646a	; 0x646a <xTaskRemoveFromEventList>
    40a8:	88 23       	and	r24, r24
    40aa:	11 f0       	breq	.+4      	; 0x40b0 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    40ac:	0e 94 2f 35 	call	0x6a5e	; 0x6a5e <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    40b0:	89 81       	ldd	r24, Y+1	; 0x01
    40b2:	81 50       	subi	r24, 0x01	; 1
    40b4:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    40b6:	89 81       	ldd	r24, Y+1	; 0x01
    40b8:	18 16       	cp	r1, r24
    40ba:	64 f3       	brlt	.-40     	; 0x4094 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    40bc:	eb 81       	ldd	r30, Y+3	; 0x03
    40be:	fc 81       	ldd	r31, Y+4	; 0x04
    40c0:	8f ef       	ldi	r24, 0xFF	; 255
    40c2:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    40c4:	0f 90       	pop	r0
    40c6:	0f be       	out	0x3f, r0	; 63
}
    40c8:	0f 90       	pop	r0
    40ca:	0f 90       	pop	r0
    40cc:	0f 90       	pop	r0
    40ce:	0f 90       	pop	r0
    40d0:	cf 91       	pop	r28
    40d2:	df 91       	pop	r29
    40d4:	08 95       	ret

000040d6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    40d6:	df 93       	push	r29
    40d8:	cf 93       	push	r28
    40da:	00 d0       	rcall	.+0      	; 0x40dc <prvIsQueueEmpty+0x6>
    40dc:	0f 92       	push	r0
    40de:	cd b7       	in	r28, 0x3d	; 61
    40e0:	de b7       	in	r29, 0x3e	; 62
    40e2:	9b 83       	std	Y+3, r25	; 0x03
    40e4:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    40e6:	0f b6       	in	r0, 0x3f	; 63
    40e8:	f8 94       	cli
    40ea:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    40ec:	ea 81       	ldd	r30, Y+2	; 0x02
    40ee:	fb 81       	ldd	r31, Y+3	; 0x03
    40f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    40f2:	88 23       	and	r24, r24
    40f4:	19 f4       	brne	.+6      	; 0x40fc <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    40f6:	81 e0       	ldi	r24, 0x01	; 1
    40f8:	89 83       	std	Y+1, r24	; 0x01
    40fa:	01 c0       	rjmp	.+2      	; 0x40fe <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    40fc:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    40fe:	0f 90       	pop	r0
    4100:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4102:	89 81       	ldd	r24, Y+1	; 0x01
}
    4104:	0f 90       	pop	r0
    4106:	0f 90       	pop	r0
    4108:	0f 90       	pop	r0
    410a:	cf 91       	pop	r28
    410c:	df 91       	pop	r29
    410e:	08 95       	ret

00004110 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    4110:	df 93       	push	r29
    4112:	cf 93       	push	r28
    4114:	00 d0       	rcall	.+0      	; 0x4116 <xQueueIsQueueEmptyFromISR+0x6>
    4116:	00 d0       	rcall	.+0      	; 0x4118 <xQueueIsQueueEmptyFromISR+0x8>
    4118:	0f 92       	push	r0
    411a:	cd b7       	in	r28, 0x3d	; 61
    411c:	de b7       	in	r29, 0x3e	; 62
    411e:	9d 83       	std	Y+5, r25	; 0x05
    4120:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    4122:	8c 81       	ldd	r24, Y+4	; 0x04
    4124:	9d 81       	ldd	r25, Y+5	; 0x05
    4126:	9a 83       	std	Y+2, r25	; 0x02
    4128:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    412a:	e9 81       	ldd	r30, Y+1	; 0x01
    412c:	fa 81       	ldd	r31, Y+2	; 0x02
    412e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4130:	88 23       	and	r24, r24
    4132:	19 f4       	brne	.+6      	; 0x413a <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    4134:	81 e0       	ldi	r24, 0x01	; 1
    4136:	8b 83       	std	Y+3, r24	; 0x03
    4138:	01 c0       	rjmp	.+2      	; 0x413c <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    413a:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    413c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    413e:	0f 90       	pop	r0
    4140:	0f 90       	pop	r0
    4142:	0f 90       	pop	r0
    4144:	0f 90       	pop	r0
    4146:	0f 90       	pop	r0
    4148:	cf 91       	pop	r28
    414a:	df 91       	pop	r29
    414c:	08 95       	ret

0000414e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    414e:	df 93       	push	r29
    4150:	cf 93       	push	r28
    4152:	00 d0       	rcall	.+0      	; 0x4154 <prvIsQueueFull+0x6>
    4154:	0f 92       	push	r0
    4156:	cd b7       	in	r28, 0x3d	; 61
    4158:	de b7       	in	r29, 0x3e	; 62
    415a:	9b 83       	std	Y+3, r25	; 0x03
    415c:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    415e:	0f b6       	in	r0, 0x3f	; 63
    4160:	f8 94       	cli
    4162:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4164:	ea 81       	ldd	r30, Y+2	; 0x02
    4166:	fb 81       	ldd	r31, Y+3	; 0x03
    4168:	92 8d       	ldd	r25, Z+26	; 0x1a
    416a:	ea 81       	ldd	r30, Y+2	; 0x02
    416c:	fb 81       	ldd	r31, Y+3	; 0x03
    416e:	83 8d       	ldd	r24, Z+27	; 0x1b
    4170:	98 17       	cp	r25, r24
    4172:	19 f4       	brne	.+6      	; 0x417a <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    4174:	81 e0       	ldi	r24, 0x01	; 1
    4176:	89 83       	std	Y+1, r24	; 0x01
    4178:	01 c0       	rjmp	.+2      	; 0x417c <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    417a:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    417c:	0f 90       	pop	r0
    417e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4180:	89 81       	ldd	r24, Y+1	; 0x01
}
    4182:	0f 90       	pop	r0
    4184:	0f 90       	pop	r0
    4186:	0f 90       	pop	r0
    4188:	cf 91       	pop	r28
    418a:	df 91       	pop	r29
    418c:	08 95       	ret

0000418e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    418e:	df 93       	push	r29
    4190:	cf 93       	push	r28
    4192:	00 d0       	rcall	.+0      	; 0x4194 <xQueueIsQueueFullFromISR+0x6>
    4194:	00 d0       	rcall	.+0      	; 0x4196 <xQueueIsQueueFullFromISR+0x8>
    4196:	0f 92       	push	r0
    4198:	cd b7       	in	r28, 0x3d	; 61
    419a:	de b7       	in	r29, 0x3e	; 62
    419c:	9d 83       	std	Y+5, r25	; 0x05
    419e:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    41a0:	8c 81       	ldd	r24, Y+4	; 0x04
    41a2:	9d 81       	ldd	r25, Y+5	; 0x05
    41a4:	9a 83       	std	Y+2, r25	; 0x02
    41a6:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    41a8:	e9 81       	ldd	r30, Y+1	; 0x01
    41aa:	fa 81       	ldd	r31, Y+2	; 0x02
    41ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    41ae:	e9 81       	ldd	r30, Y+1	; 0x01
    41b0:	fa 81       	ldd	r31, Y+2	; 0x02
    41b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    41b4:	98 17       	cp	r25, r24
    41b6:	19 f4       	brne	.+6      	; 0x41be <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    41b8:	81 e0       	ldi	r24, 0x01	; 1
    41ba:	8b 83       	std	Y+3, r24	; 0x03
    41bc:	01 c0       	rjmp	.+2      	; 0x41c0 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    41be:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    41c0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    41c2:	0f 90       	pop	r0
    41c4:	0f 90       	pop	r0
    41c6:	0f 90       	pop	r0
    41c8:	0f 90       	pop	r0
    41ca:	0f 90       	pop	r0
    41cc:	cf 91       	pop	r28
    41ce:	df 91       	pop	r29
    41d0:	08 95       	ret

000041d2 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    41d2:	cf 92       	push	r12
    41d4:	df 92       	push	r13
    41d6:	ef 92       	push	r14
    41d8:	ff 92       	push	r15
    41da:	0f 93       	push	r16
    41dc:	1f 93       	push	r17
    41de:	df 93       	push	r29
    41e0:	cf 93       	push	r28
    41e2:	cd b7       	in	r28, 0x3d	; 61
    41e4:	de b7       	in	r29, 0x3e	; 62
    41e6:	2c 97       	sbiw	r28, 0x0c	; 12
    41e8:	0f b6       	in	r0, 0x3f	; 63
    41ea:	f8 94       	cli
    41ec:	de bf       	out	0x3e, r29	; 62
    41ee:	0f be       	out	0x3f, r0	; 63
    41f0:	cd bf       	out	0x3d, r28	; 61
    41f2:	9d 83       	std	Y+5, r25	; 0x05
    41f4:	8c 83       	std	Y+4, r24	; 0x04
    41f6:	7f 83       	std	Y+7, r23	; 0x07
    41f8:	6e 83       	std	Y+6, r22	; 0x06
    41fa:	48 87       	std	Y+8, r20	; 0x08
    41fc:	3a 87       	std	Y+10, r19	; 0x0a
    41fe:	29 87       	std	Y+9, r18	; 0x09
    4200:	1c 87       	std	Y+12, r17	; 0x0c
    4202:	0b 87       	std	Y+11, r16	; 0x0b

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    4204:	88 85       	ldd	r24, Y+8	; 0x08
    4206:	81 30       	cpi	r24, 0x01	; 1
    4208:	19 f4       	brne	.+6      	; 0x4210 <xStreamBufferGenericCreate+0x3e>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    420a:	81 e0       	ldi	r24, 0x01	; 1
    420c:	89 83       	std	Y+1, r24	; 0x01
    420e:	01 c0       	rjmp	.+2      	; 0x4212 <xStreamBufferGenericCreate+0x40>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    4210:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    4212:	8e 81       	ldd	r24, Y+6	; 0x06
    4214:	9f 81       	ldd	r25, Y+7	; 0x07
    4216:	00 97       	sbiw	r24, 0x00	; 0
    4218:	21 f4       	brne	.+8      	; 0x4222 <xStreamBufferGenericCreate+0x50>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    421a:	81 e0       	ldi	r24, 0x01	; 1
    421c:	90 e0       	ldi	r25, 0x00	; 0
    421e:	9f 83       	std	Y+7, r25	; 0x07
    4220:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    4222:	8c 81       	ldd	r24, Y+4	; 0x04
    4224:	9d 81       	ldd	r25, Y+5	; 0x05
    4226:	9c 01       	movw	r18, r24
    4228:	20 5f       	subi	r18, 0xF0	; 240
    422a:	3f 4f       	sbci	r19, 0xFF	; 255
    422c:	8c 81       	ldd	r24, Y+4	; 0x04
    422e:	9d 81       	ldd	r25, Y+5	; 0x05
    4230:	82 17       	cp	r24, r18
    4232:	93 07       	cpc	r25, r19
    4234:	68 f4       	brcc	.+26     	; 0x4250 <xStreamBufferGenericCreate+0x7e>
        {
            xBufferSizeBytes++;
    4236:	8c 81       	ldd	r24, Y+4	; 0x04
    4238:	9d 81       	ldd	r25, Y+5	; 0x05
    423a:	01 96       	adiw	r24, 0x01	; 1
    423c:	9d 83       	std	Y+5, r25	; 0x05
    423e:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    4240:	8c 81       	ldd	r24, Y+4	; 0x04
    4242:	9d 81       	ldd	r25, Y+5	; 0x05
    4244:	0f 96       	adiw	r24, 0x0f	; 15
    4246:	0e 94 ae 12 	call	0x255c	; 0x255c <pvPortMalloc>
    424a:	9b 83       	std	Y+3, r25	; 0x03
    424c:	8a 83       	std	Y+2, r24	; 0x02
    424e:	02 c0       	rjmp	.+4      	; 0x4254 <xStreamBufferGenericCreate+0x82>
        }
        else
        {
            pucAllocatedMemory = NULL;
    4250:	1b 82       	std	Y+3, r1	; 0x03
    4252:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    4254:	8a 81       	ldd	r24, Y+2	; 0x02
    4256:	9b 81       	ldd	r25, Y+3	; 0x03
    4258:	00 97       	sbiw	r24, 0x00	; 0
    425a:	b1 f0       	breq	.+44     	; 0x4288 <xStreamBufferGenericCreate+0xb6>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    425c:	6a 81       	ldd	r22, Y+2	; 0x02
    425e:	7b 81       	ldd	r23, Y+3	; 0x03
    4260:	8a 81       	ldd	r24, Y+2	; 0x02
    4262:	9b 81       	ldd	r25, Y+3	; 0x03
    4264:	9c 01       	movw	r18, r24
    4266:	21 5f       	subi	r18, 0xF1	; 241
    4268:	3f 4f       	sbci	r19, 0xFF	; 255
    426a:	4c 81       	ldd	r20, Y+4	; 0x04
    426c:	5d 81       	ldd	r21, Y+5	; 0x05
    426e:	ee 81       	ldd	r30, Y+6	; 0x06
    4270:	ff 81       	ldd	r31, Y+7	; 0x07
    4272:	a9 85       	ldd	r26, Y+9	; 0x09
    4274:	ba 85       	ldd	r27, Y+10	; 0x0a
    4276:	cb 84       	ldd	r12, Y+11	; 0x0b
    4278:	dc 84       	ldd	r13, Y+12	; 0x0c
    427a:	cb 01       	movw	r24, r22
    427c:	b9 01       	movw	r22, r18
    427e:	9f 01       	movw	r18, r30
    4280:	09 81       	ldd	r16, Y+1	; 0x01
    4282:	7d 01       	movw	r14, r26
    4284:	0e 94 a1 28 	call	0x5142	; 0x5142 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    4288:	8a 81       	ldd	r24, Y+2	; 0x02
    428a:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    428c:	2c 96       	adiw	r28, 0x0c	; 12
    428e:	0f b6       	in	r0, 0x3f	; 63
    4290:	f8 94       	cli
    4292:	de bf       	out	0x3e, r29	; 62
    4294:	0f be       	out	0x3f, r0	; 63
    4296:	cd bf       	out	0x3d, r28	; 61
    4298:	cf 91       	pop	r28
    429a:	df 91       	pop	r29
    429c:	1f 91       	pop	r17
    429e:	0f 91       	pop	r16
    42a0:	ff 90       	pop	r15
    42a2:	ef 90       	pop	r14
    42a4:	df 90       	pop	r13
    42a6:	cf 90       	pop	r12
    42a8:	08 95       	ret

000042aa <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    42aa:	df 93       	push	r29
    42ac:	cf 93       	push	r28
    42ae:	00 d0       	rcall	.+0      	; 0x42b0 <vStreamBufferDelete+0x6>
    42b0:	00 d0       	rcall	.+0      	; 0x42b2 <vStreamBufferDelete+0x8>
    42b2:	cd b7       	in	r28, 0x3d	; 61
    42b4:	de b7       	in	r29, 0x3e	; 62
    42b6:	9c 83       	std	Y+4, r25	; 0x04
    42b8:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    42ba:	8b 81       	ldd	r24, Y+3	; 0x03
    42bc:	9c 81       	ldd	r25, Y+4	; 0x04
    42be:	9a 83       	std	Y+2, r25	; 0x02
    42c0:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    42c2:	e9 81       	ldd	r30, Y+1	; 0x01
    42c4:	fa 81       	ldd	r31, Y+2	; 0x02
    42c6:	86 85       	ldd	r24, Z+14	; 0x0e
    42c8:	88 2f       	mov	r24, r24
    42ca:	90 e0       	ldi	r25, 0x00	; 0
    42cc:	82 70       	andi	r24, 0x02	; 2
    42ce:	90 70       	andi	r25, 0x00	; 0
    42d0:	00 97       	sbiw	r24, 0x00	; 0
    42d2:	29 f4       	brne	.+10     	; 0x42de <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	9a 81       	ldd	r25, Y+2	; 0x02
    42d8:	0e 94 a3 13 	call	0x2746	; 0x2746 <vPortFree>
    42dc:	08 c0       	rjmp	.+16     	; 0x42ee <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    42de:	89 81       	ldd	r24, Y+1	; 0x01
    42e0:	9a 81       	ldd	r25, Y+2	; 0x02
    42e2:	60 e0       	ldi	r22, 0x00	; 0
    42e4:	70 e0       	ldi	r23, 0x00	; 0
    42e6:	4f e0       	ldi	r20, 0x0F	; 15
    42e8:	50 e0       	ldi	r21, 0x00	; 0
    42ea:	0e 94 0c 40 	call	0x8018	; 0x8018 <memset>
    }
}
    42ee:	0f 90       	pop	r0
    42f0:	0f 90       	pop	r0
    42f2:	0f 90       	pop	r0
    42f4:	0f 90       	pop	r0
    42f6:	cf 91       	pop	r28
    42f8:	df 91       	pop	r29
    42fa:	08 95       	ret

000042fc <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    42fc:	cf 92       	push	r12
    42fe:	df 92       	push	r13
    4300:	ef 92       	push	r14
    4302:	ff 92       	push	r15
    4304:	0f 93       	push	r16
    4306:	1f 93       	push	r17
    4308:	df 93       	push	r29
    430a:	cf 93       	push	r28
    430c:	cd b7       	in	r28, 0x3d	; 61
    430e:	de b7       	in	r29, 0x3e	; 62
    4310:	29 97       	sbiw	r28, 0x09	; 9
    4312:	0f b6       	in	r0, 0x3f	; 63
    4314:	f8 94       	cli
    4316:	de bf       	out	0x3e, r29	; 62
    4318:	0f be       	out	0x3f, r0	; 63
    431a:	cd bf       	out	0x3d, r28	; 61
    431c:	99 87       	std	Y+9, r25	; 0x09
    431e:	88 87       	std	Y+8, r24	; 0x08
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4320:	88 85       	ldd	r24, Y+8	; 0x08
    4322:	99 85       	ldd	r25, Y+9	; 0x09
    4324:	9f 83       	std	Y+7, r25	; 0x07
    4326:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn = pdFAIL;
    4328:	1d 82       	std	Y+5, r1	; 0x05
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
    432a:	1c 82       	std	Y+4, r1	; 0x04
    432c:	1b 82       	std	Y+3, r1	; 0x03
    432e:	1a 82       	std	Y+2, r1	; 0x02
    4330:	19 82       	std	Y+1, r1	; 0x01
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    4332:	0f b6       	in	r0, 0x3f	; 63
    4334:	f8 94       	cli
    4336:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    4338:	ee 81       	ldd	r30, Y+6	; 0x06
    433a:	ff 81       	ldd	r31, Y+7	; 0x07
    433c:	80 85       	ldd	r24, Z+8	; 0x08
    433e:	91 85       	ldd	r25, Z+9	; 0x09
    4340:	00 97       	sbiw	r24, 0x00	; 0
    4342:	21 f5       	brne	.+72     	; 0x438c <xStreamBufferReset+0x90>
    4344:	ee 81       	ldd	r30, Y+6	; 0x06
    4346:	ff 81       	ldd	r31, Y+7	; 0x07
    4348:	82 85       	ldd	r24, Z+10	; 0x0a
    434a:	93 85       	ldd	r25, Z+11	; 0x0b
    434c:	00 97       	sbiw	r24, 0x00	; 0
    434e:	f1 f4       	brne	.+60     	; 0x438c <xStreamBufferReset+0x90>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    4350:	ee 81       	ldd	r30, Y+6	; 0x06
    4352:	ff 81       	ldd	r31, Y+7	; 0x07
    4354:	44 85       	ldd	r20, Z+12	; 0x0c
    4356:	55 85       	ldd	r21, Z+13	; 0x0d
    4358:	ee 81       	ldd	r30, Y+6	; 0x06
    435a:	ff 81       	ldd	r31, Y+7	; 0x07
    435c:	24 81       	ldd	r18, Z+4	; 0x04
    435e:	35 81       	ldd	r19, Z+5	; 0x05
    4360:	ee 81       	ldd	r30, Y+6	; 0x06
    4362:	ff 81       	ldd	r31, Y+7	; 0x07
    4364:	a6 81       	ldd	r26, Z+6	; 0x06
    4366:	b7 81       	ldd	r27, Z+7	; 0x07
    4368:	ee 81       	ldd	r30, Y+6	; 0x06
    436a:	ff 81       	ldd	r31, Y+7	; 0x07
    436c:	16 85       	ldd	r17, Z+14	; 0x0e
    436e:	8e 81       	ldd	r24, Y+6	; 0x06
    4370:	9f 81       	ldd	r25, Y+7	; 0x07
    4372:	eb 81       	ldd	r30, Y+3	; 0x03
    4374:	fc 81       	ldd	r31, Y+4	; 0x04
    4376:	c9 80       	ldd	r12, Y+1	; 0x01
    4378:	da 80       	ldd	r13, Y+2	; 0x02
    437a:	ba 01       	movw	r22, r20
    437c:	a9 01       	movw	r20, r18
    437e:	9d 01       	movw	r18, r26
    4380:	01 2f       	mov	r16, r17
    4382:	7f 01       	movw	r14, r30
    4384:	0e 94 a1 28 	call	0x5142	; 0x5142 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
    4388:	81 e0       	ldi	r24, 0x01	; 1
    438a:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    438c:	0f 90       	pop	r0
    438e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4390:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4392:	29 96       	adiw	r28, 0x09	; 9
    4394:	0f b6       	in	r0, 0x3f	; 63
    4396:	f8 94       	cli
    4398:	de bf       	out	0x3e, r29	; 62
    439a:	0f be       	out	0x3f, r0	; 63
    439c:	cd bf       	out	0x3d, r28	; 61
    439e:	cf 91       	pop	r28
    43a0:	df 91       	pop	r29
    43a2:	1f 91       	pop	r17
    43a4:	0f 91       	pop	r16
    43a6:	ff 90       	pop	r15
    43a8:	ef 90       	pop	r14
    43aa:	df 90       	pop	r13
    43ac:	cf 90       	pop	r12
    43ae:	08 95       	ret

000043b0 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    43b0:	df 93       	push	r29
    43b2:	cf 93       	push	r28
    43b4:	cd b7       	in	r28, 0x3d	; 61
    43b6:	de b7       	in	r29, 0x3e	; 62
    43b8:	27 97       	sbiw	r28, 0x07	; 7
    43ba:	0f b6       	in	r0, 0x3f	; 63
    43bc:	f8 94       	cli
    43be:	de bf       	out	0x3e, r29	; 62
    43c0:	0f be       	out	0x3f, r0	; 63
    43c2:	cd bf       	out	0x3d, r28	; 61
    43c4:	9d 83       	std	Y+5, r25	; 0x05
    43c6:	8c 83       	std	Y+4, r24	; 0x04
    43c8:	7f 83       	std	Y+7, r23	; 0x07
    43ca:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    43cc:	8c 81       	ldd	r24, Y+4	; 0x04
    43ce:	9d 81       	ldd	r25, Y+5	; 0x05
    43d0:	9b 83       	std	Y+3, r25	; 0x03
    43d2:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    43d4:	8e 81       	ldd	r24, Y+6	; 0x06
    43d6:	9f 81       	ldd	r25, Y+7	; 0x07
    43d8:	00 97       	sbiw	r24, 0x00	; 0
    43da:	21 f4       	brne	.+8      	; 0x43e4 <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    43dc:	81 e0       	ldi	r24, 0x01	; 1
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	9f 83       	std	Y+7, r25	; 0x07
    43e2:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    43e4:	ea 81       	ldd	r30, Y+2	; 0x02
    43e6:	fb 81       	ldd	r31, Y+3	; 0x03
    43e8:	24 81       	ldd	r18, Z+4	; 0x04
    43ea:	35 81       	ldd	r19, Z+5	; 0x05
    43ec:	8e 81       	ldd	r24, Y+6	; 0x06
    43ee:	9f 81       	ldd	r25, Y+7	; 0x07
    43f0:	82 17       	cp	r24, r18
    43f2:	93 07       	cpc	r25, r19
    43f4:	48 f4       	brcc	.+18     	; 0x4408 <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    43f6:	ea 81       	ldd	r30, Y+2	; 0x02
    43f8:	fb 81       	ldd	r31, Y+3	; 0x03
    43fa:	8e 81       	ldd	r24, Y+6	; 0x06
    43fc:	9f 81       	ldd	r25, Y+7	; 0x07
    43fe:	97 83       	std	Z+7, r25	; 0x07
    4400:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    4402:	81 e0       	ldi	r24, 0x01	; 1
    4404:	89 83       	std	Y+1, r24	; 0x01
    4406:	01 c0       	rjmp	.+2      	; 0x440a <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    4408:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    440a:	89 81       	ldd	r24, Y+1	; 0x01
}
    440c:	27 96       	adiw	r28, 0x07	; 7
    440e:	0f b6       	in	r0, 0x3f	; 63
    4410:	f8 94       	cli
    4412:	de bf       	out	0x3e, r29	; 62
    4414:	0f be       	out	0x3f, r0	; 63
    4416:	cd bf       	out	0x3d, r28	; 61
    4418:	cf 91       	pop	r28
    441a:	df 91       	pop	r29
    441c:	08 95       	ret

0000441e <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    441e:	df 93       	push	r29
    4420:	cf 93       	push	r28
    4422:	cd b7       	in	r28, 0x3d	; 61
    4424:	de b7       	in	r29, 0x3e	; 62
    4426:	28 97       	sbiw	r28, 0x08	; 8
    4428:	0f b6       	in	r0, 0x3f	; 63
    442a:	f8 94       	cli
    442c:	de bf       	out	0x3e, r29	; 62
    442e:	0f be       	out	0x3f, r0	; 63
    4430:	cd bf       	out	0x3d, r28	; 61
    4432:	98 87       	std	Y+8, r25	; 0x08
    4434:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4436:	8f 81       	ldd	r24, Y+7	; 0x07
    4438:	98 85       	ldd	r25, Y+8	; 0x08
    443a:	9e 83       	std	Y+6, r25	; 0x06
    443c:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    443e:	ed 81       	ldd	r30, Y+5	; 0x05
    4440:	fe 81       	ldd	r31, Y+6	; 0x06
    4442:	80 81       	ld	r24, Z
    4444:	91 81       	ldd	r25, Z+1	; 0x01
    4446:	9a 83       	std	Y+2, r25	; 0x02
    4448:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    444a:	ed 81       	ldd	r30, Y+5	; 0x05
    444c:	fe 81       	ldd	r31, Y+6	; 0x06
    444e:	24 81       	ldd	r18, Z+4	; 0x04
    4450:	35 81       	ldd	r19, Z+5	; 0x05
    4452:	ed 81       	ldd	r30, Y+5	; 0x05
    4454:	fe 81       	ldd	r31, Y+6	; 0x06
    4456:	80 81       	ld	r24, Z
    4458:	91 81       	ldd	r25, Z+1	; 0x01
    445a:	82 0f       	add	r24, r18
    445c:	93 1f       	adc	r25, r19
    445e:	9c 83       	std	Y+4, r25	; 0x04
    4460:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    4462:	ed 81       	ldd	r30, Y+5	; 0x05
    4464:	fe 81       	ldd	r31, Y+6	; 0x06
    4466:	22 81       	ldd	r18, Z+2	; 0x02
    4468:	33 81       	ldd	r19, Z+3	; 0x03
    446a:	8b 81       	ldd	r24, Y+3	; 0x03
    446c:	9c 81       	ldd	r25, Y+4	; 0x04
    446e:	82 1b       	sub	r24, r18
    4470:	93 0b       	sbc	r25, r19
    4472:	9c 83       	std	Y+4, r25	; 0x04
    4474:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    4476:	ed 81       	ldd	r30, Y+5	; 0x05
    4478:	fe 81       	ldd	r31, Y+6	; 0x06
    447a:	20 81       	ld	r18, Z
    447c:	31 81       	ldd	r19, Z+1	; 0x01
    447e:	89 81       	ldd	r24, Y+1	; 0x01
    4480:	9a 81       	ldd	r25, Y+2	; 0x02
    4482:	28 17       	cp	r18, r24
    4484:	39 07       	cpc	r19, r25
    4486:	d9 f6       	brne	.-74     	; 0x443e <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    4488:	8b 81       	ldd	r24, Y+3	; 0x03
    448a:	9c 81       	ldd	r25, Y+4	; 0x04
    448c:	01 97       	sbiw	r24, 0x01	; 1
    448e:	9c 83       	std	Y+4, r25	; 0x04
    4490:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    4492:	ed 81       	ldd	r30, Y+5	; 0x05
    4494:	fe 81       	ldd	r31, Y+6	; 0x06
    4496:	24 81       	ldd	r18, Z+4	; 0x04
    4498:	35 81       	ldd	r19, Z+5	; 0x05
    449a:	8b 81       	ldd	r24, Y+3	; 0x03
    449c:	9c 81       	ldd	r25, Y+4	; 0x04
    449e:	82 17       	cp	r24, r18
    44a0:	93 07       	cpc	r25, r19
    44a2:	50 f0       	brcs	.+20     	; 0x44b8 <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    44a4:	ed 81       	ldd	r30, Y+5	; 0x05
    44a6:	fe 81       	ldd	r31, Y+6	; 0x06
    44a8:	24 81       	ldd	r18, Z+4	; 0x04
    44aa:	35 81       	ldd	r19, Z+5	; 0x05
    44ac:	8b 81       	ldd	r24, Y+3	; 0x03
    44ae:	9c 81       	ldd	r25, Y+4	; 0x04
    44b0:	82 1b       	sub	r24, r18
    44b2:	93 0b       	sbc	r25, r19
    44b4:	9c 83       	std	Y+4, r25	; 0x04
    44b6:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    44b8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ba:	9c 81       	ldd	r25, Y+4	; 0x04
}
    44bc:	28 96       	adiw	r28, 0x08	; 8
    44be:	0f b6       	in	r0, 0x3f	; 63
    44c0:	f8 94       	cli
    44c2:	de bf       	out	0x3e, r29	; 62
    44c4:	0f be       	out	0x3f, r0	; 63
    44c6:	cd bf       	out	0x3d, r28	; 61
    44c8:	cf 91       	pop	r28
    44ca:	df 91       	pop	r29
    44cc:	08 95       	ret

000044ce <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    44ce:	df 93       	push	r29
    44d0:	cf 93       	push	r28
    44d2:	00 d0       	rcall	.+0      	; 0x44d4 <xStreamBufferBytesAvailable+0x6>
    44d4:	00 d0       	rcall	.+0      	; 0x44d6 <xStreamBufferBytesAvailable+0x8>
    44d6:	00 d0       	rcall	.+0      	; 0x44d8 <xStreamBufferBytesAvailable+0xa>
    44d8:	cd b7       	in	r28, 0x3d	; 61
    44da:	de b7       	in	r29, 0x3e	; 62
    44dc:	9e 83       	std	Y+6, r25	; 0x06
    44de:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    44e0:	8d 81       	ldd	r24, Y+5	; 0x05
    44e2:	9e 81       	ldd	r25, Y+6	; 0x06
    44e4:	9c 83       	std	Y+4, r25	; 0x04
    44e6:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    44e8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ea:	9c 81       	ldd	r25, Y+4	; 0x04
    44ec:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    44f0:	9a 83       	std	Y+2, r25	; 0x02
    44f2:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    44f4:	89 81       	ldd	r24, Y+1	; 0x01
    44f6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    44f8:	26 96       	adiw	r28, 0x06	; 6
    44fa:	0f b6       	in	r0, 0x3f	; 63
    44fc:	f8 94       	cli
    44fe:	de bf       	out	0x3e, r29	; 62
    4500:	0f be       	out	0x3f, r0	; 63
    4502:	cd bf       	out	0x3d, r28	; 61
    4504:	cf 91       	pop	r28
    4506:	df 91       	pop	r29
    4508:	08 95       	ret

0000450a <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    450a:	cf 92       	push	r12
    450c:	df 92       	push	r13
    450e:	ef 92       	push	r14
    4510:	ff 92       	push	r15
    4512:	0f 93       	push	r16
    4514:	1f 93       	push	r17
    4516:	df 93       	push	r29
    4518:	cf 93       	push	r28
    451a:	cd b7       	in	r28, 0x3d	; 61
    451c:	de b7       	in	r29, 0x3e	; 62
    451e:	65 97       	sbiw	r28, 0x15	; 21
    4520:	0f b6       	in	r0, 0x3f	; 63
    4522:	f8 94       	cli
    4524:	de bf       	out	0x3e, r29	; 62
    4526:	0f be       	out	0x3f, r0	; 63
    4528:	cd bf       	out	0x3d, r28	; 61
    452a:	9f 87       	std	Y+15, r25	; 0x0f
    452c:	8e 87       	std	Y+14, r24	; 0x0e
    452e:	79 8b       	std	Y+17, r23	; 0x11
    4530:	68 8b       	std	Y+16, r22	; 0x10
    4532:	5b 8b       	std	Y+19, r21	; 0x13
    4534:	4a 8b       	std	Y+18, r20	; 0x12
    4536:	3d 8b       	std	Y+21, r19	; 0x15
    4538:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    453a:	8e 85       	ldd	r24, Y+14	; 0x0e
    453c:	9f 85       	ldd	r25, Y+15	; 0x0f
    453e:	9a 87       	std	Y+10, r25	; 0x0a
    4540:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    4542:	1e 82       	std	Y+6, r1	; 0x06
    4544:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    4546:	8a 89       	ldd	r24, Y+18	; 0x12
    4548:	9b 89       	ldd	r25, Y+19	; 0x13
    454a:	9c 83       	std	Y+4, r25	; 0x04
    454c:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    454e:	1a 82       	std	Y+2, r1	; 0x02
    4550:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    4552:	e9 85       	ldd	r30, Y+9	; 0x09
    4554:	fa 85       	ldd	r31, Y+10	; 0x0a
    4556:	84 81       	ldd	r24, Z+4	; 0x04
    4558:	95 81       	ldd	r25, Z+5	; 0x05
    455a:	01 97       	sbiw	r24, 0x01	; 1
    455c:	9a 83       	std	Y+2, r25	; 0x02
    455e:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4560:	e9 85       	ldd	r30, Y+9	; 0x09
    4562:	fa 85       	ldd	r31, Y+10	; 0x0a
    4564:	86 85       	ldd	r24, Z+14	; 0x0e
    4566:	88 2f       	mov	r24, r24
    4568:	90 e0       	ldi	r25, 0x00	; 0
    456a:	81 70       	andi	r24, 0x01	; 1
    456c:	90 70       	andi	r25, 0x00	; 0
    456e:	88 23       	and	r24, r24
    4570:	79 f0       	breq	.+30     	; 0x4590 <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4572:	8b 81       	ldd	r24, Y+3	; 0x03
    4574:	9c 81       	ldd	r25, Y+4	; 0x04
    4576:	02 96       	adiw	r24, 0x02	; 2
    4578:	9c 83       	std	Y+4, r25	; 0x04
    457a:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    457c:	2b 81       	ldd	r18, Y+3	; 0x03
    457e:	3c 81       	ldd	r19, Y+4	; 0x04
    4580:	89 81       	ldd	r24, Y+1	; 0x01
    4582:	9a 81       	ldd	r25, Y+2	; 0x02
    4584:	82 17       	cp	r24, r18
    4586:	93 07       	cpc	r25, r19
    4588:	70 f4       	brcc	.+28     	; 0x45a6 <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    458a:	1d 8a       	std	Y+21, r1	; 0x15
    458c:	1c 8a       	std	Y+20, r1	; 0x14
    458e:	0b c0       	rjmp	.+22     	; 0x45a6 <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    4590:	2b 81       	ldd	r18, Y+3	; 0x03
    4592:	3c 81       	ldd	r19, Y+4	; 0x04
    4594:	89 81       	ldd	r24, Y+1	; 0x01
    4596:	9a 81       	ldd	r25, Y+2	; 0x02
    4598:	82 17       	cp	r24, r18
    459a:	93 07       	cpc	r25, r19
    459c:	20 f4       	brcc	.+8      	; 0x45a6 <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    459e:	89 81       	ldd	r24, Y+1	; 0x01
    45a0:	9a 81       	ldd	r25, Y+2	; 0x02
    45a2:	9c 83       	std	Y+4, r25	; 0x04
    45a4:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    45a6:	8c 89       	ldd	r24, Y+20	; 0x14
    45a8:	9d 89       	ldd	r25, Y+21	; 0x15
    45aa:	00 97       	sbiw	r24, 0x00	; 0
    45ac:	09 f4       	brne	.+2      	; 0x45b0 <xStreamBufferSend+0xa6>
    45ae:	43 c0       	rjmp	.+134    	; 0x4636 <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    45b0:	ce 01       	movw	r24, r28
    45b2:	0b 96       	adiw	r24, 0x0b	; 11
    45b4:	0e 94 87 34 	call	0x690e	; 0x690e <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    45b8:	0f b6       	in	r0, 0x3f	; 63
    45ba:	f8 94       	cli
    45bc:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    45be:	89 85       	ldd	r24, Y+9	; 0x09
    45c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    45c2:	0e 94 0f 22 	call	0x441e	; 0x441e <xStreamBufferSpacesAvailable>
    45c6:	9e 83       	std	Y+6, r25	; 0x06
    45c8:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    45ca:	2d 81       	ldd	r18, Y+5	; 0x05
    45cc:	3e 81       	ldd	r19, Y+6	; 0x06
    45ce:	8b 81       	ldd	r24, Y+3	; 0x03
    45d0:	9c 81       	ldd	r25, Y+4	; 0x04
    45d2:	28 17       	cp	r18, r24
    45d4:	39 07       	cpc	r19, r25
    45d6:	68 f5       	brcc	.+90     	; 0x4632 <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    45d8:	80 e0       	ldi	r24, 0x00	; 0
    45da:	90 e0       	ldi	r25, 0x00	; 0
    45dc:	60 e0       	ldi	r22, 0x00	; 0
    45de:	0e 94 de 3c 	call	0x79bc	; 0x79bc <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    45e2:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xTaskGetCurrentTaskHandle>
    45e6:	e9 85       	ldd	r30, Y+9	; 0x09
    45e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    45ea:	93 87       	std	Z+11, r25	; 0x0b
    45ec:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    45ee:	0f 90       	pop	r0
    45f0:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    45f2:	ec 89       	ldd	r30, Y+20	; 0x14
    45f4:	fd 89       	ldd	r31, Y+21	; 0x15
    45f6:	80 e0       	ldi	r24, 0x00	; 0
    45f8:	40 e0       	ldi	r20, 0x00	; 0
    45fa:	50 e0       	ldi	r21, 0x00	; 0
    45fc:	60 e0       	ldi	r22, 0x00	; 0
    45fe:	70 e0       	ldi	r23, 0x00	; 0
    4600:	00 e0       	ldi	r16, 0x00	; 0
    4602:	10 e0       	ldi	r17, 0x00	; 0
    4604:	20 e0       	ldi	r18, 0x00	; 0
    4606:	30 e0       	ldi	r19, 0x00	; 0
    4608:	ee 24       	eor	r14, r14
    460a:	ff 24       	eor	r15, r15
    460c:	6f 01       	movw	r12, r30
    460e:	0e 94 da 36 	call	0x6db4	; 0x6db4 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    4612:	e9 85       	ldd	r30, Y+9	; 0x09
    4614:	fa 85       	ldd	r31, Y+10	; 0x0a
    4616:	13 86       	std	Z+11, r1	; 0x0b
    4618:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    461a:	ce 01       	movw	r24, r28
    461c:	0b 96       	adiw	r24, 0x0b	; 11
    461e:	9e 01       	movw	r18, r28
    4620:	2c 5e       	subi	r18, 0xEC	; 236
    4622:	3f 4f       	sbci	r19, 0xFF	; 255
    4624:	b9 01       	movw	r22, r18
    4626:	0e 94 be 34 	call	0x697c	; 0x697c <xTaskCheckForTimeOut>
    462a:	88 23       	and	r24, r24
    462c:	09 f4       	brne	.+2      	; 0x4630 <xStreamBufferSend+0x126>
    462e:	c4 cf       	rjmp	.-120    	; 0x45b8 <xStreamBufferSend+0xae>
    4630:	02 c0       	rjmp	.+4      	; 0x4636 <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    4632:	0f 90       	pop	r0
    4634:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    4636:	8d 81       	ldd	r24, Y+5	; 0x05
    4638:	9e 81       	ldd	r25, Y+6	; 0x06
    463a:	00 97       	sbiw	r24, 0x00	; 0
    463c:	31 f4       	brne	.+12     	; 0x464a <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    463e:	89 85       	ldd	r24, Y+9	; 0x09
    4640:	9a 85       	ldd	r25, Y+10	; 0x0a
    4642:	0e 94 0f 22 	call	0x441e	; 0x441e <xStreamBufferSpacesAvailable>
    4646:	9e 83       	std	Y+6, r25	; 0x06
    4648:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    464a:	89 85       	ldd	r24, Y+9	; 0x09
    464c:	9a 85       	ldd	r25, Y+10	; 0x0a
    464e:	28 89       	ldd	r18, Y+16	; 0x10
    4650:	39 89       	ldd	r19, Y+17	; 0x11
    4652:	4a 89       	ldd	r20, Y+18	; 0x12
    4654:	5b 89       	ldd	r21, Y+19	; 0x13
    4656:	ed 81       	ldd	r30, Y+5	; 0x05
    4658:	fe 81       	ldd	r31, Y+6	; 0x06
    465a:	ab 81       	ldd	r26, Y+3	; 0x03
    465c:	bc 81       	ldd	r27, Y+4	; 0x04
    465e:	b9 01       	movw	r22, r18
    4660:	9f 01       	movw	r18, r30
    4662:	8d 01       	movw	r16, r26
    4664:	0e 94 f5 23 	call	0x47ea	; 0x47ea <prvWriteMessageToBuffer>
    4668:	98 87       	std	Y+8, r25	; 0x08
    466a:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    466c:	8f 81       	ldd	r24, Y+7	; 0x07
    466e:	98 85       	ldd	r25, Y+8	; 0x08
    4670:	00 97       	sbiw	r24, 0x00	; 0
    4672:	41 f1       	breq	.+80     	; 0x46c4 <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4674:	89 85       	ldd	r24, Y+9	; 0x09
    4676:	9a 85       	ldd	r25, Y+10	; 0x0a
    4678:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    467c:	9c 01       	movw	r18, r24
    467e:	e9 85       	ldd	r30, Y+9	; 0x09
    4680:	fa 85       	ldd	r31, Y+10	; 0x0a
    4682:	86 81       	ldd	r24, Z+6	; 0x06
    4684:	97 81       	ldd	r25, Z+7	; 0x07
    4686:	28 17       	cp	r18, r24
    4688:	39 07       	cpc	r19, r25
    468a:	e0 f0       	brcs	.+56     	; 0x46c4 <xStreamBufferSend+0x1ba>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    468c:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
    4690:	e9 85       	ldd	r30, Y+9	; 0x09
    4692:	fa 85       	ldd	r31, Y+10	; 0x0a
    4694:	80 85       	ldd	r24, Z+8	; 0x08
    4696:	91 85       	ldd	r25, Z+9	; 0x09
    4698:	00 97       	sbiw	r24, 0x00	; 0
    469a:	91 f0       	breq	.+36     	; 0x46c0 <xStreamBufferSend+0x1b6>
    469c:	e9 85       	ldd	r30, Y+9	; 0x09
    469e:	fa 85       	ldd	r31, Y+10	; 0x0a
    46a0:	80 85       	ldd	r24, Z+8	; 0x08
    46a2:	91 85       	ldd	r25, Z+9	; 0x09
    46a4:	60 e0       	ldi	r22, 0x00	; 0
    46a6:	20 e0       	ldi	r18, 0x00	; 0
    46a8:	30 e0       	ldi	r19, 0x00	; 0
    46aa:	40 e0       	ldi	r20, 0x00	; 0
    46ac:	50 e0       	ldi	r21, 0x00	; 0
    46ae:	00 e0       	ldi	r16, 0x00	; 0
    46b0:	ee 24       	eor	r14, r14
    46b2:	ff 24       	eor	r15, r15
    46b4:	0e 94 d1 37 	call	0x6fa2	; 0x6fa2 <xTaskGenericNotify>
    46b8:	e9 85       	ldd	r30, Y+9	; 0x09
    46ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    46bc:	11 86       	std	Z+9, r1	; 0x09
    46be:	10 86       	std	Z+8, r1	; 0x08
    46c0:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    46c4:	8f 81       	ldd	r24, Y+7	; 0x07
    46c6:	98 85       	ldd	r25, Y+8	; 0x08
}
    46c8:	65 96       	adiw	r28, 0x15	; 21
    46ca:	0f b6       	in	r0, 0x3f	; 63
    46cc:	f8 94       	cli
    46ce:	de bf       	out	0x3e, r29	; 62
    46d0:	0f be       	out	0x3f, r0	; 63
    46d2:	cd bf       	out	0x3d, r28	; 61
    46d4:	cf 91       	pop	r28
    46d6:	df 91       	pop	r29
    46d8:	1f 91       	pop	r17
    46da:	0f 91       	pop	r16
    46dc:	ff 90       	pop	r15
    46de:	ef 90       	pop	r14
    46e0:	df 90       	pop	r13
    46e2:	cf 90       	pop	r12
    46e4:	08 95       	ret

000046e6 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    46e6:	cf 92       	push	r12
    46e8:	df 92       	push	r13
    46ea:	ef 92       	push	r14
    46ec:	ff 92       	push	r15
    46ee:	0f 93       	push	r16
    46f0:	1f 93       	push	r17
    46f2:	df 93       	push	r29
    46f4:	cf 93       	push	r28
    46f6:	cd b7       	in	r28, 0x3d	; 61
    46f8:	de b7       	in	r29, 0x3e	; 62
    46fa:	61 97       	sbiw	r28, 0x11	; 17
    46fc:	0f b6       	in	r0, 0x3f	; 63
    46fe:	f8 94       	cli
    4700:	de bf       	out	0x3e, r29	; 62
    4702:	0f be       	out	0x3f, r0	; 63
    4704:	cd bf       	out	0x3d, r28	; 61
    4706:	9b 87       	std	Y+11, r25	; 0x0b
    4708:	8a 87       	std	Y+10, r24	; 0x0a
    470a:	7d 87       	std	Y+13, r23	; 0x0d
    470c:	6c 87       	std	Y+12, r22	; 0x0c
    470e:	5f 87       	std	Y+15, r21	; 0x0f
    4710:	4e 87       	std	Y+14, r20	; 0x0e
    4712:	39 8b       	std	Y+17, r19	; 0x11
    4714:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4716:	8a 85       	ldd	r24, Y+10	; 0x0a
    4718:	9b 85       	ldd	r25, Y+11	; 0x0b
    471a:	99 87       	std	Y+9, r25	; 0x09
    471c:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    471e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4720:	9f 85       	ldd	r25, Y+15	; 0x0f
    4722:	9b 83       	std	Y+3, r25	; 0x03
    4724:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4726:	e8 85       	ldd	r30, Y+8	; 0x08
    4728:	f9 85       	ldd	r31, Y+9	; 0x09
    472a:	86 85       	ldd	r24, Z+14	; 0x0e
    472c:	88 2f       	mov	r24, r24
    472e:	90 e0       	ldi	r25, 0x00	; 0
    4730:	81 70       	andi	r24, 0x01	; 1
    4732:	90 70       	andi	r25, 0x00	; 0
    4734:	88 23       	and	r24, r24
    4736:	29 f0       	breq	.+10     	; 0x4742 <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4738:	8a 81       	ldd	r24, Y+2	; 0x02
    473a:	9b 81       	ldd	r25, Y+3	; 0x03
    473c:	02 96       	adiw	r24, 0x02	; 2
    473e:	9b 83       	std	Y+3, r25	; 0x03
    4740:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4742:	88 85       	ldd	r24, Y+8	; 0x08
    4744:	99 85       	ldd	r25, Y+9	; 0x09
    4746:	0e 94 0f 22 	call	0x441e	; 0x441e <xStreamBufferSpacesAvailable>
    474a:	9d 83       	std	Y+5, r25	; 0x05
    474c:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    474e:	88 85       	ldd	r24, Y+8	; 0x08
    4750:	99 85       	ldd	r25, Y+9	; 0x09
    4752:	2c 85       	ldd	r18, Y+12	; 0x0c
    4754:	3d 85       	ldd	r19, Y+13	; 0x0d
    4756:	4e 85       	ldd	r20, Y+14	; 0x0e
    4758:	5f 85       	ldd	r21, Y+15	; 0x0f
    475a:	ec 81       	ldd	r30, Y+4	; 0x04
    475c:	fd 81       	ldd	r31, Y+5	; 0x05
    475e:	aa 81       	ldd	r26, Y+2	; 0x02
    4760:	bb 81       	ldd	r27, Y+3	; 0x03
    4762:	b9 01       	movw	r22, r18
    4764:	9f 01       	movw	r18, r30
    4766:	8d 01       	movw	r16, r26
    4768:	0e 94 f5 23 	call	0x47ea	; 0x47ea <prvWriteMessageToBuffer>
    476c:	9f 83       	std	Y+7, r25	; 0x07
    476e:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    4770:	8e 81       	ldd	r24, Y+6	; 0x06
    4772:	9f 81       	ldd	r25, Y+7	; 0x07
    4774:	00 97       	sbiw	r24, 0x00	; 0
    4776:	41 f1       	breq	.+80     	; 0x47c8 <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4778:	88 85       	ldd	r24, Y+8	; 0x08
    477a:	99 85       	ldd	r25, Y+9	; 0x09
    477c:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    4780:	9c 01       	movw	r18, r24
    4782:	e8 85       	ldd	r30, Y+8	; 0x08
    4784:	f9 85       	ldd	r31, Y+9	; 0x09
    4786:	86 81       	ldd	r24, Z+6	; 0x06
    4788:	97 81       	ldd	r25, Z+7	; 0x07
    478a:	28 17       	cp	r18, r24
    478c:	39 07       	cpc	r19, r25
    478e:	e0 f0       	brcs	.+56     	; 0x47c8 <xStreamBufferSendFromISR+0xe2>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4790:	19 82       	std	Y+1, r1	; 0x01
    4792:	e8 85       	ldd	r30, Y+8	; 0x08
    4794:	f9 85       	ldd	r31, Y+9	; 0x09
    4796:	80 85       	ldd	r24, Z+8	; 0x08
    4798:	91 85       	ldd	r25, Z+9	; 0x09
    479a:	00 97       	sbiw	r24, 0x00	; 0
    479c:	a9 f0       	breq	.+42     	; 0x47c8 <xStreamBufferSendFromISR+0xe2>
    479e:	e8 85       	ldd	r30, Y+8	; 0x08
    47a0:	f9 85       	ldd	r31, Y+9	; 0x09
    47a2:	80 85       	ldd	r24, Z+8	; 0x08
    47a4:	91 85       	ldd	r25, Z+9	; 0x09
    47a6:	e8 89       	ldd	r30, Y+16	; 0x10
    47a8:	f9 89       	ldd	r31, Y+17	; 0x11
    47aa:	60 e0       	ldi	r22, 0x00	; 0
    47ac:	20 e0       	ldi	r18, 0x00	; 0
    47ae:	30 e0       	ldi	r19, 0x00	; 0
    47b0:	40 e0       	ldi	r20, 0x00	; 0
    47b2:	50 e0       	ldi	r21, 0x00	; 0
    47b4:	00 e0       	ldi	r16, 0x00	; 0
    47b6:	ee 24       	eor	r14, r14
    47b8:	ff 24       	eor	r15, r15
    47ba:	6f 01       	movw	r12, r30
    47bc:	0e 94 8f 39 	call	0x731e	; 0x731e <xTaskGenericNotifyFromISR>
    47c0:	e8 85       	ldd	r30, Y+8	; 0x08
    47c2:	f9 85       	ldd	r31, Y+9	; 0x09
    47c4:	11 86       	std	Z+9, r1	; 0x09
    47c6:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    47c8:	8e 81       	ldd	r24, Y+6	; 0x06
    47ca:	9f 81       	ldd	r25, Y+7	; 0x07
}
    47cc:	61 96       	adiw	r28, 0x11	; 17
    47ce:	0f b6       	in	r0, 0x3f	; 63
    47d0:	f8 94       	cli
    47d2:	de bf       	out	0x3e, r29	; 62
    47d4:	0f be       	out	0x3f, r0	; 63
    47d6:	cd bf       	out	0x3d, r28	; 61
    47d8:	cf 91       	pop	r28
    47da:	df 91       	pop	r29
    47dc:	1f 91       	pop	r17
    47de:	0f 91       	pop	r16
    47e0:	ff 90       	pop	r15
    47e2:	ef 90       	pop	r14
    47e4:	df 90       	pop	r13
    47e6:	cf 90       	pop	r12
    47e8:	08 95       	ret

000047ea <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    47ea:	0f 93       	push	r16
    47ec:	1f 93       	push	r17
    47ee:	df 93       	push	r29
    47f0:	cf 93       	push	r28
    47f2:	cd b7       	in	r28, 0x3d	; 61
    47f4:	de b7       	in	r29, 0x3e	; 62
    47f6:	62 97       	sbiw	r28, 0x12	; 18
    47f8:	0f b6       	in	r0, 0x3f	; 63
    47fa:	f8 94       	cli
    47fc:	de bf       	out	0x3e, r29	; 62
    47fe:	0f be       	out	0x3f, r0	; 63
    4800:	cd bf       	out	0x3d, r28	; 61
    4802:	9e 83       	std	Y+6, r25	; 0x06
    4804:	8d 83       	std	Y+5, r24	; 0x05
    4806:	78 87       	std	Y+8, r23	; 0x08
    4808:	6f 83       	std	Y+7, r22	; 0x07
    480a:	5a 87       	std	Y+10, r21	; 0x0a
    480c:	49 87       	std	Y+9, r20	; 0x09
    480e:	3c 87       	std	Y+12, r19	; 0x0c
    4810:	2b 87       	std	Y+11, r18	; 0x0b
    4812:	1e 87       	std	Y+14, r17	; 0x0e
    4814:	0d 87       	std	Y+13, r16	; 0x0d
    size_t xNextHead = pxStreamBuffer->xHead;
    4816:	ed 81       	ldd	r30, Y+5	; 0x05
    4818:	fe 81       	ldd	r31, Y+6	; 0x06
    481a:	82 81       	ldd	r24, Z+2	; 0x02
    481c:	93 81       	ldd	r25, Z+3	; 0x03
    481e:	9a 83       	std	Y+2, r25	; 0x02
    4820:	89 83       	std	Y+1, r24	; 0x01
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4822:	ed 81       	ldd	r30, Y+5	; 0x05
    4824:	fe 81       	ldd	r31, Y+6	; 0x06
    4826:	86 85       	ldd	r24, Z+14	; 0x0e
    4828:	88 2f       	mov	r24, r24
    482a:	90 e0       	ldi	r25, 0x00	; 0
    482c:	81 70       	andi	r24, 0x01	; 1
    482e:	90 70       	andi	r25, 0x00	; 0
    4830:	88 23       	and	r24, r24
    4832:	f1 f0       	breq	.+60     	; 0x4870 <prvWriteMessageToBuffer+0x86>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    4834:	89 85       	ldd	r24, Y+9	; 0x09
    4836:	9a 85       	ldd	r25, Y+10	; 0x0a
    4838:	9c 83       	std	Y+4, r25	; 0x04
    483a:	8b 83       	std	Y+3, r24	; 0x03

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    483c:	2b 85       	ldd	r18, Y+11	; 0x0b
    483e:	3c 85       	ldd	r19, Y+12	; 0x0c
    4840:	8d 85       	ldd	r24, Y+13	; 0x0d
    4842:	9e 85       	ldd	r25, Y+14	; 0x0e
    4844:	28 17       	cp	r18, r24
    4846:	39 07       	cpc	r19, r25
    4848:	80 f0       	brcs	.+32     	; 0x486a <prvWriteMessageToBuffer+0x80>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    484a:	9e 01       	movw	r18, r28
    484c:	2d 5f       	subi	r18, 0xFD	; 253
    484e:	3f 4f       	sbci	r19, 0xFF	; 255
    4850:	8d 81       	ldd	r24, Y+5	; 0x05
    4852:	9e 81       	ldd	r25, Y+6	; 0x06
    4854:	e9 81       	ldd	r30, Y+1	; 0x01
    4856:	fa 81       	ldd	r31, Y+2	; 0x02
    4858:	b9 01       	movw	r22, r18
    485a:	42 e0       	ldi	r20, 0x02	; 2
    485c:	50 e0       	ldi	r21, 0x00	; 0
    485e:	9f 01       	movw	r18, r30
    4860:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <prvWriteBytesToBuffer>
    4864:	9a 83       	std	Y+2, r25	; 0x02
    4866:	89 83       	std	Y+1, r24	; 0x01
    4868:	1a c0       	rjmp	.+52     	; 0x489e <prvWriteMessageToBuffer+0xb4>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    486a:	1a 86       	std	Y+10, r1	; 0x0a
    486c:	19 86       	std	Y+9, r1	; 0x09
    486e:	17 c0       	rjmp	.+46     	; 0x489e <prvWriteMessageToBuffer+0xb4>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    4870:	29 85       	ldd	r18, Y+9	; 0x09
    4872:	3a 85       	ldd	r19, Y+10	; 0x0a
    4874:	3a 8b       	std	Y+18, r19	; 0x12
    4876:	29 8b       	std	Y+17, r18	; 0x11
    4878:	8b 85       	ldd	r24, Y+11	; 0x0b
    487a:	9c 85       	ldd	r25, Y+12	; 0x0c
    487c:	98 8b       	std	Y+16, r25	; 0x10
    487e:	8f 87       	std	Y+15, r24	; 0x0f
    4880:	2f 85       	ldd	r18, Y+15	; 0x0f
    4882:	38 89       	ldd	r19, Y+16	; 0x10
    4884:	89 89       	ldd	r24, Y+17	; 0x11
    4886:	9a 89       	ldd	r25, Y+18	; 0x12
    4888:	82 17       	cp	r24, r18
    488a:	93 07       	cpc	r25, r19
    488c:	20 f4       	brcc	.+8      	; 0x4896 <prvWriteMessageToBuffer+0xac>
    488e:	29 89       	ldd	r18, Y+17	; 0x11
    4890:	3a 89       	ldd	r19, Y+18	; 0x12
    4892:	38 8b       	std	Y+16, r19	; 0x10
    4894:	2f 87       	std	Y+15, r18	; 0x0f
    4896:	8f 85       	ldd	r24, Y+15	; 0x0f
    4898:	98 89       	ldd	r25, Y+16	; 0x10
    489a:	9a 87       	std	Y+10, r25	; 0x0a
    489c:	89 87       	std	Y+9, r24	; 0x09
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    489e:	89 85       	ldd	r24, Y+9	; 0x09
    48a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    48a2:	00 97       	sbiw	r24, 0x00	; 0
    48a4:	89 f0       	breq	.+34     	; 0x48c8 <prvWriteMessageToBuffer+0xde>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    48a6:	4f 81       	ldd	r20, Y+7	; 0x07
    48a8:	58 85       	ldd	r21, Y+8	; 0x08
    48aa:	8d 81       	ldd	r24, Y+5	; 0x05
    48ac:	9e 81       	ldd	r25, Y+6	; 0x06
    48ae:	29 85       	ldd	r18, Y+9	; 0x09
    48b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    48b2:	e9 81       	ldd	r30, Y+1	; 0x01
    48b4:	fa 81       	ldd	r31, Y+2	; 0x02
    48b6:	ba 01       	movw	r22, r20
    48b8:	a9 01       	movw	r20, r18
    48ba:	9f 01       	movw	r18, r30
    48bc:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <prvWriteBytesToBuffer>
    48c0:	ed 81       	ldd	r30, Y+5	; 0x05
    48c2:	fe 81       	ldd	r31, Y+6	; 0x06
    48c4:	93 83       	std	Z+3, r25	; 0x03
    48c6:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    48c8:	89 85       	ldd	r24, Y+9	; 0x09
    48ca:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    48cc:	62 96       	adiw	r28, 0x12	; 18
    48ce:	0f b6       	in	r0, 0x3f	; 63
    48d0:	f8 94       	cli
    48d2:	de bf       	out	0x3e, r29	; 62
    48d4:	0f be       	out	0x3f, r0	; 63
    48d6:	cd bf       	out	0x3d, r28	; 61
    48d8:	cf 91       	pop	r28
    48da:	df 91       	pop	r29
    48dc:	1f 91       	pop	r17
    48de:	0f 91       	pop	r16
    48e0:	08 95       	ret

000048e2 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    48e2:	cf 92       	push	r12
    48e4:	df 92       	push	r13
    48e6:	ef 92       	push	r14
    48e8:	ff 92       	push	r15
    48ea:	0f 93       	push	r16
    48ec:	1f 93       	push	r17
    48ee:	df 93       	push	r29
    48f0:	cf 93       	push	r28
    48f2:	cd b7       	in	r28, 0x3d	; 61
    48f4:	de b7       	in	r29, 0x3e	; 62
    48f6:	60 97       	sbiw	r28, 0x10	; 16
    48f8:	0f b6       	in	r0, 0x3f	; 63
    48fa:	f8 94       	cli
    48fc:	de bf       	out	0x3e, r29	; 62
    48fe:	0f be       	out	0x3f, r0	; 63
    4900:	cd bf       	out	0x3d, r28	; 61
    4902:	9a 87       	std	Y+10, r25	; 0x0a
    4904:	89 87       	std	Y+9, r24	; 0x09
    4906:	7c 87       	std	Y+12, r23	; 0x0c
    4908:	6b 87       	std	Y+11, r22	; 0x0b
    490a:	5e 87       	std	Y+14, r21	; 0x0e
    490c:	4d 87       	std	Y+13, r20	; 0x0d
    490e:	38 8b       	std	Y+16, r19	; 0x10
    4910:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4912:	89 85       	ldd	r24, Y+9	; 0x09
    4914:	9a 85       	ldd	r25, Y+10	; 0x0a
    4916:	98 87       	std	Y+8, r25	; 0x08
    4918:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    491a:	1e 82       	std	Y+6, r1	; 0x06
    491c:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    491e:	ef 81       	ldd	r30, Y+7	; 0x07
    4920:	f8 85       	ldd	r31, Y+8	; 0x08
    4922:	86 85       	ldd	r24, Z+14	; 0x0e
    4924:	88 2f       	mov	r24, r24
    4926:	90 e0       	ldi	r25, 0x00	; 0
    4928:	81 70       	andi	r24, 0x01	; 1
    492a:	90 70       	andi	r25, 0x00	; 0
    492c:	88 23       	and	r24, r24
    492e:	29 f0       	breq	.+10     	; 0x493a <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4930:	82 e0       	ldi	r24, 0x02	; 2
    4932:	90 e0       	ldi	r25, 0x00	; 0
    4934:	9a 83       	std	Y+2, r25	; 0x02
    4936:	89 83       	std	Y+1, r24	; 0x01
    4938:	02 c0       	rjmp	.+4      	; 0x493e <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    493a:	1a 82       	std	Y+2, r1	; 0x02
    493c:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    493e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4940:	98 89       	ldd	r25, Y+16	; 0x10
    4942:	00 97       	sbiw	r24, 0x00	; 0
    4944:	09 f4       	brne	.+2      	; 0x4948 <xStreamBufferReceive+0x66>
    4946:	3f c0       	rjmp	.+126    	; 0x49c6 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    4948:	0f b6       	in	r0, 0x3f	; 63
    494a:	f8 94       	cli
    494c:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    494e:	8f 81       	ldd	r24, Y+7	; 0x07
    4950:	98 85       	ldd	r25, Y+8	; 0x08
    4952:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    4956:	9c 83       	std	Y+4, r25	; 0x04
    4958:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    495a:	2b 81       	ldd	r18, Y+3	; 0x03
    495c:	3c 81       	ldd	r19, Y+4	; 0x04
    495e:	89 81       	ldd	r24, Y+1	; 0x01
    4960:	9a 81       	ldd	r25, Y+2	; 0x02
    4962:	82 17       	cp	r24, r18
    4964:	93 07       	cpc	r25, r19
    4966:	58 f0       	brcs	.+22     	; 0x497e <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    4968:	80 e0       	ldi	r24, 0x00	; 0
    496a:	90 e0       	ldi	r25, 0x00	; 0
    496c:	60 e0       	ldi	r22, 0x00	; 0
    496e:	0e 94 de 3c 	call	0x79bc	; 0x79bc <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    4972:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xTaskGetCurrentTaskHandle>
    4976:	ef 81       	ldd	r30, Y+7	; 0x07
    4978:	f8 85       	ldd	r31, Y+8	; 0x08
    497a:	91 87       	std	Z+9, r25	; 0x09
    497c:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    497e:	0f 90       	pop	r0
    4980:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    4982:	2b 81       	ldd	r18, Y+3	; 0x03
    4984:	3c 81       	ldd	r19, Y+4	; 0x04
    4986:	89 81       	ldd	r24, Y+1	; 0x01
    4988:	9a 81       	ldd	r25, Y+2	; 0x02
    498a:	82 17       	cp	r24, r18
    498c:	93 07       	cpc	r25, r19
    498e:	08 f1       	brcs	.+66     	; 0x49d2 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4990:	ef 85       	ldd	r30, Y+15	; 0x0f
    4992:	f8 89       	ldd	r31, Y+16	; 0x10
    4994:	80 e0       	ldi	r24, 0x00	; 0
    4996:	40 e0       	ldi	r20, 0x00	; 0
    4998:	50 e0       	ldi	r21, 0x00	; 0
    499a:	60 e0       	ldi	r22, 0x00	; 0
    499c:	70 e0       	ldi	r23, 0x00	; 0
    499e:	00 e0       	ldi	r16, 0x00	; 0
    49a0:	10 e0       	ldi	r17, 0x00	; 0
    49a2:	20 e0       	ldi	r18, 0x00	; 0
    49a4:	30 e0       	ldi	r19, 0x00	; 0
    49a6:	ee 24       	eor	r14, r14
    49a8:	ff 24       	eor	r15, r15
    49aa:	6f 01       	movw	r12, r30
    49ac:	0e 94 da 36 	call	0x6db4	; 0x6db4 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    49b0:	ef 81       	ldd	r30, Y+7	; 0x07
    49b2:	f8 85       	ldd	r31, Y+8	; 0x08
    49b4:	11 86       	std	Z+9, r1	; 0x09
    49b6:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    49b8:	8f 81       	ldd	r24, Y+7	; 0x07
    49ba:	98 85       	ldd	r25, Y+8	; 0x08
    49bc:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    49c0:	9c 83       	std	Y+4, r25	; 0x04
    49c2:	8b 83       	std	Y+3, r24	; 0x03
    49c4:	06 c0       	rjmp	.+12     	; 0x49d2 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    49c6:	8f 81       	ldd	r24, Y+7	; 0x07
    49c8:	98 85       	ldd	r25, Y+8	; 0x08
    49ca:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    49ce:	9c 83       	std	Y+4, r25	; 0x04
    49d0:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    49d2:	2b 81       	ldd	r18, Y+3	; 0x03
    49d4:	3c 81       	ldd	r19, Y+4	; 0x04
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	9a 81       	ldd	r25, Y+2	; 0x02
    49da:	82 17       	cp	r24, r18
    49dc:	93 07       	cpc	r25, r19
    49de:	70 f5       	brcc	.+92     	; 0x4a3c <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    49e0:	8f 81       	ldd	r24, Y+7	; 0x07
    49e2:	98 85       	ldd	r25, Y+8	; 0x08
    49e4:	2b 85       	ldd	r18, Y+11	; 0x0b
    49e6:	3c 85       	ldd	r19, Y+12	; 0x0c
    49e8:	4d 85       	ldd	r20, Y+13	; 0x0d
    49ea:	5e 85       	ldd	r21, Y+14	; 0x0e
    49ec:	eb 81       	ldd	r30, Y+3	; 0x03
    49ee:	fc 81       	ldd	r31, Y+4	; 0x04
    49f0:	b9 01       	movw	r22, r18
    49f2:	9f 01       	movw	r18, r30
    49f4:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <prvReadMessageFromBuffer>
    49f8:	9e 83       	std	Y+6, r25	; 0x06
    49fa:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    49fc:	8d 81       	ldd	r24, Y+5	; 0x05
    49fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4a00:	00 97       	sbiw	r24, 0x00	; 0
    4a02:	e1 f0       	breq	.+56     	; 0x4a3c <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    4a04:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
    4a08:	e9 85       	ldd	r30, Y+9	; 0x09
    4a0a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4a0c:	82 85       	ldd	r24, Z+10	; 0x0a
    4a0e:	93 85       	ldd	r25, Z+11	; 0x0b
    4a10:	00 97       	sbiw	r24, 0x00	; 0
    4a12:	91 f0       	breq	.+36     	; 0x4a38 <xStreamBufferReceive+0x156>
    4a14:	e9 85       	ldd	r30, Y+9	; 0x09
    4a16:	fa 85       	ldd	r31, Y+10	; 0x0a
    4a18:	82 85       	ldd	r24, Z+10	; 0x0a
    4a1a:	93 85       	ldd	r25, Z+11	; 0x0b
    4a1c:	60 e0       	ldi	r22, 0x00	; 0
    4a1e:	20 e0       	ldi	r18, 0x00	; 0
    4a20:	30 e0       	ldi	r19, 0x00	; 0
    4a22:	40 e0       	ldi	r20, 0x00	; 0
    4a24:	50 e0       	ldi	r21, 0x00	; 0
    4a26:	00 e0       	ldi	r16, 0x00	; 0
    4a28:	ee 24       	eor	r14, r14
    4a2a:	ff 24       	eor	r15, r15
    4a2c:	0e 94 d1 37 	call	0x6fa2	; 0x6fa2 <xTaskGenericNotify>
    4a30:	e9 85       	ldd	r30, Y+9	; 0x09
    4a32:	fa 85       	ldd	r31, Y+10	; 0x0a
    4a34:	13 86       	std	Z+11, r1	; 0x0b
    4a36:	12 86       	std	Z+10, r1	; 0x0a
    4a38:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    4a3c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a3e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4a40:	60 96       	adiw	r28, 0x10	; 16
    4a42:	0f b6       	in	r0, 0x3f	; 63
    4a44:	f8 94       	cli
    4a46:	de bf       	out	0x3e, r29	; 62
    4a48:	0f be       	out	0x3f, r0	; 63
    4a4a:	cd bf       	out	0x3d, r28	; 61
    4a4c:	cf 91       	pop	r28
    4a4e:	df 91       	pop	r29
    4a50:	1f 91       	pop	r17
    4a52:	0f 91       	pop	r16
    4a54:	ff 90       	pop	r15
    4a56:	ef 90       	pop	r14
    4a58:	df 90       	pop	r13
    4a5a:	cf 90       	pop	r12
    4a5c:	08 95       	ret

00004a5e <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    4a5e:	df 93       	push	r29
    4a60:	cf 93       	push	r28
    4a62:	cd b7       	in	r28, 0x3d	; 61
    4a64:	de b7       	in	r29, 0x3e	; 62
    4a66:	2a 97       	sbiw	r28, 0x0a	; 10
    4a68:	0f b6       	in	r0, 0x3f	; 63
    4a6a:	f8 94       	cli
    4a6c:	de bf       	out	0x3e, r29	; 62
    4a6e:	0f be       	out	0x3f, r0	; 63
    4a70:	cd bf       	out	0x3d, r28	; 61
    4a72:	9a 87       	std	Y+10, r25	; 0x0a
    4a74:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4a76:	89 85       	ldd	r24, Y+9	; 0x09
    4a78:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a7a:	9e 83       	std	Y+6, r25	; 0x06
    4a7c:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4a7e:	ed 81       	ldd	r30, Y+5	; 0x05
    4a80:	fe 81       	ldd	r31, Y+6	; 0x06
    4a82:	86 85       	ldd	r24, Z+14	; 0x0e
    4a84:	88 2f       	mov	r24, r24
    4a86:	90 e0       	ldi	r25, 0x00	; 0
    4a88:	81 70       	andi	r24, 0x01	; 1
    4a8a:	90 70       	andi	r25, 0x00	; 0
    4a8c:	88 23       	and	r24, r24
    4a8e:	19 f1       	breq	.+70     	; 0x4ad6 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4a90:	8d 81       	ldd	r24, Y+5	; 0x05
    4a92:	9e 81       	ldd	r25, Y+6	; 0x06
    4a94:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    4a98:	9a 83       	std	Y+2, r25	; 0x02
    4a9a:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    4a9c:	89 81       	ldd	r24, Y+1	; 0x01
    4a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    4aa0:	83 30       	cpi	r24, 0x03	; 3
    4aa2:	91 05       	cpc	r25, r1
    4aa4:	a8 f0       	brcs	.+42     	; 0x4ad0 <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    4aa6:	9e 01       	movw	r18, r28
    4aa8:	29 5f       	subi	r18, 0xF9	; 249
    4aaa:	3f 4f       	sbci	r19, 0xFF	; 255
    4aac:	ed 81       	ldd	r30, Y+5	; 0x05
    4aae:	fe 81       	ldd	r31, Y+6	; 0x06
    4ab0:	01 90       	ld	r0, Z+
    4ab2:	f0 81       	ld	r31, Z
    4ab4:	e0 2d       	mov	r30, r0
    4ab6:	8d 81       	ldd	r24, Y+5	; 0x05
    4ab8:	9e 81       	ldd	r25, Y+6	; 0x06
    4aba:	b9 01       	movw	r22, r18
    4abc:	42 e0       	ldi	r20, 0x02	; 2
    4abe:	50 e0       	ldi	r21, 0x00	; 0
    4ac0:	9f 01       	movw	r18, r30
    4ac2:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    4ac6:	8f 81       	ldd	r24, Y+7	; 0x07
    4ac8:	98 85       	ldd	r25, Y+8	; 0x08
    4aca:	9c 83       	std	Y+4, r25	; 0x04
    4acc:	8b 83       	std	Y+3, r24	; 0x03
    4ace:	05 c0       	rjmp	.+10     	; 0x4ada <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    4ad0:	1c 82       	std	Y+4, r1	; 0x04
    4ad2:	1b 82       	std	Y+3, r1	; 0x03
    4ad4:	02 c0       	rjmp	.+4      	; 0x4ada <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    4ad6:	1c 82       	std	Y+4, r1	; 0x04
    4ad8:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    4ada:	8b 81       	ldd	r24, Y+3	; 0x03
    4adc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4ade:	2a 96       	adiw	r28, 0x0a	; 10
    4ae0:	0f b6       	in	r0, 0x3f	; 63
    4ae2:	f8 94       	cli
    4ae4:	de bf       	out	0x3e, r29	; 62
    4ae6:	0f be       	out	0x3f, r0	; 63
    4ae8:	cd bf       	out	0x3d, r28	; 61
    4aea:	cf 91       	pop	r28
    4aec:	df 91       	pop	r29
    4aee:	08 95       	ret

00004af0 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    4af0:	cf 92       	push	r12
    4af2:	df 92       	push	r13
    4af4:	ef 92       	push	r14
    4af6:	ff 92       	push	r15
    4af8:	0f 93       	push	r16
    4afa:	df 93       	push	r29
    4afc:	cf 93       	push	r28
    4afe:	cd b7       	in	r28, 0x3d	; 61
    4b00:	de b7       	in	r29, 0x3e	; 62
    4b02:	61 97       	sbiw	r28, 0x11	; 17
    4b04:	0f b6       	in	r0, 0x3f	; 63
    4b06:	f8 94       	cli
    4b08:	de bf       	out	0x3e, r29	; 62
    4b0a:	0f be       	out	0x3f, r0	; 63
    4b0c:	cd bf       	out	0x3d, r28	; 61
    4b0e:	9b 87       	std	Y+11, r25	; 0x0b
    4b10:	8a 87       	std	Y+10, r24	; 0x0a
    4b12:	7d 87       	std	Y+13, r23	; 0x0d
    4b14:	6c 87       	std	Y+12, r22	; 0x0c
    4b16:	5f 87       	std	Y+15, r21	; 0x0f
    4b18:	4e 87       	std	Y+14, r20	; 0x0e
    4b1a:	39 8b       	std	Y+17, r19	; 0x11
    4b1c:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4b1e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b20:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b22:	99 87       	std	Y+9, r25	; 0x09
    4b24:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    4b26:	1f 82       	std	Y+7, r1	; 0x07
    4b28:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4b2a:	e8 85       	ldd	r30, Y+8	; 0x08
    4b2c:	f9 85       	ldd	r31, Y+9	; 0x09
    4b2e:	86 85       	ldd	r24, Z+14	; 0x0e
    4b30:	88 2f       	mov	r24, r24
    4b32:	90 e0       	ldi	r25, 0x00	; 0
    4b34:	81 70       	andi	r24, 0x01	; 1
    4b36:	90 70       	andi	r25, 0x00	; 0
    4b38:	88 23       	and	r24, r24
    4b3a:	29 f0       	breq	.+10     	; 0x4b46 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4b3c:	82 e0       	ldi	r24, 0x02	; 2
    4b3e:	90 e0       	ldi	r25, 0x00	; 0
    4b40:	9b 83       	std	Y+3, r25	; 0x03
    4b42:	8a 83       	std	Y+2, r24	; 0x02
    4b44:	02 c0       	rjmp	.+4      	; 0x4b4a <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    4b46:	1b 82       	std	Y+3, r1	; 0x03
    4b48:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4b4a:	88 85       	ldd	r24, Y+8	; 0x08
    4b4c:	99 85       	ldd	r25, Y+9	; 0x09
    4b4e:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvBytesInBuffer>
    4b52:	9d 83       	std	Y+5, r25	; 0x05
    4b54:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    4b56:	2c 81       	ldd	r18, Y+4	; 0x04
    4b58:	3d 81       	ldd	r19, Y+5	; 0x05
    4b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b5c:	9b 81       	ldd	r25, Y+3	; 0x03
    4b5e:	82 17       	cp	r24, r18
    4b60:	93 07       	cpc	r25, r19
    4b62:	70 f5       	brcc	.+92     	; 0x4bc0 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    4b64:	88 85       	ldd	r24, Y+8	; 0x08
    4b66:	99 85       	ldd	r25, Y+9	; 0x09
    4b68:	2c 85       	ldd	r18, Y+12	; 0x0c
    4b6a:	3d 85       	ldd	r19, Y+13	; 0x0d
    4b6c:	4e 85       	ldd	r20, Y+14	; 0x0e
    4b6e:	5f 85       	ldd	r21, Y+15	; 0x0f
    4b70:	ec 81       	ldd	r30, Y+4	; 0x04
    4b72:	fd 81       	ldd	r31, Y+5	; 0x05
    4b74:	b9 01       	movw	r22, r18
    4b76:	9f 01       	movw	r18, r30
    4b78:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <prvReadMessageFromBuffer>
    4b7c:	9f 83       	std	Y+7, r25	; 0x07
    4b7e:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    4b80:	8e 81       	ldd	r24, Y+6	; 0x06
    4b82:	9f 81       	ldd	r25, Y+7	; 0x07
    4b84:	00 97       	sbiw	r24, 0x00	; 0
    4b86:	e1 f0       	breq	.+56     	; 0x4bc0 <xStreamBufferReceiveFromISR+0xd0>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4b88:	19 82       	std	Y+1, r1	; 0x01
    4b8a:	e8 85       	ldd	r30, Y+8	; 0x08
    4b8c:	f9 85       	ldd	r31, Y+9	; 0x09
    4b8e:	82 85       	ldd	r24, Z+10	; 0x0a
    4b90:	93 85       	ldd	r25, Z+11	; 0x0b
    4b92:	00 97       	sbiw	r24, 0x00	; 0
    4b94:	a9 f0       	breq	.+42     	; 0x4bc0 <xStreamBufferReceiveFromISR+0xd0>
    4b96:	e8 85       	ldd	r30, Y+8	; 0x08
    4b98:	f9 85       	ldd	r31, Y+9	; 0x09
    4b9a:	82 85       	ldd	r24, Z+10	; 0x0a
    4b9c:	93 85       	ldd	r25, Z+11	; 0x0b
    4b9e:	e8 89       	ldd	r30, Y+16	; 0x10
    4ba0:	f9 89       	ldd	r31, Y+17	; 0x11
    4ba2:	60 e0       	ldi	r22, 0x00	; 0
    4ba4:	20 e0       	ldi	r18, 0x00	; 0
    4ba6:	30 e0       	ldi	r19, 0x00	; 0
    4ba8:	40 e0       	ldi	r20, 0x00	; 0
    4baa:	50 e0       	ldi	r21, 0x00	; 0
    4bac:	00 e0       	ldi	r16, 0x00	; 0
    4bae:	ee 24       	eor	r14, r14
    4bb0:	ff 24       	eor	r15, r15
    4bb2:	6f 01       	movw	r12, r30
    4bb4:	0e 94 8f 39 	call	0x731e	; 0x731e <xTaskGenericNotifyFromISR>
    4bb8:	e8 85       	ldd	r30, Y+8	; 0x08
    4bba:	f9 85       	ldd	r31, Y+9	; 0x09
    4bbc:	13 86       	std	Z+11, r1	; 0x0b
    4bbe:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    4bc0:	8e 81       	ldd	r24, Y+6	; 0x06
    4bc2:	9f 81       	ldd	r25, Y+7	; 0x07
}
    4bc4:	61 96       	adiw	r28, 0x11	; 17
    4bc6:	0f b6       	in	r0, 0x3f	; 63
    4bc8:	f8 94       	cli
    4bca:	de bf       	out	0x3e, r29	; 62
    4bcc:	0f be       	out	0x3f, r0	; 63
    4bce:	cd bf       	out	0x3d, r28	; 61
    4bd0:	cf 91       	pop	r28
    4bd2:	df 91       	pop	r29
    4bd4:	0f 91       	pop	r16
    4bd6:	ff 90       	pop	r15
    4bd8:	ef 90       	pop	r14
    4bda:	df 90       	pop	r13
    4bdc:	cf 90       	pop	r12
    4bde:	08 95       	ret

00004be0 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    4be0:	df 93       	push	r29
    4be2:	cf 93       	push	r28
    4be4:	cd b7       	in	r28, 0x3d	; 61
    4be6:	de b7       	in	r29, 0x3e	; 62
    4be8:	64 97       	sbiw	r28, 0x14	; 20
    4bea:	0f b6       	in	r0, 0x3f	; 63
    4bec:	f8 94       	cli
    4bee:	de bf       	out	0x3e, r29	; 62
    4bf0:	0f be       	out	0x3f, r0	; 63
    4bf2:	cd bf       	out	0x3d, r28	; 61
    4bf4:	9a 87       	std	Y+10, r25	; 0x0a
    4bf6:	89 87       	std	Y+9, r24	; 0x09
    4bf8:	7c 87       	std	Y+12, r23	; 0x0c
    4bfa:	6b 87       	std	Y+11, r22	; 0x0b
    4bfc:	5e 87       	std	Y+14, r21	; 0x0e
    4bfe:	4d 87       	std	Y+13, r20	; 0x0d
    4c00:	38 8b       	std	Y+16, r19	; 0x10
    4c02:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    4c04:	e9 85       	ldd	r30, Y+9	; 0x09
    4c06:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c08:	80 81       	ld	r24, Z
    4c0a:	91 81       	ldd	r25, Z+1	; 0x01
    4c0c:	9a 83       	std	Y+2, r25	; 0x02
    4c0e:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4c10:	e9 85       	ldd	r30, Y+9	; 0x09
    4c12:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c14:	86 85       	ldd	r24, Z+14	; 0x0e
    4c16:	88 2f       	mov	r24, r24
    4c18:	90 e0       	ldi	r25, 0x00	; 0
    4c1a:	81 70       	andi	r24, 0x01	; 1
    4c1c:	90 70       	andi	r25, 0x00	; 0
    4c1e:	88 23       	and	r24, r24
    4c20:	11 f1       	breq	.+68     	; 0x4c66 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    4c22:	9e 01       	movw	r18, r28
    4c24:	29 5f       	subi	r18, 0xF9	; 249
    4c26:	3f 4f       	sbci	r19, 0xFF	; 255
    4c28:	89 85       	ldd	r24, Y+9	; 0x09
    4c2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c30:	b9 01       	movw	r22, r18
    4c32:	42 e0       	ldi	r20, 0x02	; 2
    4c34:	50 e0       	ldi	r21, 0x00	; 0
    4c36:	9f 01       	movw	r18, r30
    4c38:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <prvReadBytesFromBuffer>
    4c3c:	9a 83       	std	Y+2, r25	; 0x02
    4c3e:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    4c40:	8f 81       	ldd	r24, Y+7	; 0x07
    4c42:	98 85       	ldd	r25, Y+8	; 0x08
    4c44:	9c 83       	std	Y+4, r25	; 0x04
    4c46:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4c48:	8f 85       	ldd	r24, Y+15	; 0x0f
    4c4a:	98 89       	ldd	r25, Y+16	; 0x10
    4c4c:	02 97       	sbiw	r24, 0x02	; 2
    4c4e:	98 8b       	std	Y+16, r25	; 0x10
    4c50:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    4c52:	2b 81       	ldd	r18, Y+3	; 0x03
    4c54:	3c 81       	ldd	r19, Y+4	; 0x04
    4c56:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c58:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c5a:	82 17       	cp	r24, r18
    4c5c:	93 07       	cpc	r25, r19
    4c5e:	38 f4       	brcc	.+14     	; 0x4c6e <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    4c60:	1c 82       	std	Y+4, r1	; 0x04
    4c62:	1b 82       	std	Y+3, r1	; 0x03
    4c64:	04 c0       	rjmp	.+8      	; 0x4c6e <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    4c66:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c68:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c6a:	9c 83       	std	Y+4, r25	; 0x04
    4c6c:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    4c6e:	2b 81       	ldd	r18, Y+3	; 0x03
    4c70:	3c 81       	ldd	r19, Y+4	; 0x04
    4c72:	3c 8b       	std	Y+20, r19	; 0x14
    4c74:	2b 8b       	std	Y+19, r18	; 0x13
    4c76:	8f 85       	ldd	r24, Y+15	; 0x0f
    4c78:	98 89       	ldd	r25, Y+16	; 0x10
    4c7a:	9a 8b       	std	Y+18, r25	; 0x12
    4c7c:	89 8b       	std	Y+17, r24	; 0x11
    4c7e:	29 89       	ldd	r18, Y+17	; 0x11
    4c80:	3a 89       	ldd	r19, Y+18	; 0x12
    4c82:	8b 89       	ldd	r24, Y+19	; 0x13
    4c84:	9c 89       	ldd	r25, Y+20	; 0x14
    4c86:	82 17       	cp	r24, r18
    4c88:	93 07       	cpc	r25, r19
    4c8a:	20 f4       	brcc	.+8      	; 0x4c94 <prvReadMessageFromBuffer+0xb4>
    4c8c:	2b 89       	ldd	r18, Y+19	; 0x13
    4c8e:	3c 89       	ldd	r19, Y+20	; 0x14
    4c90:	3a 8b       	std	Y+18, r19	; 0x12
    4c92:	29 8b       	std	Y+17, r18	; 0x11
    4c94:	89 89       	ldd	r24, Y+17	; 0x11
    4c96:	9a 89       	ldd	r25, Y+18	; 0x12
    4c98:	9e 83       	std	Y+6, r25	; 0x06
    4c9a:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    4c9c:	8d 81       	ldd	r24, Y+5	; 0x05
    4c9e:	9e 81       	ldd	r25, Y+6	; 0x06
    4ca0:	00 97       	sbiw	r24, 0x00	; 0
    4ca2:	89 f0       	breq	.+34     	; 0x4cc6 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    4ca4:	4b 85       	ldd	r20, Y+11	; 0x0b
    4ca6:	5c 85       	ldd	r21, Y+12	; 0x0c
    4ca8:	89 85       	ldd	r24, Y+9	; 0x09
    4caa:	9a 85       	ldd	r25, Y+10	; 0x0a
    4cac:	2d 81       	ldd	r18, Y+5	; 0x05
    4cae:	3e 81       	ldd	r19, Y+6	; 0x06
    4cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    4cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    4cb4:	ba 01       	movw	r22, r20
    4cb6:	a9 01       	movw	r20, r18
    4cb8:	9f 01       	movw	r18, r30
    4cba:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <prvReadBytesFromBuffer>
    4cbe:	e9 85       	ldd	r30, Y+9	; 0x09
    4cc0:	fa 85       	ldd	r31, Y+10	; 0x0a
    4cc2:	91 83       	std	Z+1, r25	; 0x01
    4cc4:	80 83       	st	Z, r24
    }

    return xCount;
    4cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    4cc8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4cca:	64 96       	adiw	r28, 0x14	; 20
    4ccc:	0f b6       	in	r0, 0x3f	; 63
    4cce:	f8 94       	cli
    4cd0:	de bf       	out	0x3e, r29	; 62
    4cd2:	0f be       	out	0x3f, r0	; 63
    4cd4:	cd bf       	out	0x3d, r28	; 61
    4cd6:	cf 91       	pop	r28
    4cd8:	df 91       	pop	r29
    4cda:	08 95       	ret

00004cdc <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    4cdc:	df 93       	push	r29
    4cde:	cf 93       	push	r28
    4ce0:	cd b7       	in	r28, 0x3d	; 61
    4ce2:	de b7       	in	r29, 0x3e	; 62
    4ce4:	27 97       	sbiw	r28, 0x07	; 7
    4ce6:	0f b6       	in	r0, 0x3f	; 63
    4ce8:	f8 94       	cli
    4cea:	de bf       	out	0x3e, r29	; 62
    4cec:	0f be       	out	0x3f, r0	; 63
    4cee:	cd bf       	out	0x3d, r28	; 61
    4cf0:	9f 83       	std	Y+7, r25	; 0x07
    4cf2:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4cf4:	8e 81       	ldd	r24, Y+6	; 0x06
    4cf6:	9f 81       	ldd	r25, Y+7	; 0x07
    4cf8:	9d 83       	std	Y+5, r25	; 0x05
    4cfa:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    4cfc:	ec 81       	ldd	r30, Y+4	; 0x04
    4cfe:	fd 81       	ldd	r31, Y+5	; 0x05
    4d00:	80 81       	ld	r24, Z
    4d02:	91 81       	ldd	r25, Z+1	; 0x01
    4d04:	9a 83       	std	Y+2, r25	; 0x02
    4d06:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    4d08:	ec 81       	ldd	r30, Y+4	; 0x04
    4d0a:	fd 81       	ldd	r31, Y+5	; 0x05
    4d0c:	22 81       	ldd	r18, Z+2	; 0x02
    4d0e:	33 81       	ldd	r19, Z+3	; 0x03
    4d10:	89 81       	ldd	r24, Y+1	; 0x01
    4d12:	9a 81       	ldd	r25, Y+2	; 0x02
    4d14:	28 17       	cp	r18, r24
    4d16:	39 07       	cpc	r19, r25
    4d18:	19 f4       	brne	.+6      	; 0x4d20 <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    4d1a:	81 e0       	ldi	r24, 0x01	; 1
    4d1c:	8b 83       	std	Y+3, r24	; 0x03
    4d1e:	01 c0       	rjmp	.+2      	; 0x4d22 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    4d20:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    4d22:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4d24:	27 96       	adiw	r28, 0x07	; 7
    4d26:	0f b6       	in	r0, 0x3f	; 63
    4d28:	f8 94       	cli
    4d2a:	de bf       	out	0x3e, r29	; 62
    4d2c:	0f be       	out	0x3f, r0	; 63
    4d2e:	cd bf       	out	0x3d, r28	; 61
    4d30:	cf 91       	pop	r28
    4d32:	df 91       	pop	r29
    4d34:	08 95       	ret

00004d36 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    4d36:	df 93       	push	r29
    4d38:	cf 93       	push	r28
    4d3a:	cd b7       	in	r28, 0x3d	; 61
    4d3c:	de b7       	in	r29, 0x3e	; 62
    4d3e:	27 97       	sbiw	r28, 0x07	; 7
    4d40:	0f b6       	in	r0, 0x3f	; 63
    4d42:	f8 94       	cli
    4d44:	de bf       	out	0x3e, r29	; 62
    4d46:	0f be       	out	0x3f, r0	; 63
    4d48:	cd bf       	out	0x3d, r28	; 61
    4d4a:	9f 83       	std	Y+7, r25	; 0x07
    4d4c:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4d4e:	8e 81       	ldd	r24, Y+6	; 0x06
    4d50:	9f 81       	ldd	r25, Y+7	; 0x07
    4d52:	9a 83       	std	Y+2, r25	; 0x02
    4d54:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4d56:	e9 81       	ldd	r30, Y+1	; 0x01
    4d58:	fa 81       	ldd	r31, Y+2	; 0x02
    4d5a:	86 85       	ldd	r24, Z+14	; 0x0e
    4d5c:	88 2f       	mov	r24, r24
    4d5e:	90 e0       	ldi	r25, 0x00	; 0
    4d60:	81 70       	andi	r24, 0x01	; 1
    4d62:	90 70       	andi	r25, 0x00	; 0
    4d64:	88 23       	and	r24, r24
    4d66:	29 f0       	breq	.+10     	; 0x4d72 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4d68:	82 e0       	ldi	r24, 0x02	; 2
    4d6a:	90 e0       	ldi	r25, 0x00	; 0
    4d6c:	9c 83       	std	Y+4, r25	; 0x04
    4d6e:	8b 83       	std	Y+3, r24	; 0x03
    4d70:	02 c0       	rjmp	.+4      	; 0x4d76 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    4d72:	1c 82       	std	Y+4, r1	; 0x04
    4d74:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    4d76:	8e 81       	ldd	r24, Y+6	; 0x06
    4d78:	9f 81       	ldd	r25, Y+7	; 0x07
    4d7a:	0e 94 0f 22 	call	0x441e	; 0x441e <xStreamBufferSpacesAvailable>
    4d7e:	9c 01       	movw	r18, r24
    4d80:	8b 81       	ldd	r24, Y+3	; 0x03
    4d82:	9c 81       	ldd	r25, Y+4	; 0x04
    4d84:	82 17       	cp	r24, r18
    4d86:	93 07       	cpc	r25, r19
    4d88:	18 f0       	brcs	.+6      	; 0x4d90 <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    4d8a:	81 e0       	ldi	r24, 0x01	; 1
    4d8c:	8d 83       	std	Y+5, r24	; 0x05
    4d8e:	01 c0       	rjmp	.+2      	; 0x4d92 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    4d90:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    4d92:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4d94:	27 96       	adiw	r28, 0x07	; 7
    4d96:	0f b6       	in	r0, 0x3f	; 63
    4d98:	f8 94       	cli
    4d9a:	de bf       	out	0x3e, r29	; 62
    4d9c:	0f be       	out	0x3f, r0	; 63
    4d9e:	cd bf       	out	0x3d, r28	; 61
    4da0:	cf 91       	pop	r28
    4da2:	df 91       	pop	r29
    4da4:	08 95       	ret

00004da6 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    4da6:	cf 92       	push	r12
    4da8:	df 92       	push	r13
    4daa:	ef 92       	push	r14
    4dac:	ff 92       	push	r15
    4dae:	0f 93       	push	r16
    4db0:	df 93       	push	r29
    4db2:	cf 93       	push	r28
    4db4:	cd b7       	in	r28, 0x3d	; 61
    4db6:	de b7       	in	r29, 0x3e	; 62
    4db8:	28 97       	sbiw	r28, 0x08	; 8
    4dba:	0f b6       	in	r0, 0x3f	; 63
    4dbc:	f8 94       	cli
    4dbe:	de bf       	out	0x3e, r29	; 62
    4dc0:	0f be       	out	0x3f, r0	; 63
    4dc2:	cd bf       	out	0x3d, r28	; 61
    4dc4:	9e 83       	std	Y+6, r25	; 0x06
    4dc6:	8d 83       	std	Y+5, r24	; 0x05
    4dc8:	78 87       	std	Y+8, r23	; 0x08
    4dca:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4dcc:	8d 81       	ldd	r24, Y+5	; 0x05
    4dce:	9e 81       	ldd	r25, Y+6	; 0x06
    4dd0:	9c 83       	std	Y+4, r25	; 0x04
    4dd2:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4dd4:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    4dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    4dda:	80 85       	ldd	r24, Z+8	; 0x08
    4ddc:	91 85       	ldd	r25, Z+9	; 0x09
    4dde:	00 97       	sbiw	r24, 0x00	; 0
    4de0:	c1 f0       	breq	.+48     	; 0x4e12 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4de2:	eb 81       	ldd	r30, Y+3	; 0x03
    4de4:	fc 81       	ldd	r31, Y+4	; 0x04
    4de6:	80 85       	ldd	r24, Z+8	; 0x08
    4de8:	91 85       	ldd	r25, Z+9	; 0x09
    4dea:	ef 81       	ldd	r30, Y+7	; 0x07
    4dec:	f8 85       	ldd	r31, Y+8	; 0x08
    4dee:	60 e0       	ldi	r22, 0x00	; 0
    4df0:	20 e0       	ldi	r18, 0x00	; 0
    4df2:	30 e0       	ldi	r19, 0x00	; 0
    4df4:	40 e0       	ldi	r20, 0x00	; 0
    4df6:	50 e0       	ldi	r21, 0x00	; 0
    4df8:	00 e0       	ldi	r16, 0x00	; 0
    4dfa:	ee 24       	eor	r14, r14
    4dfc:	ff 24       	eor	r15, r15
    4dfe:	6f 01       	movw	r12, r30
    4e00:	0e 94 8f 39 	call	0x731e	; 0x731e <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4e04:	eb 81       	ldd	r30, Y+3	; 0x03
    4e06:	fc 81       	ldd	r31, Y+4	; 0x04
    4e08:	11 86       	std	Z+9, r1	; 0x09
    4e0a:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    4e0c:	81 e0       	ldi	r24, 0x01	; 1
    4e0e:	8a 83       	std	Y+2, r24	; 0x02
    4e10:	01 c0       	rjmp	.+2      	; 0x4e14 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    4e12:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4e14:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4e16:	28 96       	adiw	r28, 0x08	; 8
    4e18:	0f b6       	in	r0, 0x3f	; 63
    4e1a:	f8 94       	cli
    4e1c:	de bf       	out	0x3e, r29	; 62
    4e1e:	0f be       	out	0x3f, r0	; 63
    4e20:	cd bf       	out	0x3d, r28	; 61
    4e22:	cf 91       	pop	r28
    4e24:	df 91       	pop	r29
    4e26:	0f 91       	pop	r16
    4e28:	ff 90       	pop	r15
    4e2a:	ef 90       	pop	r14
    4e2c:	df 90       	pop	r13
    4e2e:	cf 90       	pop	r12
    4e30:	08 95       	ret

00004e32 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    4e32:	cf 92       	push	r12
    4e34:	df 92       	push	r13
    4e36:	ef 92       	push	r14
    4e38:	ff 92       	push	r15
    4e3a:	0f 93       	push	r16
    4e3c:	df 93       	push	r29
    4e3e:	cf 93       	push	r28
    4e40:	cd b7       	in	r28, 0x3d	; 61
    4e42:	de b7       	in	r29, 0x3e	; 62
    4e44:	28 97       	sbiw	r28, 0x08	; 8
    4e46:	0f b6       	in	r0, 0x3f	; 63
    4e48:	f8 94       	cli
    4e4a:	de bf       	out	0x3e, r29	; 62
    4e4c:	0f be       	out	0x3f, r0	; 63
    4e4e:	cd bf       	out	0x3d, r28	; 61
    4e50:	9e 83       	std	Y+6, r25	; 0x06
    4e52:	8d 83       	std	Y+5, r24	; 0x05
    4e54:	78 87       	std	Y+8, r23	; 0x08
    4e56:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4e58:	8d 81       	ldd	r24, Y+5	; 0x05
    4e5a:	9e 81       	ldd	r25, Y+6	; 0x06
    4e5c:	9c 83       	std	Y+4, r25	; 0x04
    4e5e:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4e60:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    4e62:	eb 81       	ldd	r30, Y+3	; 0x03
    4e64:	fc 81       	ldd	r31, Y+4	; 0x04
    4e66:	82 85       	ldd	r24, Z+10	; 0x0a
    4e68:	93 85       	ldd	r25, Z+11	; 0x0b
    4e6a:	00 97       	sbiw	r24, 0x00	; 0
    4e6c:	c1 f0       	breq	.+48     	; 0x4e9e <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    4e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e70:	fc 81       	ldd	r31, Y+4	; 0x04
    4e72:	82 85       	ldd	r24, Z+10	; 0x0a
    4e74:	93 85       	ldd	r25, Z+11	; 0x0b
    4e76:	ef 81       	ldd	r30, Y+7	; 0x07
    4e78:	f8 85       	ldd	r31, Y+8	; 0x08
    4e7a:	60 e0       	ldi	r22, 0x00	; 0
    4e7c:	20 e0       	ldi	r18, 0x00	; 0
    4e7e:	30 e0       	ldi	r19, 0x00	; 0
    4e80:	40 e0       	ldi	r20, 0x00	; 0
    4e82:	50 e0       	ldi	r21, 0x00	; 0
    4e84:	00 e0       	ldi	r16, 0x00	; 0
    4e86:	ee 24       	eor	r14, r14
    4e88:	ff 24       	eor	r15, r15
    4e8a:	6f 01       	movw	r12, r30
    4e8c:	0e 94 8f 39 	call	0x731e	; 0x731e <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    4e90:	eb 81       	ldd	r30, Y+3	; 0x03
    4e92:	fc 81       	ldd	r31, Y+4	; 0x04
    4e94:	13 86       	std	Z+11, r1	; 0x0b
    4e96:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    4e98:	81 e0       	ldi	r24, 0x01	; 1
    4e9a:	8a 83       	std	Y+2, r24	; 0x02
    4e9c:	01 c0       	rjmp	.+2      	; 0x4ea0 <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    4e9e:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4ea0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4ea2:	28 96       	adiw	r28, 0x08	; 8
    4ea4:	0f b6       	in	r0, 0x3f	; 63
    4ea6:	f8 94       	cli
    4ea8:	de bf       	out	0x3e, r29	; 62
    4eaa:	0f be       	out	0x3f, r0	; 63
    4eac:	cd bf       	out	0x3d, r28	; 61
    4eae:	cf 91       	pop	r28
    4eb0:	df 91       	pop	r29
    4eb2:	0f 91       	pop	r16
    4eb4:	ff 90       	pop	r15
    4eb6:	ef 90       	pop	r14
    4eb8:	df 90       	pop	r13
    4eba:	cf 90       	pop	r12
    4ebc:	08 95       	ret

00004ebe <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    4ebe:	df 93       	push	r29
    4ec0:	cf 93       	push	r28
    4ec2:	cd b7       	in	r28, 0x3d	; 61
    4ec4:	de b7       	in	r29, 0x3e	; 62
    4ec6:	2e 97       	sbiw	r28, 0x0e	; 14
    4ec8:	0f b6       	in	r0, 0x3f	; 63
    4eca:	f8 94       	cli
    4ecc:	de bf       	out	0x3e, r29	; 62
    4ece:	0f be       	out	0x3f, r0	; 63
    4ed0:	cd bf       	out	0x3d, r28	; 61
    4ed2:	9c 83       	std	Y+4, r25	; 0x04
    4ed4:	8b 83       	std	Y+3, r24	; 0x03
    4ed6:	7e 83       	std	Y+6, r23	; 0x06
    4ed8:	6d 83       	std	Y+5, r22	; 0x05
    4eda:	58 87       	std	Y+8, r21	; 0x08
    4edc:	4f 83       	std	Y+7, r20	; 0x07
    4ede:	3a 87       	std	Y+10, r19	; 0x0a
    4ee0:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    4ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ee6:	24 81       	ldd	r18, Z+4	; 0x04
    4ee8:	35 81       	ldd	r19, Z+5	; 0x05
    4eea:	89 85       	ldd	r24, Y+9	; 0x09
    4eec:	9a 85       	ldd	r25, Y+10	; 0x0a
    4eee:	a9 01       	movw	r20, r18
    4ef0:	48 1b       	sub	r20, r24
    4ef2:	59 0b       	sbc	r21, r25
    4ef4:	ca 01       	movw	r24, r20
    4ef6:	2f 81       	ldd	r18, Y+7	; 0x07
    4ef8:	38 85       	ldd	r19, Y+8	; 0x08
    4efa:	3e 87       	std	Y+14, r19	; 0x0e
    4efc:	2d 87       	std	Y+13, r18	; 0x0d
    4efe:	9c 87       	std	Y+12, r25	; 0x0c
    4f00:	8b 87       	std	Y+11, r24	; 0x0b
    4f02:	4b 85       	ldd	r20, Y+11	; 0x0b
    4f04:	5c 85       	ldd	r21, Y+12	; 0x0c
    4f06:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f08:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f0a:	84 17       	cp	r24, r20
    4f0c:	95 07       	cpc	r25, r21
    4f0e:	20 f4       	brcc	.+8      	; 0x4f18 <prvWriteBytesToBuffer+0x5a>
    4f10:	2d 85       	ldd	r18, Y+13	; 0x0d
    4f12:	3e 85       	ldd	r19, Y+14	; 0x0e
    4f14:	3c 87       	std	Y+12, r19	; 0x0c
    4f16:	2b 87       	std	Y+11, r18	; 0x0b
    4f18:	4b 85       	ldd	r20, Y+11	; 0x0b
    4f1a:	5c 85       	ldd	r21, Y+12	; 0x0c
    4f1c:	5a 83       	std	Y+2, r21	; 0x02
    4f1e:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4f20:	eb 81       	ldd	r30, Y+3	; 0x03
    4f22:	fc 81       	ldd	r31, Y+4	; 0x04
    4f24:	24 85       	ldd	r18, Z+12	; 0x0c
    4f26:	35 85       	ldd	r19, Z+13	; 0x0d
    4f28:	89 85       	ldd	r24, Y+9	; 0x09
    4f2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f2c:	82 0f       	add	r24, r18
    4f2e:	93 1f       	adc	r25, r19
    4f30:	2d 81       	ldd	r18, Y+5	; 0x05
    4f32:	3e 81       	ldd	r19, Y+6	; 0x06
    4f34:	49 81       	ldd	r20, Y+1	; 0x01
    4f36:	5a 81       	ldd	r21, Y+2	; 0x02
    4f38:	b9 01       	movw	r22, r18
    4f3a:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    4f3e:	2f 81       	ldd	r18, Y+7	; 0x07
    4f40:	38 85       	ldd	r19, Y+8	; 0x08
    4f42:	89 81       	ldd	r24, Y+1	; 0x01
    4f44:	9a 81       	ldd	r25, Y+2	; 0x02
    4f46:	82 17       	cp	r24, r18
    4f48:	93 07       	cpc	r25, r19
    4f4a:	b0 f4       	brcc	.+44     	; 0x4f78 <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4f4c:	eb 81       	ldd	r30, Y+3	; 0x03
    4f4e:	fc 81       	ldd	r31, Y+4	; 0x04
    4f50:	64 85       	ldd	r22, Z+12	; 0x0c
    4f52:	75 85       	ldd	r23, Z+13	; 0x0d
    4f54:	2d 81       	ldd	r18, Y+5	; 0x05
    4f56:	3e 81       	ldd	r19, Y+6	; 0x06
    4f58:	89 81       	ldd	r24, Y+1	; 0x01
    4f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f5c:	a9 01       	movw	r20, r18
    4f5e:	48 0f       	add	r20, r24
    4f60:	59 1f       	adc	r21, r25
    4f62:	2f 81       	ldd	r18, Y+7	; 0x07
    4f64:	38 85       	ldd	r19, Y+8	; 0x08
    4f66:	89 81       	ldd	r24, Y+1	; 0x01
    4f68:	9a 81       	ldd	r25, Y+2	; 0x02
    4f6a:	28 1b       	sub	r18, r24
    4f6c:	39 0b       	sbc	r19, r25
    4f6e:	cb 01       	movw	r24, r22
    4f70:	ba 01       	movw	r22, r20
    4f72:	a9 01       	movw	r20, r18
    4f74:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    4f78:	29 85       	ldd	r18, Y+9	; 0x09
    4f7a:	3a 85       	ldd	r19, Y+10	; 0x0a
    4f7c:	8f 81       	ldd	r24, Y+7	; 0x07
    4f7e:	98 85       	ldd	r25, Y+8	; 0x08
    4f80:	82 0f       	add	r24, r18
    4f82:	93 1f       	adc	r25, r19
    4f84:	9a 87       	std	Y+10, r25	; 0x0a
    4f86:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    4f88:	eb 81       	ldd	r30, Y+3	; 0x03
    4f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4f8c:	24 81       	ldd	r18, Z+4	; 0x04
    4f8e:	35 81       	ldd	r19, Z+5	; 0x05
    4f90:	89 85       	ldd	r24, Y+9	; 0x09
    4f92:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f94:	82 17       	cp	r24, r18
    4f96:	93 07       	cpc	r25, r19
    4f98:	50 f0       	brcs	.+20     	; 0x4fae <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    4f9a:	eb 81       	ldd	r30, Y+3	; 0x03
    4f9c:	fc 81       	ldd	r31, Y+4	; 0x04
    4f9e:	24 81       	ldd	r18, Z+4	; 0x04
    4fa0:	35 81       	ldd	r19, Z+5	; 0x05
    4fa2:	89 85       	ldd	r24, Y+9	; 0x09
    4fa4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fa6:	82 1b       	sub	r24, r18
    4fa8:	93 0b       	sbc	r25, r19
    4faa:	9a 87       	std	Y+10, r25	; 0x0a
    4fac:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    4fae:	89 85       	ldd	r24, Y+9	; 0x09
    4fb0:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    4fb2:	2e 96       	adiw	r28, 0x0e	; 14
    4fb4:	0f b6       	in	r0, 0x3f	; 63
    4fb6:	f8 94       	cli
    4fb8:	de bf       	out	0x3e, r29	; 62
    4fba:	0f be       	out	0x3f, r0	; 63
    4fbc:	cd bf       	out	0x3d, r28	; 61
    4fbe:	cf 91       	pop	r28
    4fc0:	df 91       	pop	r29
    4fc2:	08 95       	ret

00004fc4 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    4fc4:	df 93       	push	r29
    4fc6:	cf 93       	push	r28
    4fc8:	cd b7       	in	r28, 0x3d	; 61
    4fca:	de b7       	in	r29, 0x3e	; 62
    4fcc:	2e 97       	sbiw	r28, 0x0e	; 14
    4fce:	0f b6       	in	r0, 0x3f	; 63
    4fd0:	f8 94       	cli
    4fd2:	de bf       	out	0x3e, r29	; 62
    4fd4:	0f be       	out	0x3f, r0	; 63
    4fd6:	cd bf       	out	0x3d, r28	; 61
    4fd8:	9c 83       	std	Y+4, r25	; 0x04
    4fda:	8b 83       	std	Y+3, r24	; 0x03
    4fdc:	7e 83       	std	Y+6, r23	; 0x06
    4fde:	6d 83       	std	Y+5, r22	; 0x05
    4fe0:	58 87       	std	Y+8, r21	; 0x08
    4fe2:	4f 83       	std	Y+7, r20	; 0x07
    4fe4:	3a 87       	std	Y+10, r19	; 0x0a
    4fe6:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    4fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    4fea:	fc 81       	ldd	r31, Y+4	; 0x04
    4fec:	24 81       	ldd	r18, Z+4	; 0x04
    4fee:	35 81       	ldd	r19, Z+5	; 0x05
    4ff0:	89 85       	ldd	r24, Y+9	; 0x09
    4ff2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ff4:	a9 01       	movw	r20, r18
    4ff6:	48 1b       	sub	r20, r24
    4ff8:	59 0b       	sbc	r21, r25
    4ffa:	ca 01       	movw	r24, r20
    4ffc:	2f 81       	ldd	r18, Y+7	; 0x07
    4ffe:	38 85       	ldd	r19, Y+8	; 0x08
    5000:	3e 87       	std	Y+14, r19	; 0x0e
    5002:	2d 87       	std	Y+13, r18	; 0x0d
    5004:	9c 87       	std	Y+12, r25	; 0x0c
    5006:	8b 87       	std	Y+11, r24	; 0x0b
    5008:	4b 85       	ldd	r20, Y+11	; 0x0b
    500a:	5c 85       	ldd	r21, Y+12	; 0x0c
    500c:	8d 85       	ldd	r24, Y+13	; 0x0d
    500e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5010:	84 17       	cp	r24, r20
    5012:	95 07       	cpc	r25, r21
    5014:	20 f4       	brcc	.+8      	; 0x501e <prvReadBytesFromBuffer+0x5a>
    5016:	2d 85       	ldd	r18, Y+13	; 0x0d
    5018:	3e 85       	ldd	r19, Y+14	; 0x0e
    501a:	3c 87       	std	Y+12, r19	; 0x0c
    501c:	2b 87       	std	Y+11, r18	; 0x0b
    501e:	4b 85       	ldd	r20, Y+11	; 0x0b
    5020:	5c 85       	ldd	r21, Y+12	; 0x0c
    5022:	5a 83       	std	Y+2, r21	; 0x02
    5024:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    5026:	eb 81       	ldd	r30, Y+3	; 0x03
    5028:	fc 81       	ldd	r31, Y+4	; 0x04
    502a:	24 85       	ldd	r18, Z+12	; 0x0c
    502c:	35 85       	ldd	r19, Z+13	; 0x0d
    502e:	89 85       	ldd	r24, Y+9	; 0x09
    5030:	9a 85       	ldd	r25, Y+10	; 0x0a
    5032:	a9 01       	movw	r20, r18
    5034:	48 0f       	add	r20, r24
    5036:	59 1f       	adc	r21, r25
    5038:	8d 81       	ldd	r24, Y+5	; 0x05
    503a:	9e 81       	ldd	r25, Y+6	; 0x06
    503c:	29 81       	ldd	r18, Y+1	; 0x01
    503e:	3a 81       	ldd	r19, Y+2	; 0x02
    5040:	ba 01       	movw	r22, r20
    5042:	a9 01       	movw	r20, r18
    5044:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    5048:	2f 81       	ldd	r18, Y+7	; 0x07
    504a:	38 85       	ldd	r19, Y+8	; 0x08
    504c:	89 81       	ldd	r24, Y+1	; 0x01
    504e:	9a 81       	ldd	r25, Y+2	; 0x02
    5050:	82 17       	cp	r24, r18
    5052:	93 07       	cpc	r25, r19
    5054:	b0 f4       	brcc	.+44     	; 0x5082 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    5056:	2d 81       	ldd	r18, Y+5	; 0x05
    5058:	3e 81       	ldd	r19, Y+6	; 0x06
    505a:	89 81       	ldd	r24, Y+1	; 0x01
    505c:	9a 81       	ldd	r25, Y+2	; 0x02
    505e:	b9 01       	movw	r22, r18
    5060:	68 0f       	add	r22, r24
    5062:	79 1f       	adc	r23, r25
    5064:	eb 81       	ldd	r30, Y+3	; 0x03
    5066:	fc 81       	ldd	r31, Y+4	; 0x04
    5068:	44 85       	ldd	r20, Z+12	; 0x0c
    506a:	55 85       	ldd	r21, Z+13	; 0x0d
    506c:	2f 81       	ldd	r18, Y+7	; 0x07
    506e:	38 85       	ldd	r19, Y+8	; 0x08
    5070:	89 81       	ldd	r24, Y+1	; 0x01
    5072:	9a 81       	ldd	r25, Y+2	; 0x02
    5074:	28 1b       	sub	r18, r24
    5076:	39 0b       	sbc	r19, r25
    5078:	cb 01       	movw	r24, r22
    507a:	ba 01       	movw	r22, r20
    507c:	a9 01       	movw	r20, r18
    507e:	0e 94 03 40 	call	0x8006	; 0x8006 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    5082:	29 85       	ldd	r18, Y+9	; 0x09
    5084:	3a 85       	ldd	r19, Y+10	; 0x0a
    5086:	8f 81       	ldd	r24, Y+7	; 0x07
    5088:	98 85       	ldd	r25, Y+8	; 0x08
    508a:	82 0f       	add	r24, r18
    508c:	93 1f       	adc	r25, r19
    508e:	9a 87       	std	Y+10, r25	; 0x0a
    5090:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    5092:	eb 81       	ldd	r30, Y+3	; 0x03
    5094:	fc 81       	ldd	r31, Y+4	; 0x04
    5096:	24 81       	ldd	r18, Z+4	; 0x04
    5098:	35 81       	ldd	r19, Z+5	; 0x05
    509a:	89 85       	ldd	r24, Y+9	; 0x09
    509c:	9a 85       	ldd	r25, Y+10	; 0x0a
    509e:	82 17       	cp	r24, r18
    50a0:	93 07       	cpc	r25, r19
    50a2:	50 f0       	brcs	.+20     	; 0x50b8 <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    50a4:	eb 81       	ldd	r30, Y+3	; 0x03
    50a6:	fc 81       	ldd	r31, Y+4	; 0x04
    50a8:	24 81       	ldd	r18, Z+4	; 0x04
    50aa:	35 81       	ldd	r19, Z+5	; 0x05
    50ac:	89 85       	ldd	r24, Y+9	; 0x09
    50ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    50b0:	82 1b       	sub	r24, r18
    50b2:	93 0b       	sbc	r25, r19
    50b4:	9a 87       	std	Y+10, r25	; 0x0a
    50b6:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    50b8:	89 85       	ldd	r24, Y+9	; 0x09
    50ba:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    50bc:	2e 96       	adiw	r28, 0x0e	; 14
    50be:	0f b6       	in	r0, 0x3f	; 63
    50c0:	f8 94       	cli
    50c2:	de bf       	out	0x3e, r29	; 62
    50c4:	0f be       	out	0x3f, r0	; 63
    50c6:	cd bf       	out	0x3d, r28	; 61
    50c8:	cf 91       	pop	r28
    50ca:	df 91       	pop	r29
    50cc:	08 95       	ret

000050ce <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    50ce:	df 93       	push	r29
    50d0:	cf 93       	push	r28
    50d2:	00 d0       	rcall	.+0      	; 0x50d4 <prvBytesInBuffer+0x6>
    50d4:	00 d0       	rcall	.+0      	; 0x50d6 <prvBytesInBuffer+0x8>
    50d6:	cd b7       	in	r28, 0x3d	; 61
    50d8:	de b7       	in	r29, 0x3e	; 62
    50da:	9c 83       	std	Y+4, r25	; 0x04
    50dc:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    50de:	eb 81       	ldd	r30, Y+3	; 0x03
    50e0:	fc 81       	ldd	r31, Y+4	; 0x04
    50e2:	24 81       	ldd	r18, Z+4	; 0x04
    50e4:	35 81       	ldd	r19, Z+5	; 0x05
    50e6:	eb 81       	ldd	r30, Y+3	; 0x03
    50e8:	fc 81       	ldd	r31, Y+4	; 0x04
    50ea:	82 81       	ldd	r24, Z+2	; 0x02
    50ec:	93 81       	ldd	r25, Z+3	; 0x03
    50ee:	82 0f       	add	r24, r18
    50f0:	93 1f       	adc	r25, r19
    50f2:	9a 83       	std	Y+2, r25	; 0x02
    50f4:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    50f6:	eb 81       	ldd	r30, Y+3	; 0x03
    50f8:	fc 81       	ldd	r31, Y+4	; 0x04
    50fa:	20 81       	ld	r18, Z
    50fc:	31 81       	ldd	r19, Z+1	; 0x01
    50fe:	89 81       	ldd	r24, Y+1	; 0x01
    5100:	9a 81       	ldd	r25, Y+2	; 0x02
    5102:	82 1b       	sub	r24, r18
    5104:	93 0b       	sbc	r25, r19
    5106:	9a 83       	std	Y+2, r25	; 0x02
    5108:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    510a:	eb 81       	ldd	r30, Y+3	; 0x03
    510c:	fc 81       	ldd	r31, Y+4	; 0x04
    510e:	24 81       	ldd	r18, Z+4	; 0x04
    5110:	35 81       	ldd	r19, Z+5	; 0x05
    5112:	89 81       	ldd	r24, Y+1	; 0x01
    5114:	9a 81       	ldd	r25, Y+2	; 0x02
    5116:	82 17       	cp	r24, r18
    5118:	93 07       	cpc	r25, r19
    511a:	50 f0       	brcs	.+20     	; 0x5130 <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    511c:	eb 81       	ldd	r30, Y+3	; 0x03
    511e:	fc 81       	ldd	r31, Y+4	; 0x04
    5120:	24 81       	ldd	r18, Z+4	; 0x04
    5122:	35 81       	ldd	r19, Z+5	; 0x05
    5124:	89 81       	ldd	r24, Y+1	; 0x01
    5126:	9a 81       	ldd	r25, Y+2	; 0x02
    5128:	82 1b       	sub	r24, r18
    512a:	93 0b       	sbc	r25, r19
    512c:	9a 83       	std	Y+2, r25	; 0x02
    512e:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    5130:	89 81       	ldd	r24, Y+1	; 0x01
    5132:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5134:	0f 90       	pop	r0
    5136:	0f 90       	pop	r0
    5138:	0f 90       	pop	r0
    513a:	0f 90       	pop	r0
    513c:	cf 91       	pop	r28
    513e:	df 91       	pop	r29
    5140:	08 95       	ret

00005142 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    5142:	cf 92       	push	r12
    5144:	df 92       	push	r13
    5146:	ef 92       	push	r14
    5148:	ff 92       	push	r15
    514a:	0f 93       	push	r16
    514c:	df 93       	push	r29
    514e:	cf 93       	push	r28
    5150:	cd b7       	in	r28, 0x3d	; 61
    5152:	de b7       	in	r29, 0x3e	; 62
    5154:	2d 97       	sbiw	r28, 0x0d	; 13
    5156:	0f b6       	in	r0, 0x3f	; 63
    5158:	f8 94       	cli
    515a:	de bf       	out	0x3e, r29	; 62
    515c:	0f be       	out	0x3f, r0	; 63
    515e:	cd bf       	out	0x3d, r28	; 61
    5160:	9a 83       	std	Y+2, r25	; 0x02
    5162:	89 83       	std	Y+1, r24	; 0x01
    5164:	7c 83       	std	Y+4, r23	; 0x04
    5166:	6b 83       	std	Y+3, r22	; 0x03
    5168:	5e 83       	std	Y+6, r21	; 0x06
    516a:	4d 83       	std	Y+5, r20	; 0x05
    516c:	38 87       	std	Y+8, r19	; 0x08
    516e:	2f 83       	std	Y+7, r18	; 0x07
    5170:	09 87       	std	Y+9, r16	; 0x09
    5172:	fb 86       	std	Y+11, r15	; 0x0b
    5174:	ea 86       	std	Y+10, r14	; 0x0a
    5176:	dd 86       	std	Y+13, r13	; 0x0d
    5178:	cc 86       	std	Y+12, r12	; 0x0c
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    517a:	89 81       	ldd	r24, Y+1	; 0x01
    517c:	9a 81       	ldd	r25, Y+2	; 0x02
    517e:	60 e0       	ldi	r22, 0x00	; 0
    5180:	70 e0       	ldi	r23, 0x00	; 0
    5182:	4f e0       	ldi	r20, 0x0F	; 15
    5184:	50 e0       	ldi	r21, 0x00	; 0
    5186:	0e 94 0c 40 	call	0x8018	; 0x8018 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    518a:	e9 81       	ldd	r30, Y+1	; 0x01
    518c:	fa 81       	ldd	r31, Y+2	; 0x02
    518e:	8b 81       	ldd	r24, Y+3	; 0x03
    5190:	9c 81       	ldd	r25, Y+4	; 0x04
    5192:	95 87       	std	Z+13, r25	; 0x0d
    5194:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    5196:	e9 81       	ldd	r30, Y+1	; 0x01
    5198:	fa 81       	ldd	r31, Y+2	; 0x02
    519a:	8d 81       	ldd	r24, Y+5	; 0x05
    519c:	9e 81       	ldd	r25, Y+6	; 0x06
    519e:	95 83       	std	Z+5, r25	; 0x05
    51a0:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    51a2:	e9 81       	ldd	r30, Y+1	; 0x01
    51a4:	fa 81       	ldd	r31, Y+2	; 0x02
    51a6:	8f 81       	ldd	r24, Y+7	; 0x07
    51a8:	98 85       	ldd	r25, Y+8	; 0x08
    51aa:	97 83       	std	Z+7, r25	; 0x07
    51ac:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    51ae:	e9 81       	ldd	r30, Y+1	; 0x01
    51b0:	fa 81       	ldd	r31, Y+2	; 0x02
    51b2:	89 85       	ldd	r24, Y+9	; 0x09
    51b4:	86 87       	std	Z+14, r24	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    51b6:	2d 96       	adiw	r28, 0x0d	; 13
    51b8:	0f b6       	in	r0, 0x3f	; 63
    51ba:	f8 94       	cli
    51bc:	de bf       	out	0x3e, r29	; 62
    51be:	0f be       	out	0x3f, r0	; 63
    51c0:	cd bf       	out	0x3d, r28	; 61
    51c2:	cf 91       	pop	r28
    51c4:	df 91       	pop	r29
    51c6:	0f 91       	pop	r16
    51c8:	ff 90       	pop	r15
    51ca:	ef 90       	pop	r14
    51cc:	df 90       	pop	r13
    51ce:	cf 90       	pop	r12
    51d0:	08 95       	ret

000051d2 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    51d2:	8f 92       	push	r8
    51d4:	9f 92       	push	r9
    51d6:	af 92       	push	r10
    51d8:	bf 92       	push	r11
    51da:	cf 92       	push	r12
    51dc:	df 92       	push	r13
    51de:	ef 92       	push	r14
    51e0:	ff 92       	push	r15
    51e2:	0f 93       	push	r16
    51e4:	1f 93       	push	r17
    51e6:	df 93       	push	r29
    51e8:	cf 93       	push	r28
    51ea:	cd b7       	in	r28, 0x3d	; 61
    51ec:	de b7       	in	r29, 0x3e	; 62
    51ee:	60 97       	sbiw	r28, 0x10	; 16
    51f0:	0f b6       	in	r0, 0x3f	; 63
    51f2:	f8 94       	cli
    51f4:	de bf       	out	0x3e, r29	; 62
    51f6:	0f be       	out	0x3f, r0	; 63
    51f8:	cd bf       	out	0x3d, r28	; 61
    51fa:	9f 83       	std	Y+7, r25	; 0x07
    51fc:	8e 83       	std	Y+6, r24	; 0x06
    51fe:	79 87       	std	Y+9, r23	; 0x09
    5200:	68 87       	std	Y+8, r22	; 0x08
    5202:	5b 87       	std	Y+11, r21	; 0x0b
    5204:	4a 87       	std	Y+10, r20	; 0x0a
    5206:	3d 87       	std	Y+13, r19	; 0x0d
    5208:	2c 87       	std	Y+12, r18	; 0x0c
    520a:	0e 87       	std	Y+14, r16	; 0x0e
    520c:	f8 8a       	std	Y+16, r15	; 0x10
    520e:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    5210:	8a 85       	ldd	r24, Y+10	; 0x0a
    5212:	9b 85       	ldd	r25, Y+11	; 0x0b
    5214:	0e 94 ae 12 	call	0x255c	; 0x255c <pvPortMalloc>
    5218:	9a 83       	std	Y+2, r25	; 0x02
    521a:	89 83       	std	Y+1, r24	; 0x01

            if( pxStack != NULL )
    521c:	89 81       	ldd	r24, Y+1	; 0x01
    521e:	9a 81       	ldd	r25, Y+2	; 0x02
    5220:	00 97       	sbiw	r24, 0x00	; 0
    5222:	f1 f0       	breq	.+60     	; 0x5260 <xTaskCreate+0x8e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    5224:	8e e2       	ldi	r24, 0x2E	; 46
    5226:	90 e0       	ldi	r25, 0x00	; 0
    5228:	0e 94 ae 12 	call	0x255c	; 0x255c <pvPortMalloc>
    522c:	9d 83       	std	Y+5, r25	; 0x05
    522e:	8c 83       	std	Y+4, r24	; 0x04

                if( pxNewTCB != NULL )
    5230:	8c 81       	ldd	r24, Y+4	; 0x04
    5232:	9d 81       	ldd	r25, Y+5	; 0x05
    5234:	00 97       	sbiw	r24, 0x00	; 0
    5236:	79 f0       	breq	.+30     	; 0x5256 <xTaskCreate+0x84>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    5238:	8c 81       	ldd	r24, Y+4	; 0x04
    523a:	9d 81       	ldd	r25, Y+5	; 0x05
    523c:	60 e0       	ldi	r22, 0x00	; 0
    523e:	70 e0       	ldi	r23, 0x00	; 0
    5240:	4e e2       	ldi	r20, 0x2E	; 46
    5242:	50 e0       	ldi	r21, 0x00	; 0
    5244:	0e 94 0c 40 	call	0x8018	; 0x8018 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    5248:	ec 81       	ldd	r30, Y+4	; 0x04
    524a:	fd 81       	ldd	r31, Y+5	; 0x05
    524c:	89 81       	ldd	r24, Y+1	; 0x01
    524e:	9a 81       	ldd	r25, Y+2	; 0x02
    5250:	90 8f       	std	Z+24, r25	; 0x18
    5252:	87 8b       	std	Z+23, r24	; 0x17
    5254:	07 c0       	rjmp	.+14     	; 0x5264 <xTaskCreate+0x92>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    5256:	89 81       	ldd	r24, Y+1	; 0x01
    5258:	9a 81       	ldd	r25, Y+2	; 0x02
    525a:	0e 94 a3 13 	call	0x2746	; 0x2746 <vPortFree>
    525e:	02 c0       	rjmp	.+4      	; 0x5264 <xTaskCreate+0x92>
                }
            }
            else
            {
                pxNewTCB = NULL;
    5260:	1d 82       	std	Y+5, r1	; 0x05
    5262:	1c 82       	std	Y+4, r1	; 0x04
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    5264:	8c 81       	ldd	r24, Y+4	; 0x04
    5266:	9d 81       	ldd	r25, Y+5	; 0x05
    5268:	00 97       	sbiw	r24, 0x00	; 0
    526a:	e9 f0       	breq	.+58     	; 0x52a6 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    526c:	8a 85       	ldd	r24, Y+10	; 0x0a
    526e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5270:	9c 01       	movw	r18, r24
    5272:	40 e0       	ldi	r20, 0x00	; 0
    5274:	50 e0       	ldi	r21, 0x00	; 0
    5276:	8e 81       	ldd	r24, Y+6	; 0x06
    5278:	9f 81       	ldd	r25, Y+7	; 0x07
    527a:	68 85       	ldd	r22, Y+8	; 0x08
    527c:	79 85       	ldd	r23, Y+9	; 0x09
    527e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5280:	fd 85       	ldd	r31, Y+13	; 0x0d
    5282:	af 85       	ldd	r26, Y+15	; 0x0f
    5284:	b8 89       	ldd	r27, Y+16	; 0x10
    5286:	ac 80       	ldd	r10, Y+4	; 0x04
    5288:	bd 80       	ldd	r11, Y+5	; 0x05
    528a:	8f 01       	movw	r16, r30
    528c:	ee 84       	ldd	r14, Y+14	; 0x0e
    528e:	6d 01       	movw	r12, r26
    5290:	88 24       	eor	r8, r8
    5292:	99 24       	eor	r9, r9
    5294:	0e 94 69 29 	call	0x52d2	; 0x52d2 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    5298:	8c 81       	ldd	r24, Y+4	; 0x04
    529a:	9d 81       	ldd	r25, Y+5	; 0x05
    529c:	0e 94 18 2a 	call	0x5430	; 0x5430 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    52a0:	81 e0       	ldi	r24, 0x01	; 1
    52a2:	8b 83       	std	Y+3, r24	; 0x03
    52a4:	02 c0       	rjmp	.+4      	; 0x52aa <xTaskCreate+0xd8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    52a6:	8f ef       	ldi	r24, 0xFF	; 255
    52a8:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    52aa:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    52ac:	60 96       	adiw	r28, 0x10	; 16
    52ae:	0f b6       	in	r0, 0x3f	; 63
    52b0:	f8 94       	cli
    52b2:	de bf       	out	0x3e, r29	; 62
    52b4:	0f be       	out	0x3f, r0	; 63
    52b6:	cd bf       	out	0x3d, r28	; 61
    52b8:	cf 91       	pop	r28
    52ba:	df 91       	pop	r29
    52bc:	1f 91       	pop	r17
    52be:	0f 91       	pop	r16
    52c0:	ff 90       	pop	r15
    52c2:	ef 90       	pop	r14
    52c4:	df 90       	pop	r13
    52c6:	cf 90       	pop	r12
    52c8:	bf 90       	pop	r11
    52ca:	af 90       	pop	r10
    52cc:	9f 90       	pop	r9
    52ce:	8f 90       	pop	r8
    52d0:	08 95       	ret

000052d2 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    52d2:	8f 92       	push	r8
    52d4:	9f 92       	push	r9
    52d6:	af 92       	push	r10
    52d8:	bf 92       	push	r11
    52da:	cf 92       	push	r12
    52dc:	df 92       	push	r13
    52de:	ef 92       	push	r14
    52e0:	0f 93       	push	r16
    52e2:	1f 93       	push	r17
    52e4:	df 93       	push	r29
    52e6:	cf 93       	push	r28
    52e8:	cd b7       	in	r28, 0x3d	; 61
    52ea:	de b7       	in	r29, 0x3e	; 62
    52ec:	64 97       	sbiw	r28, 0x14	; 20
    52ee:	0f b6       	in	r0, 0x3f	; 63
    52f0:	f8 94       	cli
    52f2:	de bf       	out	0x3e, r29	; 62
    52f4:	0f be       	out	0x3f, r0	; 63
    52f6:	cd bf       	out	0x3d, r28	; 61
    52f8:	9d 83       	std	Y+5, r25	; 0x05
    52fa:	8c 83       	std	Y+4, r24	; 0x04
    52fc:	7f 83       	std	Y+7, r23	; 0x07
    52fe:	6e 83       	std	Y+6, r22	; 0x06
    5300:	28 87       	std	Y+8, r18	; 0x08
    5302:	39 87       	std	Y+9, r19	; 0x09
    5304:	4a 87       	std	Y+10, r20	; 0x0a
    5306:	5b 87       	std	Y+11, r21	; 0x0b
    5308:	1d 87       	std	Y+13, r17	; 0x0d
    530a:	0c 87       	std	Y+12, r16	; 0x0c
    530c:	ee 86       	std	Y+14, r14	; 0x0e
    530e:	d8 8a       	std	Y+16, r13	; 0x10
    5310:	cf 86       	std	Y+15, r12	; 0x0f
    5312:	ba 8a       	std	Y+18, r11	; 0x12
    5314:	a9 8a       	std	Y+17, r10	; 0x11
    5316:	9c 8a       	std	Y+20, r9	; 0x14
    5318:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    531a:	e9 89       	ldd	r30, Y+17	; 0x11
    531c:	fa 89       	ldd	r31, Y+18	; 0x12
    531e:	27 89       	ldd	r18, Z+23	; 0x17
    5320:	30 8d       	ldd	r19, Z+24	; 0x18
    5322:	88 85       	ldd	r24, Y+8	; 0x08
    5324:	99 85       	ldd	r25, Y+9	; 0x09
    5326:	01 97       	sbiw	r24, 0x01	; 1
    5328:	82 0f       	add	r24, r18
    532a:	93 1f       	adc	r25, r19
    532c:	9b 83       	std	Y+3, r25	; 0x03
    532e:	8a 83       	std	Y+2, r24	; 0x02
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    5330:	8e 81       	ldd	r24, Y+6	; 0x06
    5332:	9f 81       	ldd	r25, Y+7	; 0x07
    5334:	00 97       	sbiw	r24, 0x00	; 0
    5336:	49 f1       	breq	.+82     	; 0x538a <prvInitialiseNewTask+0xb8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5338:	19 82       	std	Y+1, r1	; 0x01
    533a:	21 c0       	rjmp	.+66     	; 0x537e <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    533c:	89 81       	ldd	r24, Y+1	; 0x01
    533e:	48 2f       	mov	r20, r24
    5340:	50 e0       	ldi	r21, 0x00	; 0
    5342:	89 81       	ldd	r24, Y+1	; 0x01
    5344:	28 2f       	mov	r18, r24
    5346:	30 e0       	ldi	r19, 0x00	; 0
    5348:	8e 81       	ldd	r24, Y+6	; 0x06
    534a:	9f 81       	ldd	r25, Y+7	; 0x07
    534c:	fc 01       	movw	r30, r24
    534e:	e2 0f       	add	r30, r18
    5350:	f3 1f       	adc	r31, r19
    5352:	20 81       	ld	r18, Z
    5354:	89 89       	ldd	r24, Y+17	; 0x11
    5356:	9a 89       	ldd	r25, Y+18	; 0x12
    5358:	84 0f       	add	r24, r20
    535a:	95 1f       	adc	r25, r21
    535c:	fc 01       	movw	r30, r24
    535e:	79 96       	adiw	r30, 0x19	; 25
    5360:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    5362:	89 81       	ldd	r24, Y+1	; 0x01
    5364:	28 2f       	mov	r18, r24
    5366:	30 e0       	ldi	r19, 0x00	; 0
    5368:	8e 81       	ldd	r24, Y+6	; 0x06
    536a:	9f 81       	ldd	r25, Y+7	; 0x07
    536c:	fc 01       	movw	r30, r24
    536e:	e2 0f       	add	r30, r18
    5370:	f3 1f       	adc	r31, r19
    5372:	80 81       	ld	r24, Z
    5374:	88 23       	and	r24, r24
    5376:	31 f0       	breq	.+12     	; 0x5384 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5378:	89 81       	ldd	r24, Y+1	; 0x01
    537a:	8f 5f       	subi	r24, 0xFF	; 255
    537c:	89 83       	std	Y+1, r24	; 0x01
    537e:	89 81       	ldd	r24, Y+1	; 0x01
    5380:	80 31       	cpi	r24, 0x10	; 16
    5382:	e0 f2       	brcs	.-72     	; 0x533c <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5384:	e9 89       	ldd	r30, Y+17	; 0x11
    5386:	fa 89       	ldd	r31, Y+18	; 0x12
    5388:	10 a6       	std	Z+40, r1	; 0x28
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    538a:	8e 85       	ldd	r24, Y+14	; 0x0e
    538c:	84 30       	cpi	r24, 0x04	; 4
    538e:	10 f0       	brcs	.+4      	; 0x5394 <prvInitialiseNewTask+0xc2>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5390:	83 e0       	ldi	r24, 0x03	; 3
    5392:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    5394:	e9 89       	ldd	r30, Y+17	; 0x11
    5396:	fa 89       	ldd	r31, Y+18	; 0x12
    5398:	8e 85       	ldd	r24, Y+14	; 0x0e
    539a:	86 8b       	std	Z+22, r24	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    539c:	89 89       	ldd	r24, Y+17	; 0x11
    539e:	9a 89       	ldd	r25, Y+18	; 0x12
    53a0:	02 96       	adiw	r24, 0x02	; 2
    53a2:	0e 94 86 15 	call	0x2b0c	; 0x2b0c <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    53a6:	89 89       	ldd	r24, Y+17	; 0x11
    53a8:	9a 89       	ldd	r25, Y+18	; 0x12
    53aa:	0c 96       	adiw	r24, 0x0c	; 12
    53ac:	0e 94 86 15 	call	0x2b0c	; 0x2b0c <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    53b0:	e9 89       	ldd	r30, Y+17	; 0x11
    53b2:	fa 89       	ldd	r31, Y+18	; 0x12
    53b4:	89 89       	ldd	r24, Y+17	; 0x11
    53b6:	9a 89       	ldd	r25, Y+18	; 0x12
    53b8:	91 87       	std	Z+9, r25	; 0x09
    53ba:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    53bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    53be:	28 2f       	mov	r18, r24
    53c0:	30 e0       	ldi	r19, 0x00	; 0
    53c2:	84 e0       	ldi	r24, 0x04	; 4
    53c4:	90 e0       	ldi	r25, 0x00	; 0
    53c6:	82 1b       	sub	r24, r18
    53c8:	93 0b       	sbc	r25, r19
    53ca:	e9 89       	ldd	r30, Y+17	; 0x11
    53cc:	fa 89       	ldd	r31, Y+18	; 0x12
    53ce:	95 87       	std	Z+13, r25	; 0x0d
    53d0:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    53d2:	e9 89       	ldd	r30, Y+17	; 0x11
    53d4:	fa 89       	ldd	r31, Y+18	; 0x12
    53d6:	89 89       	ldd	r24, Y+17	; 0x11
    53d8:	9a 89       	ldd	r25, Y+18	; 0x12
    53da:	93 8b       	std	Z+19, r25	; 0x13
    53dc:	82 8b       	std	Z+18, r24	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    53de:	8a 81       	ldd	r24, Y+2	; 0x02
    53e0:	9b 81       	ldd	r25, Y+3	; 0x03
    53e2:	2c 81       	ldd	r18, Y+4	; 0x04
    53e4:	3d 81       	ldd	r19, Y+5	; 0x05
    53e6:	4c 85       	ldd	r20, Y+12	; 0x0c
    53e8:	5d 85       	ldd	r21, Y+13	; 0x0d
    53ea:	b9 01       	movw	r22, r18
    53ec:	0e 94 92 16 	call	0x2d24	; 0x2d24 <pxPortInitialiseStack>
    53f0:	e9 89       	ldd	r30, Y+17	; 0x11
    53f2:	fa 89       	ldd	r31, Y+18	; 0x12
    53f4:	91 83       	std	Z+1, r25	; 0x01
    53f6:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    53f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    53fa:	98 89       	ldd	r25, Y+16	; 0x10
    53fc:	00 97       	sbiw	r24, 0x00	; 0
    53fe:	31 f0       	breq	.+12     	; 0x540c <prvInitialiseNewTask+0x13a>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    5400:	ef 85       	ldd	r30, Y+15	; 0x0f
    5402:	f8 89       	ldd	r31, Y+16	; 0x10
    5404:	89 89       	ldd	r24, Y+17	; 0x11
    5406:	9a 89       	ldd	r25, Y+18	; 0x12
    5408:	91 83       	std	Z+1, r25	; 0x01
    540a:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    540c:	64 96       	adiw	r28, 0x14	; 20
    540e:	0f b6       	in	r0, 0x3f	; 63
    5410:	f8 94       	cli
    5412:	de bf       	out	0x3e, r29	; 62
    5414:	0f be       	out	0x3f, r0	; 63
    5416:	cd bf       	out	0x3d, r28	; 61
    5418:	cf 91       	pop	r28
    541a:	df 91       	pop	r29
    541c:	1f 91       	pop	r17
    541e:	0f 91       	pop	r16
    5420:	ef 90       	pop	r14
    5422:	df 90       	pop	r13
    5424:	cf 90       	pop	r12
    5426:	bf 90       	pop	r11
    5428:	af 90       	pop	r10
    542a:	9f 90       	pop	r9
    542c:	8f 90       	pop	r8
    542e:	08 95       	ret

00005430 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    5430:	df 93       	push	r29
    5432:	cf 93       	push	r28
    5434:	00 d0       	rcall	.+0      	; 0x5436 <prvAddNewTaskToReadyList+0x6>
    5436:	00 d0       	rcall	.+0      	; 0x5438 <prvAddNewTaskToReadyList+0x8>
    5438:	cd b7       	in	r28, 0x3d	; 61
    543a:	de b7       	in	r29, 0x3e	; 62
    543c:	9c 83       	std	Y+4, r25	; 0x04
    543e:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    5440:	0f b6       	in	r0, 0x3f	; 63
    5442:	f8 94       	cli
    5444:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    5446:	80 91 94 06 	lds	r24, 0x0694
    544a:	8f 5f       	subi	r24, 0xFF	; 255
    544c:	80 93 94 06 	sts	0x0694, r24

        if( pxCurrentTCB == NULL )
    5450:	80 91 91 06 	lds	r24, 0x0691
    5454:	90 91 92 06 	lds	r25, 0x0692
    5458:	00 97       	sbiw	r24, 0x00	; 0
    545a:	69 f4       	brne	.+26     	; 0x5476 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    545c:	8b 81       	ldd	r24, Y+3	; 0x03
    545e:	9c 81       	ldd	r25, Y+4	; 0x04
    5460:	90 93 92 06 	sts	0x0692, r25
    5464:	80 93 91 06 	sts	0x0691, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    5468:	80 91 94 06 	lds	r24, 0x0694
    546c:	81 30       	cpi	r24, 0x01	; 1
    546e:	b9 f4       	brne	.+46     	; 0x549e <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    5470:	0e 94 43 35 	call	0x6a86	; 0x6a86 <prvInitialiseTaskLists>
    5474:	14 c0       	rjmp	.+40     	; 0x549e <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    5476:	80 91 98 06 	lds	r24, 0x0698
    547a:	88 23       	and	r24, r24
    547c:	81 f4       	brne	.+32     	; 0x549e <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    547e:	e0 91 91 06 	lds	r30, 0x0691
    5482:	f0 91 92 06 	lds	r31, 0x0692
    5486:	96 89       	ldd	r25, Z+22	; 0x16
    5488:	eb 81       	ldd	r30, Y+3	; 0x03
    548a:	fc 81       	ldd	r31, Y+4	; 0x04
    548c:	86 89       	ldd	r24, Z+22	; 0x16
    548e:	89 17       	cp	r24, r25
    5490:	30 f0       	brcs	.+12     	; 0x549e <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    5492:	8b 81       	ldd	r24, Y+3	; 0x03
    5494:	9c 81       	ldd	r25, Y+4	; 0x04
    5496:	90 93 92 06 	sts	0x0692, r25
    549a:	80 93 91 06 	sts	0x0691, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    549e:	80 91 9d 06 	lds	r24, 0x069D
    54a2:	8f 5f       	subi	r24, 0xFF	; 255
    54a4:	80 93 9d 06 	sts	0x069D, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    54a8:	eb 81       	ldd	r30, Y+3	; 0x03
    54aa:	fc 81       	ldd	r31, Y+4	; 0x04
    54ac:	96 89       	ldd	r25, Z+22	; 0x16
    54ae:	80 91 97 06 	lds	r24, 0x0697
    54b2:	89 17       	cp	r24, r25
    54b4:	28 f4       	brcc	.+10     	; 0x54c0 <prvAddNewTaskToReadyList+0x90>
    54b6:	eb 81       	ldd	r30, Y+3	; 0x03
    54b8:	fc 81       	ldd	r31, Y+4	; 0x04
    54ba:	86 89       	ldd	r24, Z+22	; 0x16
    54bc:	80 93 97 06 	sts	0x0697, r24
    54c0:	eb 81       	ldd	r30, Y+3	; 0x03
    54c2:	fc 81       	ldd	r31, Y+4	; 0x04
    54c4:	86 89       	ldd	r24, Z+22	; 0x16
    54c6:	28 2f       	mov	r18, r24
    54c8:	30 e0       	ldi	r19, 0x00	; 0
    54ca:	c9 01       	movw	r24, r18
    54cc:	88 0f       	add	r24, r24
    54ce:	99 1f       	adc	r25, r25
    54d0:	88 0f       	add	r24, r24
    54d2:	99 1f       	adc	r25, r25
    54d4:	88 0f       	add	r24, r24
    54d6:	99 1f       	adc	r25, r25
    54d8:	82 0f       	add	r24, r18
    54da:	93 1f       	adc	r25, r19
    54dc:	fc 01       	movw	r30, r24
    54de:	ed 55       	subi	r30, 0x5D	; 93
    54e0:	f9 4f       	sbci	r31, 0xF9	; 249
    54e2:	81 81       	ldd	r24, Z+1	; 0x01
    54e4:	92 81       	ldd	r25, Z+2	; 0x02
    54e6:	9a 83       	std	Y+2, r25	; 0x02
    54e8:	89 83       	std	Y+1, r24	; 0x01
    54ea:	eb 81       	ldd	r30, Y+3	; 0x03
    54ec:	fc 81       	ldd	r31, Y+4	; 0x04
    54ee:	89 81       	ldd	r24, Y+1	; 0x01
    54f0:	9a 81       	ldd	r25, Y+2	; 0x02
    54f2:	95 83       	std	Z+5, r25	; 0x05
    54f4:	84 83       	std	Z+4, r24	; 0x04
    54f6:	e9 81       	ldd	r30, Y+1	; 0x01
    54f8:	fa 81       	ldd	r31, Y+2	; 0x02
    54fa:	84 81       	ldd	r24, Z+4	; 0x04
    54fc:	95 81       	ldd	r25, Z+5	; 0x05
    54fe:	eb 81       	ldd	r30, Y+3	; 0x03
    5500:	fc 81       	ldd	r31, Y+4	; 0x04
    5502:	97 83       	std	Z+7, r25	; 0x07
    5504:	86 83       	std	Z+6, r24	; 0x06
    5506:	e9 81       	ldd	r30, Y+1	; 0x01
    5508:	fa 81       	ldd	r31, Y+2	; 0x02
    550a:	04 80       	ldd	r0, Z+4	; 0x04
    550c:	f5 81       	ldd	r31, Z+5	; 0x05
    550e:	e0 2d       	mov	r30, r0
    5510:	8b 81       	ldd	r24, Y+3	; 0x03
    5512:	9c 81       	ldd	r25, Y+4	; 0x04
    5514:	02 96       	adiw	r24, 0x02	; 2
    5516:	93 83       	std	Z+3, r25	; 0x03
    5518:	82 83       	std	Z+2, r24	; 0x02
    551a:	8b 81       	ldd	r24, Y+3	; 0x03
    551c:	9c 81       	ldd	r25, Y+4	; 0x04
    551e:	02 96       	adiw	r24, 0x02	; 2
    5520:	e9 81       	ldd	r30, Y+1	; 0x01
    5522:	fa 81       	ldd	r31, Y+2	; 0x02
    5524:	95 83       	std	Z+5, r25	; 0x05
    5526:	84 83       	std	Z+4, r24	; 0x04
    5528:	eb 81       	ldd	r30, Y+3	; 0x03
    552a:	fc 81       	ldd	r31, Y+4	; 0x04
    552c:	86 89       	ldd	r24, Z+22	; 0x16
    552e:	28 2f       	mov	r18, r24
    5530:	30 e0       	ldi	r19, 0x00	; 0
    5532:	c9 01       	movw	r24, r18
    5534:	88 0f       	add	r24, r24
    5536:	99 1f       	adc	r25, r25
    5538:	88 0f       	add	r24, r24
    553a:	99 1f       	adc	r25, r25
    553c:	88 0f       	add	r24, r24
    553e:	99 1f       	adc	r25, r25
    5540:	82 0f       	add	r24, r18
    5542:	93 1f       	adc	r25, r19
    5544:	8d 55       	subi	r24, 0x5D	; 93
    5546:	99 4f       	sbci	r25, 0xF9	; 249
    5548:	eb 81       	ldd	r30, Y+3	; 0x03
    554a:	fc 81       	ldd	r31, Y+4	; 0x04
    554c:	93 87       	std	Z+11, r25	; 0x0b
    554e:	82 87       	std	Z+10, r24	; 0x0a
    5550:	eb 81       	ldd	r30, Y+3	; 0x03
    5552:	fc 81       	ldd	r31, Y+4	; 0x04
    5554:	86 89       	ldd	r24, Z+22	; 0x16
    5556:	28 2f       	mov	r18, r24
    5558:	30 e0       	ldi	r19, 0x00	; 0
    555a:	c9 01       	movw	r24, r18
    555c:	88 0f       	add	r24, r24
    555e:	99 1f       	adc	r25, r25
    5560:	88 0f       	add	r24, r24
    5562:	99 1f       	adc	r25, r25
    5564:	88 0f       	add	r24, r24
    5566:	99 1f       	adc	r25, r25
    5568:	82 0f       	add	r24, r18
    556a:	93 1f       	adc	r25, r19
    556c:	fc 01       	movw	r30, r24
    556e:	ed 55       	subi	r30, 0x5D	; 93
    5570:	f9 4f       	sbci	r31, 0xF9	; 249
    5572:	80 81       	ld	r24, Z
    5574:	8f 5f       	subi	r24, 0xFF	; 255
    5576:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    5578:	0f 90       	pop	r0
    557a:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    557c:	80 91 98 06 	lds	r24, 0x0698
    5580:	88 23       	and	r24, r24
    5582:	61 f0       	breq	.+24     	; 0x559c <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    5584:	e0 91 91 06 	lds	r30, 0x0691
    5588:	f0 91 92 06 	lds	r31, 0x0692
    558c:	96 89       	ldd	r25, Z+22	; 0x16
    558e:	eb 81       	ldd	r30, Y+3	; 0x03
    5590:	fc 81       	ldd	r31, Y+4	; 0x04
    5592:	86 89       	ldd	r24, Z+22	; 0x16
    5594:	98 17       	cp	r25, r24
    5596:	10 f4       	brcc	.+4      	; 0x559c <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    5598:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    559c:	0f 90       	pop	r0
    559e:	0f 90       	pop	r0
    55a0:	0f 90       	pop	r0
    55a2:	0f 90       	pop	r0
    55a4:	cf 91       	pop	r28
    55a6:	df 91       	pop	r29
    55a8:	08 95       	ret

000055aa <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    55aa:	df 93       	push	r29
    55ac:	cf 93       	push	r28
    55ae:	00 d0       	rcall	.+0      	; 0x55b0 <vTaskDelete+0x6>
    55b0:	00 d0       	rcall	.+0      	; 0x55b2 <vTaskDelete+0x8>
    55b2:	00 d0       	rcall	.+0      	; 0x55b4 <vTaskDelete+0xa>
    55b4:	cd b7       	in	r28, 0x3d	; 61
    55b6:	de b7       	in	r29, 0x3e	; 62
    55b8:	9c 83       	std	Y+4, r25	; 0x04
    55ba:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    55bc:	0f b6       	in	r0, 0x3f	; 63
    55be:	f8 94       	cli
    55c0:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    55c2:	8b 81       	ldd	r24, Y+3	; 0x03
    55c4:	9c 81       	ldd	r25, Y+4	; 0x04
    55c6:	00 97       	sbiw	r24, 0x00	; 0
    55c8:	39 f4       	brne	.+14     	; 0x55d8 <vTaskDelete+0x2e>
    55ca:	80 91 91 06 	lds	r24, 0x0691
    55ce:	90 91 92 06 	lds	r25, 0x0692
    55d2:	9e 83       	std	Y+6, r25	; 0x06
    55d4:	8d 83       	std	Y+5, r24	; 0x05
    55d6:	04 c0       	rjmp	.+8      	; 0x55e0 <vTaskDelete+0x36>
    55d8:	8b 81       	ldd	r24, Y+3	; 0x03
    55da:	9c 81       	ldd	r25, Y+4	; 0x04
    55dc:	9e 83       	std	Y+6, r25	; 0x06
    55de:	8d 83       	std	Y+5, r24	; 0x05
    55e0:	8d 81       	ldd	r24, Y+5	; 0x05
    55e2:	9e 81       	ldd	r25, Y+6	; 0x06
    55e4:	9a 83       	std	Y+2, r25	; 0x02
    55e6:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    55e8:	89 81       	ldd	r24, Y+1	; 0x01
    55ea:	9a 81       	ldd	r25, Y+2	; 0x02
    55ec:	02 96       	adiw	r24, 0x02	; 2
    55ee:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    55f2:	e9 81       	ldd	r30, Y+1	; 0x01
    55f4:	fa 81       	ldd	r31, Y+2	; 0x02
    55f6:	84 89       	ldd	r24, Z+20	; 0x14
    55f8:	95 89       	ldd	r25, Z+21	; 0x15
    55fa:	00 97       	sbiw	r24, 0x00	; 0
    55fc:	29 f0       	breq	.+10     	; 0x5608 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    55fe:	89 81       	ldd	r24, Y+1	; 0x01
    5600:	9a 81       	ldd	r25, Y+2	; 0x02
    5602:	0c 96       	adiw	r24, 0x0c	; 12
    5604:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    5608:	80 91 9d 06 	lds	r24, 0x069D
    560c:	8f 5f       	subi	r24, 0xFF	; 255
    560e:	80 93 9d 06 	sts	0x069D, r24

            if( pxTCB == pxCurrentTCB )
    5612:	20 91 91 06 	lds	r18, 0x0691
    5616:	30 91 92 06 	lds	r19, 0x0692
    561a:	89 81       	ldd	r24, Y+1	; 0x01
    561c:	9a 81       	ldd	r25, Y+2	; 0x02
    561e:	82 17       	cp	r24, r18
    5620:	93 07       	cpc	r25, r19
    5622:	81 f4       	brne	.+32     	; 0x5644 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    5624:	89 81       	ldd	r24, Y+1	; 0x01
    5626:	9a 81       	ldd	r25, Y+2	; 0x02
    5628:	9c 01       	movw	r18, r24
    562a:	2e 5f       	subi	r18, 0xFE	; 254
    562c:	3f 4f       	sbci	r19, 0xFF	; 255
    562e:	86 ee       	ldi	r24, 0xE6	; 230
    5630:	96 e0       	ldi	r25, 0x06	; 6
    5632:	b9 01       	movw	r22, r18
    5634:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    5638:	80 91 93 06 	lds	r24, 0x0693
    563c:	8f 5f       	subi	r24, 0xFF	; 255
    563e:	80 93 93 06 	sts	0x0693, r24
    5642:	07 c0       	rjmp	.+14     	; 0x5652 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    5644:	80 91 94 06 	lds	r24, 0x0694
    5648:	81 50       	subi	r24, 0x01	; 1
    564a:	80 93 94 06 	sts	0x0694, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    564e:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    5652:	0f 90       	pop	r0
    5654:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    5656:	20 91 91 06 	lds	r18, 0x0691
    565a:	30 91 92 06 	lds	r19, 0x0692
    565e:	89 81       	ldd	r24, Y+1	; 0x01
    5660:	9a 81       	ldd	r25, Y+2	; 0x02
    5662:	82 17       	cp	r24, r18
    5664:	93 07       	cpc	r25, r19
    5666:	21 f0       	breq	.+8      	; 0x5670 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    5668:	89 81       	ldd	r24, Y+1	; 0x01
    566a:	9a 81       	ldd	r25, Y+2	; 0x02
    566c:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    5670:	80 91 98 06 	lds	r24, 0x0698
    5674:	88 23       	and	r24, r24
    5676:	59 f0       	breq	.+22     	; 0x568e <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    5678:	20 91 91 06 	lds	r18, 0x0691
    567c:	30 91 92 06 	lds	r19, 0x0692
    5680:	89 81       	ldd	r24, Y+1	; 0x01
    5682:	9a 81       	ldd	r25, Y+2	; 0x02
    5684:	82 17       	cp	r24, r18
    5686:	93 07       	cpc	r25, r19
    5688:	11 f4       	brne	.+4      	; 0x568e <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    568a:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    568e:	26 96       	adiw	r28, 0x06	; 6
    5690:	0f b6       	in	r0, 0x3f	; 63
    5692:	f8 94       	cli
    5694:	de bf       	out	0x3e, r29	; 62
    5696:	0f be       	out	0x3f, r0	; 63
    5698:	cd bf       	out	0x3d, r28	; 61
    569a:	cf 91       	pop	r28
    569c:	df 91       	pop	r29
    569e:	08 95       	ret

000056a0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    56a0:	df 93       	push	r29
    56a2:	cf 93       	push	r28
    56a4:	00 d0       	rcall	.+0      	; 0x56a6 <vTaskDelay+0x6>
    56a6:	0f 92       	push	r0
    56a8:	cd b7       	in	r28, 0x3d	; 61
    56aa:	de b7       	in	r29, 0x3e	; 62
    56ac:	9b 83       	std	Y+3, r25	; 0x03
    56ae:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    56b0:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    56b2:	8a 81       	ldd	r24, Y+2	; 0x02
    56b4:	9b 81       	ldd	r25, Y+3	; 0x03
    56b6:	00 97       	sbiw	r24, 0x00	; 0
    56b8:	51 f0       	breq	.+20     	; 0x56ce <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    56ba:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    56be:	8a 81       	ldd	r24, Y+2	; 0x02
    56c0:	9b 81       	ldd	r25, Y+3	; 0x03
    56c2:	60 e0       	ldi	r22, 0x00	; 0
    56c4:	0e 94 a9 3d 	call	0x7b52	; 0x7b52 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    56c8:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    56cc:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    56ce:	89 81       	ldd	r24, Y+1	; 0x01
    56d0:	88 23       	and	r24, r24
    56d2:	11 f4       	brne	.+4      	; 0x56d8 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    56d4:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    56d8:	0f 90       	pop	r0
    56da:	0f 90       	pop	r0
    56dc:	0f 90       	pop	r0
    56de:	cf 91       	pop	r28
    56e0:	df 91       	pop	r29
    56e2:	08 95       	ret

000056e4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    56e4:	df 93       	push	r29
    56e6:	cf 93       	push	r28
    56e8:	cd b7       	in	r28, 0x3d	; 61
    56ea:	de b7       	in	r29, 0x3e	; 62
    56ec:	27 97       	sbiw	r28, 0x07	; 7
    56ee:	0f b6       	in	r0, 0x3f	; 63
    56f0:	f8 94       	cli
    56f2:	de bf       	out	0x3e, r29	; 62
    56f4:	0f be       	out	0x3f, r0	; 63
    56f6:	cd bf       	out	0x3d, r28	; 61
    56f8:	9d 83       	std	Y+5, r25	; 0x05
    56fa:	8c 83       	std	Y+4, r24	; 0x04
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    56fc:	0f b6       	in	r0, 0x3f	; 63
    56fe:	f8 94       	cli
    5700:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    5702:	8c 81       	ldd	r24, Y+4	; 0x04
    5704:	9d 81       	ldd	r25, Y+5	; 0x05
    5706:	00 97       	sbiw	r24, 0x00	; 0
    5708:	39 f4       	brne	.+14     	; 0x5718 <vTaskSuspend+0x34>
    570a:	80 91 91 06 	lds	r24, 0x0691
    570e:	90 91 92 06 	lds	r25, 0x0692
    5712:	9f 83       	std	Y+7, r25	; 0x07
    5714:	8e 83       	std	Y+6, r24	; 0x06
    5716:	04 c0       	rjmp	.+8      	; 0x5720 <vTaskSuspend+0x3c>
    5718:	8c 81       	ldd	r24, Y+4	; 0x04
    571a:	9d 81       	ldd	r25, Y+5	; 0x05
    571c:	9f 83       	std	Y+7, r25	; 0x07
    571e:	8e 83       	std	Y+6, r24	; 0x06
    5720:	8e 81       	ldd	r24, Y+6	; 0x06
    5722:	9f 81       	ldd	r25, Y+7	; 0x07
    5724:	9b 83       	std	Y+3, r25	; 0x03
    5726:	8a 83       	std	Y+2, r24	; 0x02

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5728:	8a 81       	ldd	r24, Y+2	; 0x02
    572a:	9b 81       	ldd	r25, Y+3	; 0x03
    572c:	02 96       	adiw	r24, 0x02	; 2
    572e:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5732:	ea 81       	ldd	r30, Y+2	; 0x02
    5734:	fb 81       	ldd	r31, Y+3	; 0x03
    5736:	84 89       	ldd	r24, Z+20	; 0x14
    5738:	95 89       	ldd	r25, Z+21	; 0x15
    573a:	00 97       	sbiw	r24, 0x00	; 0
    573c:	29 f0       	breq	.+10     	; 0x5748 <vTaskSuspend+0x64>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    573e:	8a 81       	ldd	r24, Y+2	; 0x02
    5740:	9b 81       	ldd	r25, Y+3	; 0x03
    5742:	0c 96       	adiw	r24, 0x0c	; 12
    5744:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    5748:	8a 81       	ldd	r24, Y+2	; 0x02
    574a:	9b 81       	ldd	r25, Y+3	; 0x03
    574c:	9c 01       	movw	r18, r24
    574e:	2e 5f       	subi	r18, 0xFE	; 254
    5750:	3f 4f       	sbci	r19, 0xFF	; 255
    5752:	8f ee       	ldi	r24, 0xEF	; 239
    5754:	96 e0       	ldi	r25, 0x06	; 6
    5756:	b9 01       	movw	r22, r18
    5758:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    575c:	19 82       	std	Y+1, r1	; 0x01
    575e:	1d c0       	rjmp	.+58     	; 0x579a <vTaskSuspend+0xb6>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    5760:	89 81       	ldd	r24, Y+1	; 0x01
    5762:	28 2f       	mov	r18, r24
    5764:	33 27       	eor	r19, r19
    5766:	27 fd       	sbrc	r18, 7
    5768:	30 95       	com	r19
    576a:	8a 81       	ldd	r24, Y+2	; 0x02
    576c:	9b 81       	ldd	r25, Y+3	; 0x03
    576e:	82 0f       	add	r24, r18
    5770:	93 1f       	adc	r25, r19
    5772:	fc 01       	movw	r30, r24
    5774:	bd 96       	adiw	r30, 0x2d	; 45
    5776:	80 81       	ld	r24, Z
    5778:	81 30       	cpi	r24, 0x01	; 1
    577a:	61 f4       	brne	.+24     	; 0x5794 <vTaskSuspend+0xb0>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    577c:	89 81       	ldd	r24, Y+1	; 0x01
    577e:	28 2f       	mov	r18, r24
    5780:	33 27       	eor	r19, r19
    5782:	27 fd       	sbrc	r18, 7
    5784:	30 95       	com	r19
    5786:	8a 81       	ldd	r24, Y+2	; 0x02
    5788:	9b 81       	ldd	r25, Y+3	; 0x03
    578a:	82 0f       	add	r24, r18
    578c:	93 1f       	adc	r25, r19
    578e:	fc 01       	movw	r30, r24
    5790:	bd 96       	adiw	r30, 0x2d	; 45
    5792:	10 82       	st	Z, r1

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    5794:	89 81       	ldd	r24, Y+1	; 0x01
    5796:	8f 5f       	subi	r24, 0xFF	; 255
    5798:	89 83       	std	Y+1, r24	; 0x01
    579a:	89 81       	ldd	r24, Y+1	; 0x01
    579c:	18 16       	cp	r1, r24
    579e:	04 f7       	brge	.-64     	; 0x5760 <vTaskSuspend+0x7c>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    57a0:	0f 90       	pop	r0
    57a2:	0f be       	out	0x3f, r0	; 63

        if( xSchedulerRunning != pdFALSE )
    57a4:	80 91 98 06 	lds	r24, 0x0698
    57a8:	88 23       	and	r24, r24
    57aa:	39 f0       	breq	.+14     	; 0x57ba <vTaskSuspend+0xd6>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    57ac:	0f b6       	in	r0, 0x3f	; 63
    57ae:	f8 94       	cli
    57b0:	0f 92       	push	r0
            {
                prvResetNextTaskUnblockTime();
    57b2:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
    57b6:	0f 90       	pop	r0
    57b8:	0f be       	out	0x3f, r0	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    57ba:	20 91 91 06 	lds	r18, 0x0691
    57be:	30 91 92 06 	lds	r19, 0x0692
    57c2:	8a 81       	ldd	r24, Y+2	; 0x02
    57c4:	9b 81       	ldd	r25, Y+3	; 0x03
    57c6:	82 17       	cp	r24, r18
    57c8:	93 07       	cpc	r25, r19
    57ca:	a1 f4       	brne	.+40     	; 0x57f4 <vTaskSuspend+0x110>
        {
            if( xSchedulerRunning != pdFALSE )
    57cc:	80 91 98 06 	lds	r24, 0x0698
    57d0:	88 23       	and	r24, r24
    57d2:	19 f0       	breq	.+6      	; 0x57da <vTaskSuspend+0xf6>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    57d4:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
    57d8:	0d c0       	rjmp	.+26     	; 0x57f4 <vTaskSuspend+0x110>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    57da:	90 91 ef 06 	lds	r25, 0x06EF
    57de:	80 91 94 06 	lds	r24, 0x0694
    57e2:	98 17       	cp	r25, r24
    57e4:	29 f4       	brne	.+10     	; 0x57f0 <vTaskSuspend+0x10c>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
    57e6:	10 92 92 06 	sts	0x0692, r1
    57ea:	10 92 91 06 	sts	0x0691, r1
    57ee:	02 c0       	rjmp	.+4      	; 0x57f4 <vTaskSuspend+0x110>
                }
                else
                {
                    vTaskSwitchContext();
    57f0:	0e 94 41 31 	call	0x6282	; 0x6282 <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    57f4:	27 96       	adiw	r28, 0x07	; 7
    57f6:	0f b6       	in	r0, 0x3f	; 63
    57f8:	f8 94       	cli
    57fa:	de bf       	out	0x3e, r29	; 62
    57fc:	0f be       	out	0x3f, r0	; 63
    57fe:	cd bf       	out	0x3d, r28	; 61
    5800:	cf 91       	pop	r28
    5802:	df 91       	pop	r29
    5804:	08 95       	ret

00005806 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
    5806:	df 93       	push	r29
    5808:	cf 93       	push	r28
    580a:	00 d0       	rcall	.+0      	; 0x580c <prvTaskIsTaskSuspended+0x6>
    580c:	00 d0       	rcall	.+0      	; 0x580e <prvTaskIsTaskSuspended+0x8>
    580e:	0f 92       	push	r0
    5810:	cd b7       	in	r28, 0x3d	; 61
    5812:	de b7       	in	r29, 0x3e	; 62
    5814:	9d 83       	std	Y+5, r25	; 0x05
    5816:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    5818:	1b 82       	std	Y+3, r1	; 0x03
        const TCB_t * const pxTCB = xTask;
    581a:	8c 81       	ldd	r24, Y+4	; 0x04
    581c:	9d 81       	ldd	r25, Y+5	; 0x05
    581e:	9a 83       	std	Y+2, r25	; 0x02
    5820:	89 83       	std	Y+1, r24	; 0x01

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    5822:	e9 81       	ldd	r30, Y+1	; 0x01
    5824:	fa 81       	ldd	r31, Y+2	; 0x02
    5826:	82 85       	ldd	r24, Z+10	; 0x0a
    5828:	93 85       	ldd	r25, Z+11	; 0x0b
    582a:	26 e0       	ldi	r18, 0x06	; 6
    582c:	8f 3e       	cpi	r24, 0xEF	; 239
    582e:	92 07       	cpc	r25, r18
    5830:	81 f4       	brne	.+32     	; 0x5852 <prvTaskIsTaskSuspended+0x4c>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    5832:	e9 81       	ldd	r30, Y+1	; 0x01
    5834:	fa 81       	ldd	r31, Y+2	; 0x02
    5836:	84 89       	ldd	r24, Z+20	; 0x14
    5838:	95 89       	ldd	r25, Z+21	; 0x15
    583a:	26 e0       	ldi	r18, 0x06	; 6
    583c:	8d 3d       	cpi	r24, 0xDD	; 221
    583e:	92 07       	cpc	r25, r18
    5840:	41 f0       	breq	.+16     	; 0x5852 <prvTaskIsTaskSuspended+0x4c>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    5842:	e9 81       	ldd	r30, Y+1	; 0x01
    5844:	fa 81       	ldd	r31, Y+2	; 0x02
    5846:	84 89       	ldd	r24, Z+20	; 0x14
    5848:	95 89       	ldd	r25, Z+21	; 0x15
    584a:	00 97       	sbiw	r24, 0x00	; 0
    584c:	11 f4       	brne	.+4      	; 0x5852 <prvTaskIsTaskSuspended+0x4c>
                {
                    xReturn = pdTRUE;
    584e:	81 e0       	ldi	r24, 0x01	; 1
    5850:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    5852:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    5854:	0f 90       	pop	r0
    5856:	0f 90       	pop	r0
    5858:	0f 90       	pop	r0
    585a:	0f 90       	pop	r0
    585c:	0f 90       	pop	r0
    585e:	cf 91       	pop	r28
    5860:	df 91       	pop	r29
    5862:	08 95       	ret

00005864 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    5864:	df 93       	push	r29
    5866:	cf 93       	push	r28
    5868:	00 d0       	rcall	.+0      	; 0x586a <vTaskResume+0x6>
    586a:	00 d0       	rcall	.+0      	; 0x586c <vTaskResume+0x8>
    586c:	00 d0       	rcall	.+0      	; 0x586e <vTaskResume+0xa>
    586e:	cd b7       	in	r28, 0x3d	; 61
    5870:	de b7       	in	r29, 0x3e	; 62
    5872:	9e 83       	std	Y+6, r25	; 0x06
    5874:	8d 83       	std	Y+5, r24	; 0x05
        TCB_t * const pxTCB = xTaskToResume;
    5876:	8d 81       	ldd	r24, Y+5	; 0x05
    5878:	9e 81       	ldd	r25, Y+6	; 0x06
    587a:	9c 83       	std	Y+4, r25	; 0x04
    587c:	8b 83       	std	Y+3, r24	; 0x03
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    587e:	20 91 91 06 	lds	r18, 0x0691
    5882:	30 91 92 06 	lds	r19, 0x0692
    5886:	8b 81       	ldd	r24, Y+3	; 0x03
    5888:	9c 81       	ldd	r25, Y+4	; 0x04
    588a:	82 17       	cp	r24, r18
    588c:	93 07       	cpc	r25, r19
    588e:	09 f4       	brne	.+2      	; 0x5892 <vTaskResume+0x2e>
    5890:	8a c0       	rjmp	.+276    	; 0x59a6 <vTaskResume+0x142>
    5892:	8b 81       	ldd	r24, Y+3	; 0x03
    5894:	9c 81       	ldd	r25, Y+4	; 0x04
    5896:	00 97       	sbiw	r24, 0x00	; 0
    5898:	09 f4       	brne	.+2      	; 0x589c <vTaskResume+0x38>
    589a:	85 c0       	rjmp	.+266    	; 0x59a6 <vTaskResume+0x142>
        {
            taskENTER_CRITICAL();
    589c:	0f b6       	in	r0, 0x3f	; 63
    589e:	f8 94       	cli
    58a0:	0f 92       	push	r0
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    58a2:	8b 81       	ldd	r24, Y+3	; 0x03
    58a4:	9c 81       	ldd	r25, Y+4	; 0x04
    58a6:	0e 94 03 2c 	call	0x5806	; 0x5806 <prvTaskIsTaskSuspended>
    58aa:	88 23       	and	r24, r24
    58ac:	09 f4       	brne	.+2      	; 0x58b0 <vTaskResume+0x4c>
    58ae:	79 c0       	rjmp	.+242    	; 0x59a2 <vTaskResume+0x13e>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    58b0:	8b 81       	ldd	r24, Y+3	; 0x03
    58b2:	9c 81       	ldd	r25, Y+4	; 0x04
    58b4:	02 96       	adiw	r24, 0x02	; 2
    58b6:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    58ba:	eb 81       	ldd	r30, Y+3	; 0x03
    58bc:	fc 81       	ldd	r31, Y+4	; 0x04
    58be:	96 89       	ldd	r25, Z+22	; 0x16
    58c0:	80 91 97 06 	lds	r24, 0x0697
    58c4:	89 17       	cp	r24, r25
    58c6:	28 f4       	brcc	.+10     	; 0x58d2 <vTaskResume+0x6e>
    58c8:	eb 81       	ldd	r30, Y+3	; 0x03
    58ca:	fc 81       	ldd	r31, Y+4	; 0x04
    58cc:	86 89       	ldd	r24, Z+22	; 0x16
    58ce:	80 93 97 06 	sts	0x0697, r24
    58d2:	eb 81       	ldd	r30, Y+3	; 0x03
    58d4:	fc 81       	ldd	r31, Y+4	; 0x04
    58d6:	86 89       	ldd	r24, Z+22	; 0x16
    58d8:	28 2f       	mov	r18, r24
    58da:	30 e0       	ldi	r19, 0x00	; 0
    58dc:	c9 01       	movw	r24, r18
    58de:	88 0f       	add	r24, r24
    58e0:	99 1f       	adc	r25, r25
    58e2:	88 0f       	add	r24, r24
    58e4:	99 1f       	adc	r25, r25
    58e6:	88 0f       	add	r24, r24
    58e8:	99 1f       	adc	r25, r25
    58ea:	82 0f       	add	r24, r18
    58ec:	93 1f       	adc	r25, r19
    58ee:	fc 01       	movw	r30, r24
    58f0:	ed 55       	subi	r30, 0x5D	; 93
    58f2:	f9 4f       	sbci	r31, 0xF9	; 249
    58f4:	81 81       	ldd	r24, Z+1	; 0x01
    58f6:	92 81       	ldd	r25, Z+2	; 0x02
    58f8:	9a 83       	std	Y+2, r25	; 0x02
    58fa:	89 83       	std	Y+1, r24	; 0x01
    58fc:	eb 81       	ldd	r30, Y+3	; 0x03
    58fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5900:	89 81       	ldd	r24, Y+1	; 0x01
    5902:	9a 81       	ldd	r25, Y+2	; 0x02
    5904:	95 83       	std	Z+5, r25	; 0x05
    5906:	84 83       	std	Z+4, r24	; 0x04
    5908:	e9 81       	ldd	r30, Y+1	; 0x01
    590a:	fa 81       	ldd	r31, Y+2	; 0x02
    590c:	84 81       	ldd	r24, Z+4	; 0x04
    590e:	95 81       	ldd	r25, Z+5	; 0x05
    5910:	eb 81       	ldd	r30, Y+3	; 0x03
    5912:	fc 81       	ldd	r31, Y+4	; 0x04
    5914:	97 83       	std	Z+7, r25	; 0x07
    5916:	86 83       	std	Z+6, r24	; 0x06
    5918:	e9 81       	ldd	r30, Y+1	; 0x01
    591a:	fa 81       	ldd	r31, Y+2	; 0x02
    591c:	04 80       	ldd	r0, Z+4	; 0x04
    591e:	f5 81       	ldd	r31, Z+5	; 0x05
    5920:	e0 2d       	mov	r30, r0
    5922:	8b 81       	ldd	r24, Y+3	; 0x03
    5924:	9c 81       	ldd	r25, Y+4	; 0x04
    5926:	02 96       	adiw	r24, 0x02	; 2
    5928:	93 83       	std	Z+3, r25	; 0x03
    592a:	82 83       	std	Z+2, r24	; 0x02
    592c:	8b 81       	ldd	r24, Y+3	; 0x03
    592e:	9c 81       	ldd	r25, Y+4	; 0x04
    5930:	02 96       	adiw	r24, 0x02	; 2
    5932:	e9 81       	ldd	r30, Y+1	; 0x01
    5934:	fa 81       	ldd	r31, Y+2	; 0x02
    5936:	95 83       	std	Z+5, r25	; 0x05
    5938:	84 83       	std	Z+4, r24	; 0x04
    593a:	eb 81       	ldd	r30, Y+3	; 0x03
    593c:	fc 81       	ldd	r31, Y+4	; 0x04
    593e:	86 89       	ldd	r24, Z+22	; 0x16
    5940:	28 2f       	mov	r18, r24
    5942:	30 e0       	ldi	r19, 0x00	; 0
    5944:	c9 01       	movw	r24, r18
    5946:	88 0f       	add	r24, r24
    5948:	99 1f       	adc	r25, r25
    594a:	88 0f       	add	r24, r24
    594c:	99 1f       	adc	r25, r25
    594e:	88 0f       	add	r24, r24
    5950:	99 1f       	adc	r25, r25
    5952:	82 0f       	add	r24, r18
    5954:	93 1f       	adc	r25, r19
    5956:	8d 55       	subi	r24, 0x5D	; 93
    5958:	99 4f       	sbci	r25, 0xF9	; 249
    595a:	eb 81       	ldd	r30, Y+3	; 0x03
    595c:	fc 81       	ldd	r31, Y+4	; 0x04
    595e:	93 87       	std	Z+11, r25	; 0x0b
    5960:	82 87       	std	Z+10, r24	; 0x0a
    5962:	eb 81       	ldd	r30, Y+3	; 0x03
    5964:	fc 81       	ldd	r31, Y+4	; 0x04
    5966:	86 89       	ldd	r24, Z+22	; 0x16
    5968:	28 2f       	mov	r18, r24
    596a:	30 e0       	ldi	r19, 0x00	; 0
    596c:	c9 01       	movw	r24, r18
    596e:	88 0f       	add	r24, r24
    5970:	99 1f       	adc	r25, r25
    5972:	88 0f       	add	r24, r24
    5974:	99 1f       	adc	r25, r25
    5976:	88 0f       	add	r24, r24
    5978:	99 1f       	adc	r25, r25
    597a:	82 0f       	add	r24, r18
    597c:	93 1f       	adc	r25, r19
    597e:	fc 01       	movw	r30, r24
    5980:	ed 55       	subi	r30, 0x5D	; 93
    5982:	f9 4f       	sbci	r31, 0xF9	; 249
    5984:	80 81       	ld	r24, Z
    5986:	8f 5f       	subi	r24, 0xFF	; 255
    5988:	80 83       	st	Z, r24

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    598a:	eb 81       	ldd	r30, Y+3	; 0x03
    598c:	fc 81       	ldd	r31, Y+4	; 0x04
    598e:	96 89       	ldd	r25, Z+22	; 0x16
    5990:	e0 91 91 06 	lds	r30, 0x0691
    5994:	f0 91 92 06 	lds	r31, 0x0692
    5998:	86 89       	ldd	r24, Z+22	; 0x16
    599a:	98 17       	cp	r25, r24
    599c:	10 f0       	brcs	.+4      	; 0x59a2 <vTaskResume+0x13e>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    599e:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    59a2:	0f 90       	pop	r0
    59a4:	0f be       	out	0x3f, r0	; 63
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    59a6:	26 96       	adiw	r28, 0x06	; 6
    59a8:	0f b6       	in	r0, 0x3f	; 63
    59aa:	f8 94       	cli
    59ac:	de bf       	out	0x3e, r29	; 62
    59ae:	0f be       	out	0x3f, r0	; 63
    59b0:	cd bf       	out	0x3d, r28	; 61
    59b2:	cf 91       	pop	r28
    59b4:	df 91       	pop	r29
    59b6:	08 95       	ret

000059b8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    59b8:	df 93       	push	r29
    59ba:	cf 93       	push	r28
    59bc:	cd b7       	in	r28, 0x3d	; 61
    59be:	de b7       	in	r29, 0x3e	; 62
    59c0:	28 97       	sbiw	r28, 0x08	; 8
    59c2:	0f b6       	in	r0, 0x3f	; 63
    59c4:	f8 94       	cli
    59c6:	de bf       	out	0x3e, r29	; 62
    59c8:	0f be       	out	0x3f, r0	; 63
    59ca:	cd bf       	out	0x3d, r28	; 61
    59cc:	98 87       	std	Y+8, r25	; 0x08
    59ce:	8f 83       	std	Y+7, r24	; 0x07
        BaseType_t xYieldRequired = pdFALSE;
    59d0:	1e 82       	std	Y+6, r1	; 0x06
        TCB_t * const pxTCB = xTaskToResume;
    59d2:	8f 81       	ldd	r24, Y+7	; 0x07
    59d4:	98 85       	ldd	r25, Y+8	; 0x08
    59d6:	9d 83       	std	Y+5, r25	; 0x05
    59d8:	8c 83       	std	Y+4, r24	; 0x04
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    59da:	1b 82       	std	Y+3, r1	; 0x03
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    59dc:	8c 81       	ldd	r24, Y+4	; 0x04
    59de:	9d 81       	ldd	r25, Y+5	; 0x05
    59e0:	0e 94 03 2c 	call	0x5806	; 0x5806 <prvTaskIsTaskSuspended>
    59e4:	88 23       	and	r24, r24
    59e6:	09 f4       	brne	.+2      	; 0x59ea <xTaskResumeFromISR+0x32>
    59e8:	8c c0       	rjmp	.+280    	; 0x5b02 <xTaskResumeFromISR+0x14a>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    59ea:	80 91 a2 06 	lds	r24, 0x06A2
    59ee:	88 23       	and	r24, r24
    59f0:	09 f0       	breq	.+2      	; 0x59f4 <xTaskResumeFromISR+0x3c>
    59f2:	7d c0       	rjmp	.+250    	; 0x5aee <xTaskResumeFromISR+0x136>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    59f4:	ec 81       	ldd	r30, Y+4	; 0x04
    59f6:	fd 81       	ldd	r31, Y+5	; 0x05
    59f8:	96 89       	ldd	r25, Z+22	; 0x16
    59fa:	e0 91 91 06 	lds	r30, 0x0691
    59fe:	f0 91 92 06 	lds	r31, 0x0692
    5a02:	86 89       	ldd	r24, Z+22	; 0x16
    5a04:	98 17       	cp	r25, r24
    5a06:	28 f0       	brcs	.+10     	; 0x5a12 <xTaskResumeFromISR+0x5a>
                    {
                        xYieldRequired = pdTRUE;
    5a08:	81 e0       	ldi	r24, 0x01	; 1
    5a0a:	8e 83       	std	Y+6, r24	; 0x06

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
    5a0c:	81 e0       	ldi	r24, 0x01	; 1
    5a0e:	80 93 9b 06 	sts	0x069B, r24
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5a12:	8c 81       	ldd	r24, Y+4	; 0x04
    5a14:	9d 81       	ldd	r25, Y+5	; 0x05
    5a16:	02 96       	adiw	r24, 0x02	; 2
    5a18:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    5a1c:	ec 81       	ldd	r30, Y+4	; 0x04
    5a1e:	fd 81       	ldd	r31, Y+5	; 0x05
    5a20:	96 89       	ldd	r25, Z+22	; 0x16
    5a22:	80 91 97 06 	lds	r24, 0x0697
    5a26:	89 17       	cp	r24, r25
    5a28:	28 f4       	brcc	.+10     	; 0x5a34 <xTaskResumeFromISR+0x7c>
    5a2a:	ec 81       	ldd	r30, Y+4	; 0x04
    5a2c:	fd 81       	ldd	r31, Y+5	; 0x05
    5a2e:	86 89       	ldd	r24, Z+22	; 0x16
    5a30:	80 93 97 06 	sts	0x0697, r24
    5a34:	ec 81       	ldd	r30, Y+4	; 0x04
    5a36:	fd 81       	ldd	r31, Y+5	; 0x05
    5a38:	86 89       	ldd	r24, Z+22	; 0x16
    5a3a:	28 2f       	mov	r18, r24
    5a3c:	30 e0       	ldi	r19, 0x00	; 0
    5a3e:	c9 01       	movw	r24, r18
    5a40:	88 0f       	add	r24, r24
    5a42:	99 1f       	adc	r25, r25
    5a44:	88 0f       	add	r24, r24
    5a46:	99 1f       	adc	r25, r25
    5a48:	88 0f       	add	r24, r24
    5a4a:	99 1f       	adc	r25, r25
    5a4c:	82 0f       	add	r24, r18
    5a4e:	93 1f       	adc	r25, r19
    5a50:	fc 01       	movw	r30, r24
    5a52:	ed 55       	subi	r30, 0x5D	; 93
    5a54:	f9 4f       	sbci	r31, 0xF9	; 249
    5a56:	81 81       	ldd	r24, Z+1	; 0x01
    5a58:	92 81       	ldd	r25, Z+2	; 0x02
    5a5a:	9a 83       	std	Y+2, r25	; 0x02
    5a5c:	89 83       	std	Y+1, r24	; 0x01
    5a5e:	ec 81       	ldd	r30, Y+4	; 0x04
    5a60:	fd 81       	ldd	r31, Y+5	; 0x05
    5a62:	89 81       	ldd	r24, Y+1	; 0x01
    5a64:	9a 81       	ldd	r25, Y+2	; 0x02
    5a66:	95 83       	std	Z+5, r25	; 0x05
    5a68:	84 83       	std	Z+4, r24	; 0x04
    5a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a6e:	84 81       	ldd	r24, Z+4	; 0x04
    5a70:	95 81       	ldd	r25, Z+5	; 0x05
    5a72:	ec 81       	ldd	r30, Y+4	; 0x04
    5a74:	fd 81       	ldd	r31, Y+5	; 0x05
    5a76:	97 83       	std	Z+7, r25	; 0x07
    5a78:	86 83       	std	Z+6, r24	; 0x06
    5a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7e:	04 80       	ldd	r0, Z+4	; 0x04
    5a80:	f5 81       	ldd	r31, Z+5	; 0x05
    5a82:	e0 2d       	mov	r30, r0
    5a84:	8c 81       	ldd	r24, Y+4	; 0x04
    5a86:	9d 81       	ldd	r25, Y+5	; 0x05
    5a88:	02 96       	adiw	r24, 0x02	; 2
    5a8a:	93 83       	std	Z+3, r25	; 0x03
    5a8c:	82 83       	std	Z+2, r24	; 0x02
    5a8e:	8c 81       	ldd	r24, Y+4	; 0x04
    5a90:	9d 81       	ldd	r25, Y+5	; 0x05
    5a92:	02 96       	adiw	r24, 0x02	; 2
    5a94:	e9 81       	ldd	r30, Y+1	; 0x01
    5a96:	fa 81       	ldd	r31, Y+2	; 0x02
    5a98:	95 83       	std	Z+5, r25	; 0x05
    5a9a:	84 83       	std	Z+4, r24	; 0x04
    5a9c:	ec 81       	ldd	r30, Y+4	; 0x04
    5a9e:	fd 81       	ldd	r31, Y+5	; 0x05
    5aa0:	86 89       	ldd	r24, Z+22	; 0x16
    5aa2:	28 2f       	mov	r18, r24
    5aa4:	30 e0       	ldi	r19, 0x00	; 0
    5aa6:	c9 01       	movw	r24, r18
    5aa8:	88 0f       	add	r24, r24
    5aaa:	99 1f       	adc	r25, r25
    5aac:	88 0f       	add	r24, r24
    5aae:	99 1f       	adc	r25, r25
    5ab0:	88 0f       	add	r24, r24
    5ab2:	99 1f       	adc	r25, r25
    5ab4:	82 0f       	add	r24, r18
    5ab6:	93 1f       	adc	r25, r19
    5ab8:	8d 55       	subi	r24, 0x5D	; 93
    5aba:	99 4f       	sbci	r25, 0xF9	; 249
    5abc:	ec 81       	ldd	r30, Y+4	; 0x04
    5abe:	fd 81       	ldd	r31, Y+5	; 0x05
    5ac0:	93 87       	std	Z+11, r25	; 0x0b
    5ac2:	82 87       	std	Z+10, r24	; 0x0a
    5ac4:	ec 81       	ldd	r30, Y+4	; 0x04
    5ac6:	fd 81       	ldd	r31, Y+5	; 0x05
    5ac8:	86 89       	ldd	r24, Z+22	; 0x16
    5aca:	28 2f       	mov	r18, r24
    5acc:	30 e0       	ldi	r19, 0x00	; 0
    5ace:	c9 01       	movw	r24, r18
    5ad0:	88 0f       	add	r24, r24
    5ad2:	99 1f       	adc	r25, r25
    5ad4:	88 0f       	add	r24, r24
    5ad6:	99 1f       	adc	r25, r25
    5ad8:	88 0f       	add	r24, r24
    5ada:	99 1f       	adc	r25, r25
    5adc:	82 0f       	add	r24, r18
    5ade:	93 1f       	adc	r25, r19
    5ae0:	fc 01       	movw	r30, r24
    5ae2:	ed 55       	subi	r30, 0x5D	; 93
    5ae4:	f9 4f       	sbci	r31, 0xF9	; 249
    5ae6:	80 81       	ld	r24, Z
    5ae8:	8f 5f       	subi	r24, 0xFF	; 255
    5aea:	80 83       	st	Z, r24
    5aec:	0a c0       	rjmp	.+20     	; 0x5b02 <xTaskResumeFromISR+0x14a>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5aee:	8c 81       	ldd	r24, Y+4	; 0x04
    5af0:	9d 81       	ldd	r25, Y+5	; 0x05
    5af2:	9c 01       	movw	r18, r24
    5af4:	24 5f       	subi	r18, 0xF4	; 244
    5af6:	3f 4f       	sbci	r19, 0xFF	; 255
    5af8:	8d ed       	ldi	r24, 0xDD	; 221
    5afa:	96 e0       	ldi	r25, 0x06	; 6
    5afc:	b9 01       	movw	r22, r18
    5afe:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    5b02:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    5b04:	28 96       	adiw	r28, 0x08	; 8
    5b06:	0f b6       	in	r0, 0x3f	; 63
    5b08:	f8 94       	cli
    5b0a:	de bf       	out	0x3e, r29	; 62
    5b0c:	0f be       	out	0x3f, r0	; 63
    5b0e:	cd bf       	out	0x3d, r28	; 61
    5b10:	cf 91       	pop	r28
    5b12:	df 91       	pop	r29
    5b14:	08 95       	ret

00005b16 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    5b16:	ef 92       	push	r14
    5b18:	ff 92       	push	r15
    5b1a:	0f 93       	push	r16
    5b1c:	df 93       	push	r29
    5b1e:	cf 93       	push	r28
    5b20:	00 d0       	rcall	.+0      	; 0x5b22 <vTaskStartScheduler+0xc>
    5b22:	cd b7       	in	r28, 0x3d	; 61
    5b24:	de b7       	in	r29, 0x3e	; 62
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    5b26:	89 e3       	ldi	r24, 0x39	; 57
    5b28:	95 e3       	ldi	r25, 0x35	; 53
    5b2a:	20 e6       	ldi	r18, 0x60	; 96
    5b2c:	30 e0       	ldi	r19, 0x00	; 0
    5b2e:	e0 ea       	ldi	r30, 0xA0	; 160
    5b30:	f6 e0       	ldi	r31, 0x06	; 6
    5b32:	b9 01       	movw	r22, r18
    5b34:	45 e5       	ldi	r20, 0x55	; 85
    5b36:	50 e0       	ldi	r21, 0x00	; 0
    5b38:	20 e0       	ldi	r18, 0x00	; 0
    5b3a:	30 e0       	ldi	r19, 0x00	; 0
    5b3c:	00 e0       	ldi	r16, 0x00	; 0
    5b3e:	7f 01       	movw	r14, r30
    5b40:	0e 94 e9 28 	call	0x51d2	; 0x51d2 <xTaskCreate>
    5b44:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    5b46:	89 81       	ldd	r24, Y+1	; 0x01
    5b48:	81 30       	cpi	r24, 0x01	; 1
    5b4a:	81 f4       	brne	.+32     	; 0x5b6c <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    5b4c:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    5b4e:	8f ef       	ldi	r24, 0xFF	; 255
    5b50:	9f ef       	ldi	r25, 0xFF	; 255
    5b52:	90 93 9f 06 	sts	0x069F, r25
    5b56:	80 93 9e 06 	sts	0x069E, r24
        xSchedulerRunning = pdTRUE;
    5b5a:	81 e0       	ldi	r24, 0x01	; 1
    5b5c:	80 93 98 06 	sts	0x0698, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    5b60:	10 92 96 06 	sts	0x0696, r1
    5b64:	10 92 95 06 	sts	0x0695, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    5b68:	0e 94 15 18 	call	0x302a	; 0x302a <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    5b6c:	80 91 a4 00 	lds	r24, 0x00A4
}
    5b70:	0f 90       	pop	r0
    5b72:	0f 90       	pop	r0
    5b74:	cf 91       	pop	r28
    5b76:	df 91       	pop	r29
    5b78:	0f 91       	pop	r16
    5b7a:	ff 90       	pop	r15
    5b7c:	ef 90       	pop	r14
    5b7e:	08 95       	ret

00005b80 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    5b80:	df 93       	push	r29
    5b82:	cf 93       	push	r28
    5b84:	cd b7       	in	r28, 0x3d	; 61
    5b86:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    5b88:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    5b8a:	10 92 98 06 	sts	0x0698, r1
    vPortEndScheduler();
    5b8e:	0e 94 4a 18 	call	0x3094	; 0x3094 <vPortEndScheduler>
}
    5b92:	cf 91       	pop	r28
    5b94:	df 91       	pop	r29
    5b96:	08 95       	ret

00005b98 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    5b98:	df 93       	push	r29
    5b9a:	cf 93       	push	r28
    5b9c:	cd b7       	in	r28, 0x3d	; 61
    5b9e:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    5ba0:	80 91 a2 06 	lds	r24, 0x06A2
    5ba4:	8f 5f       	subi	r24, 0xFF	; 255
    5ba6:	80 93 a2 06 	sts	0x06A2, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    5baa:	cf 91       	pop	r28
    5bac:	df 91       	pop	r29
    5bae:	08 95       	ret

00005bb0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5bb0:	df 93       	push	r29
    5bb2:	cf 93       	push	r28
    5bb4:	cd b7       	in	r28, 0x3d	; 61
    5bb6:	de b7       	in	r29, 0x3e	; 62
    5bb8:	2b 97       	sbiw	r28, 0x0b	; 11
    5bba:	0f b6       	in	r0, 0x3f	; 63
    5bbc:	f8 94       	cli
    5bbe:	de bf       	out	0x3e, r29	; 62
    5bc0:	0f be       	out	0x3f, r0	; 63
    5bc2:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    5bc4:	1b 86       	std	Y+11, r1	; 0x0b
    5bc6:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    5bc8:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    5bca:	0f b6       	in	r0, 0x3f	; 63
    5bcc:	f8 94       	cli
    5bce:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    5bd0:	80 91 a2 06 	lds	r24, 0x06A2
    5bd4:	81 50       	subi	r24, 0x01	; 1
    5bd6:	80 93 a2 06 	sts	0x06A2, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5bda:	80 91 a2 06 	lds	r24, 0x06A2
    5bde:	88 23       	and	r24, r24
    5be0:	09 f0       	breq	.+2      	; 0x5be4 <xTaskResumeAll+0x34>
    5be2:	2a c1       	rjmp	.+596    	; 0x5e38 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    5be4:	80 91 94 06 	lds	r24, 0x0694
    5be8:	88 23       	and	r24, r24
    5bea:	09 f4       	brne	.+2      	; 0x5bee <xTaskResumeAll+0x3e>
    5bec:	25 c1       	rjmp	.+586    	; 0x5e38 <xTaskResumeAll+0x288>
    5bee:	f3 c0       	rjmp	.+486    	; 0x5dd6 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5bf0:	e0 91 e2 06 	lds	r30, 0x06E2
    5bf4:	f0 91 e3 06 	lds	r31, 0x06E3
    5bf8:	86 81       	ldd	r24, Z+6	; 0x06
    5bfa:	97 81       	ldd	r25, Z+7	; 0x07
    5bfc:	9b 87       	std	Y+11, r25	; 0x0b
    5bfe:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    5c00:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c02:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c04:	84 89       	ldd	r24, Z+20	; 0x14
    5c06:	95 89       	ldd	r25, Z+21	; 0x15
    5c08:	98 87       	std	Y+8, r25	; 0x08
    5c0a:	8f 83       	std	Y+7, r24	; 0x07
    5c0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c10:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c12:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c14:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c16:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c18:	80 89       	ldd	r24, Z+16	; 0x10
    5c1a:	91 89       	ldd	r25, Z+17	; 0x11
    5c1c:	15 96       	adiw	r26, 0x05	; 5
    5c1e:	9c 93       	st	X, r25
    5c20:	8e 93       	st	-X, r24
    5c22:	14 97       	sbiw	r26, 0x04	; 4
    5c24:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c26:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c28:	a0 89       	ldd	r26, Z+16	; 0x10
    5c2a:	b1 89       	ldd	r27, Z+17	; 0x11
    5c2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c30:	86 85       	ldd	r24, Z+14	; 0x0e
    5c32:	97 85       	ldd	r25, Z+15	; 0x0f
    5c34:	13 96       	adiw	r26, 0x03	; 3
    5c36:	9c 93       	st	X, r25
    5c38:	8e 93       	st	-X, r24
    5c3a:	12 97       	sbiw	r26, 0x02	; 2
    5c3c:	ef 81       	ldd	r30, Y+7	; 0x07
    5c3e:	f8 85       	ldd	r31, Y+8	; 0x08
    5c40:	21 81       	ldd	r18, Z+1	; 0x01
    5c42:	32 81       	ldd	r19, Z+2	; 0x02
    5c44:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c46:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c48:	0c 96       	adiw	r24, 0x0c	; 12
    5c4a:	28 17       	cp	r18, r24
    5c4c:	39 07       	cpc	r19, r25
    5c4e:	41 f4       	brne	.+16     	; 0x5c60 <xTaskResumeAll+0xb0>
    5c50:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c52:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c54:	80 89       	ldd	r24, Z+16	; 0x10
    5c56:	91 89       	ldd	r25, Z+17	; 0x11
    5c58:	ef 81       	ldd	r30, Y+7	; 0x07
    5c5a:	f8 85       	ldd	r31, Y+8	; 0x08
    5c5c:	92 83       	std	Z+2, r25	; 0x02
    5c5e:	81 83       	std	Z+1, r24	; 0x01
    5c60:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c62:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c64:	15 8a       	std	Z+21, r1	; 0x15
    5c66:	14 8a       	std	Z+20, r1	; 0x14
    5c68:	ef 81       	ldd	r30, Y+7	; 0x07
    5c6a:	f8 85       	ldd	r31, Y+8	; 0x08
    5c6c:	80 81       	ld	r24, Z
    5c6e:	81 50       	subi	r24, 0x01	; 1
    5c70:	ef 81       	ldd	r30, Y+7	; 0x07
    5c72:	f8 85       	ldd	r31, Y+8	; 0x08
    5c74:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5c76:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c78:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c7a:	82 85       	ldd	r24, Z+10	; 0x0a
    5c7c:	93 85       	ldd	r25, Z+11	; 0x0b
    5c7e:	9e 83       	std	Y+6, r25	; 0x06
    5c80:	8d 83       	std	Y+5, r24	; 0x05
    5c82:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c84:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c86:	a4 81       	ldd	r26, Z+4	; 0x04
    5c88:	b5 81       	ldd	r27, Z+5	; 0x05
    5c8a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c8c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c8e:	86 81       	ldd	r24, Z+6	; 0x06
    5c90:	97 81       	ldd	r25, Z+7	; 0x07
    5c92:	15 96       	adiw	r26, 0x05	; 5
    5c94:	9c 93       	st	X, r25
    5c96:	8e 93       	st	-X, r24
    5c98:	14 97       	sbiw	r26, 0x04	; 4
    5c9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c9e:	a6 81       	ldd	r26, Z+6	; 0x06
    5ca0:	b7 81       	ldd	r27, Z+7	; 0x07
    5ca2:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ca4:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ca6:	84 81       	ldd	r24, Z+4	; 0x04
    5ca8:	95 81       	ldd	r25, Z+5	; 0x05
    5caa:	13 96       	adiw	r26, 0x03	; 3
    5cac:	9c 93       	st	X, r25
    5cae:	8e 93       	st	-X, r24
    5cb0:	12 97       	sbiw	r26, 0x02	; 2
    5cb2:	ed 81       	ldd	r30, Y+5	; 0x05
    5cb4:	fe 81       	ldd	r31, Y+6	; 0x06
    5cb6:	21 81       	ldd	r18, Z+1	; 0x01
    5cb8:	32 81       	ldd	r19, Z+2	; 0x02
    5cba:	8a 85       	ldd	r24, Y+10	; 0x0a
    5cbc:	9b 85       	ldd	r25, Y+11	; 0x0b
    5cbe:	02 96       	adiw	r24, 0x02	; 2
    5cc0:	28 17       	cp	r18, r24
    5cc2:	39 07       	cpc	r19, r25
    5cc4:	41 f4       	brne	.+16     	; 0x5cd6 <xTaskResumeAll+0x126>
    5cc6:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cc8:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cca:	86 81       	ldd	r24, Z+6	; 0x06
    5ccc:	97 81       	ldd	r25, Z+7	; 0x07
    5cce:	ed 81       	ldd	r30, Y+5	; 0x05
    5cd0:	fe 81       	ldd	r31, Y+6	; 0x06
    5cd2:	92 83       	std	Z+2, r25	; 0x02
    5cd4:	81 83       	std	Z+1, r24	; 0x01
    5cd6:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cd8:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cda:	13 86       	std	Z+11, r1	; 0x0b
    5cdc:	12 86       	std	Z+10, r1	; 0x0a
    5cde:	ed 81       	ldd	r30, Y+5	; 0x05
    5ce0:	fe 81       	ldd	r31, Y+6	; 0x06
    5ce2:	80 81       	ld	r24, Z
    5ce4:	81 50       	subi	r24, 0x01	; 1
    5ce6:	ed 81       	ldd	r30, Y+5	; 0x05
    5ce8:	fe 81       	ldd	r31, Y+6	; 0x06
    5cea:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5cec:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cee:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cf0:	96 89       	ldd	r25, Z+22	; 0x16
    5cf2:	80 91 97 06 	lds	r24, 0x0697
    5cf6:	89 17       	cp	r24, r25
    5cf8:	28 f4       	brcc	.+10     	; 0x5d04 <xTaskResumeAll+0x154>
    5cfa:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cfc:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cfe:	86 89       	ldd	r24, Z+22	; 0x16
    5d00:	80 93 97 06 	sts	0x0697, r24
    5d04:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d06:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d08:	86 89       	ldd	r24, Z+22	; 0x16
    5d0a:	28 2f       	mov	r18, r24
    5d0c:	30 e0       	ldi	r19, 0x00	; 0
    5d0e:	c9 01       	movw	r24, r18
    5d10:	88 0f       	add	r24, r24
    5d12:	99 1f       	adc	r25, r25
    5d14:	88 0f       	add	r24, r24
    5d16:	99 1f       	adc	r25, r25
    5d18:	88 0f       	add	r24, r24
    5d1a:	99 1f       	adc	r25, r25
    5d1c:	82 0f       	add	r24, r18
    5d1e:	93 1f       	adc	r25, r19
    5d20:	fc 01       	movw	r30, r24
    5d22:	ed 55       	subi	r30, 0x5D	; 93
    5d24:	f9 4f       	sbci	r31, 0xF9	; 249
    5d26:	81 81       	ldd	r24, Z+1	; 0x01
    5d28:	92 81       	ldd	r25, Z+2	; 0x02
    5d2a:	9c 83       	std	Y+4, r25	; 0x04
    5d2c:	8b 83       	std	Y+3, r24	; 0x03
    5d2e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d30:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d32:	8b 81       	ldd	r24, Y+3	; 0x03
    5d34:	9c 81       	ldd	r25, Y+4	; 0x04
    5d36:	95 83       	std	Z+5, r25	; 0x05
    5d38:	84 83       	std	Z+4, r24	; 0x04
    5d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d3e:	84 81       	ldd	r24, Z+4	; 0x04
    5d40:	95 81       	ldd	r25, Z+5	; 0x05
    5d42:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d44:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d46:	97 83       	std	Z+7, r25	; 0x07
    5d48:	86 83       	std	Z+6, r24	; 0x06
    5d4a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d4c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d4e:	04 80       	ldd	r0, Z+4	; 0x04
    5d50:	f5 81       	ldd	r31, Z+5	; 0x05
    5d52:	e0 2d       	mov	r30, r0
    5d54:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d56:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d58:	02 96       	adiw	r24, 0x02	; 2
    5d5a:	93 83       	std	Z+3, r25	; 0x03
    5d5c:	82 83       	std	Z+2, r24	; 0x02
    5d5e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d60:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d62:	02 96       	adiw	r24, 0x02	; 2
    5d64:	eb 81       	ldd	r30, Y+3	; 0x03
    5d66:	fc 81       	ldd	r31, Y+4	; 0x04
    5d68:	95 83       	std	Z+5, r25	; 0x05
    5d6a:	84 83       	std	Z+4, r24	; 0x04
    5d6c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d6e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d70:	86 89       	ldd	r24, Z+22	; 0x16
    5d72:	28 2f       	mov	r18, r24
    5d74:	30 e0       	ldi	r19, 0x00	; 0
    5d76:	c9 01       	movw	r24, r18
    5d78:	88 0f       	add	r24, r24
    5d7a:	99 1f       	adc	r25, r25
    5d7c:	88 0f       	add	r24, r24
    5d7e:	99 1f       	adc	r25, r25
    5d80:	88 0f       	add	r24, r24
    5d82:	99 1f       	adc	r25, r25
    5d84:	82 0f       	add	r24, r18
    5d86:	93 1f       	adc	r25, r19
    5d88:	8d 55       	subi	r24, 0x5D	; 93
    5d8a:	99 4f       	sbci	r25, 0xF9	; 249
    5d8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d90:	93 87       	std	Z+11, r25	; 0x0b
    5d92:	82 87       	std	Z+10, r24	; 0x0a
    5d94:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d96:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d98:	86 89       	ldd	r24, Z+22	; 0x16
    5d9a:	28 2f       	mov	r18, r24
    5d9c:	30 e0       	ldi	r19, 0x00	; 0
    5d9e:	c9 01       	movw	r24, r18
    5da0:	88 0f       	add	r24, r24
    5da2:	99 1f       	adc	r25, r25
    5da4:	88 0f       	add	r24, r24
    5da6:	99 1f       	adc	r25, r25
    5da8:	88 0f       	add	r24, r24
    5daa:	99 1f       	adc	r25, r25
    5dac:	82 0f       	add	r24, r18
    5dae:	93 1f       	adc	r25, r19
    5db0:	fc 01       	movw	r30, r24
    5db2:	ed 55       	subi	r30, 0x5D	; 93
    5db4:	f9 4f       	sbci	r31, 0xF9	; 249
    5db6:	80 81       	ld	r24, Z
    5db8:	8f 5f       	subi	r24, 0xFF	; 255
    5dba:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5dbc:	ea 85       	ldd	r30, Y+10	; 0x0a
    5dbe:	fb 85       	ldd	r31, Y+11	; 0x0b
    5dc0:	96 89       	ldd	r25, Z+22	; 0x16
    5dc2:	e0 91 91 06 	lds	r30, 0x0691
    5dc6:	f0 91 92 06 	lds	r31, 0x0692
    5dca:	86 89       	ldd	r24, Z+22	; 0x16
    5dcc:	98 17       	cp	r25, r24
    5dce:	18 f0       	brcs	.+6      	; 0x5dd6 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	80 93 9b 06 	sts	0x069B, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5dd6:	80 91 dd 06 	lds	r24, 0x06DD
    5dda:	88 23       	and	r24, r24
    5ddc:	09 f0       	breq	.+2      	; 0x5de0 <xTaskResumeAll+0x230>
    5dde:	08 cf       	rjmp	.-496    	; 0x5bf0 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    5de0:	8a 85       	ldd	r24, Y+10	; 0x0a
    5de2:	9b 85       	ldd	r25, Y+11	; 0x0b
    5de4:	00 97       	sbiw	r24, 0x00	; 0
    5de6:	11 f0       	breq	.+4      	; 0x5dec <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    5de8:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    5dec:	80 91 99 06 	lds	r24, 0x0699
    5df0:	90 91 9a 06 	lds	r25, 0x069A
    5df4:	9a 83       	std	Y+2, r25	; 0x02
    5df6:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    5df8:	89 81       	ldd	r24, Y+1	; 0x01
    5dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    5dfc:	00 97       	sbiw	r24, 0x00	; 0
    5dfe:	a1 f0       	breq	.+40     	; 0x5e28 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    5e00:	0e 94 aa 2f 	call	0x5f54	; 0x5f54 <xTaskIncrementTick>
    5e04:	88 23       	and	r24, r24
    5e06:	19 f0       	breq	.+6      	; 0x5e0e <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    5e08:	81 e0       	ldi	r24, 0x01	; 1
    5e0a:	80 93 9b 06 	sts	0x069B, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    5e0e:	89 81       	ldd	r24, Y+1	; 0x01
    5e10:	9a 81       	ldd	r25, Y+2	; 0x02
    5e12:	01 97       	sbiw	r24, 0x01	; 1
    5e14:	9a 83       	std	Y+2, r25	; 0x02
    5e16:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    5e18:	89 81       	ldd	r24, Y+1	; 0x01
    5e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e1c:	00 97       	sbiw	r24, 0x00	; 0
    5e1e:	81 f7       	brne	.-32     	; 0x5e00 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    5e20:	10 92 9a 06 	sts	0x069A, r1
    5e24:	10 92 99 06 	sts	0x0699, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    5e28:	80 91 9b 06 	lds	r24, 0x069B
    5e2c:	88 23       	and	r24, r24
    5e2e:	21 f0       	breq	.+8      	; 0x5e38 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
    5e30:	81 e0       	ldi	r24, 0x01	; 1
    5e32:	89 87       	std	Y+9, r24	; 0x09
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    5e34:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    5e38:	0f 90       	pop	r0
    5e3a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    5e3c:	89 85       	ldd	r24, Y+9	; 0x09
}
    5e3e:	2b 96       	adiw	r28, 0x0b	; 11
    5e40:	0f b6       	in	r0, 0x3f	; 63
    5e42:	f8 94       	cli
    5e44:	de bf       	out	0x3e, r29	; 62
    5e46:	0f be       	out	0x3f, r0	; 63
    5e48:	cd bf       	out	0x3d, r28	; 61
    5e4a:	cf 91       	pop	r28
    5e4c:	df 91       	pop	r29
    5e4e:	08 95       	ret

00005e50 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    5e50:	df 93       	push	r29
    5e52:	cf 93       	push	r28
    5e54:	00 d0       	rcall	.+0      	; 0x5e56 <xTaskGetTickCount+0x6>
    5e56:	cd b7       	in	r28, 0x3d	; 61
    5e58:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    5e5a:	0f b6       	in	r0, 0x3f	; 63
    5e5c:	f8 94       	cli
    5e5e:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    5e60:	80 91 95 06 	lds	r24, 0x0695
    5e64:	90 91 96 06 	lds	r25, 0x0696
    5e68:	9a 83       	std	Y+2, r25	; 0x02
    5e6a:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    5e6c:	0f 90       	pop	r0
    5e6e:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    5e70:	89 81       	ldd	r24, Y+1	; 0x01
    5e72:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5e74:	0f 90       	pop	r0
    5e76:	0f 90       	pop	r0
    5e78:	cf 91       	pop	r28
    5e7a:	df 91       	pop	r29
    5e7c:	08 95       	ret

00005e7e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    5e7e:	df 93       	push	r29
    5e80:	cf 93       	push	r28
    5e82:	00 d0       	rcall	.+0      	; 0x5e84 <xTaskGetTickCountFromISR+0x6>
    5e84:	0f 92       	push	r0
    5e86:	cd b7       	in	r28, 0x3d	; 61
    5e88:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    5e8a:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    5e8c:	80 91 95 06 	lds	r24, 0x0695
    5e90:	90 91 96 06 	lds	r25, 0x0696
    5e94:	9b 83       	std	Y+3, r25	; 0x03
    5e96:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    5e98:	8a 81       	ldd	r24, Y+2	; 0x02
    5e9a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5e9c:	0f 90       	pop	r0
    5e9e:	0f 90       	pop	r0
    5ea0:	0f 90       	pop	r0
    5ea2:	cf 91       	pop	r28
    5ea4:	df 91       	pop	r29
    5ea6:	08 95       	ret

00005ea8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    5ea8:	df 93       	push	r29
    5eaa:	cf 93       	push	r28
    5eac:	cd b7       	in	r28, 0x3d	; 61
    5eae:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    5eb0:	80 91 94 06 	lds	r24, 0x0694
}
    5eb4:	cf 91       	pop	r28
    5eb6:	df 91       	pop	r29
    5eb8:	08 95       	ret

00005eba <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5eba:	df 93       	push	r29
    5ebc:	cf 93       	push	r28
    5ebe:	00 d0       	rcall	.+0      	; 0x5ec0 <pcTaskGetName+0x6>
    5ec0:	00 d0       	rcall	.+0      	; 0x5ec2 <pcTaskGetName+0x8>
    5ec2:	00 d0       	rcall	.+0      	; 0x5ec4 <pcTaskGetName+0xa>
    5ec4:	cd b7       	in	r28, 0x3d	; 61
    5ec6:	de b7       	in	r29, 0x3e	; 62
    5ec8:	9c 83       	std	Y+4, r25	; 0x04
    5eca:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    5ece:	9c 81       	ldd	r25, Y+4	; 0x04
    5ed0:	00 97       	sbiw	r24, 0x00	; 0
    5ed2:	39 f4       	brne	.+14     	; 0x5ee2 <pcTaskGetName+0x28>
    5ed4:	80 91 91 06 	lds	r24, 0x0691
    5ed8:	90 91 92 06 	lds	r25, 0x0692
    5edc:	9e 83       	std	Y+6, r25	; 0x06
    5ede:	8d 83       	std	Y+5, r24	; 0x05
    5ee0:	04 c0       	rjmp	.+8      	; 0x5eea <pcTaskGetName+0x30>
    5ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    5ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    5ee6:	9e 83       	std	Y+6, r25	; 0x06
    5ee8:	8d 83       	std	Y+5, r24	; 0x05
    5eea:	8d 81       	ldd	r24, Y+5	; 0x05
    5eec:	9e 81       	ldd	r25, Y+6	; 0x06
    5eee:	9a 83       	std	Y+2, r25	; 0x02
    5ef0:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    5ef2:	89 81       	ldd	r24, Y+1	; 0x01
    5ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    5ef6:	49 96       	adiw	r24, 0x19	; 25
}
    5ef8:	26 96       	adiw	r28, 0x06	; 6
    5efa:	0f b6       	in	r0, 0x3f	; 63
    5efc:	f8 94       	cli
    5efe:	de bf       	out	0x3e, r29	; 62
    5f00:	0f be       	out	0x3f, r0	; 63
    5f02:	cd bf       	out	0x3d, r28	; 61
    5f04:	cf 91       	pop	r28
    5f06:	df 91       	pop	r29
    5f08:	08 95       	ret

00005f0a <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    5f0a:	df 93       	push	r29
    5f0c:	cf 93       	push	r28
    5f0e:	00 d0       	rcall	.+0      	; 0x5f10 <xTaskCatchUpTicks+0x6>
    5f10:	0f 92       	push	r0
    5f12:	cd b7       	in	r28, 0x3d	; 61
    5f14:	de b7       	in	r29, 0x3e	; 62
    5f16:	9b 83       	std	Y+3, r25	; 0x03
    5f18:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    5f1a:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    5f1e:	0f b6       	in	r0, 0x3f	; 63
    5f20:	f8 94       	cli
    5f22:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    5f24:	20 91 99 06 	lds	r18, 0x0699
    5f28:	30 91 9a 06 	lds	r19, 0x069A
    5f2c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f2e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f30:	82 0f       	add	r24, r18
    5f32:	93 1f       	adc	r25, r19
    5f34:	90 93 9a 06 	sts	0x069A, r25
    5f38:	80 93 99 06 	sts	0x0699, r24
    }
    taskEXIT_CRITICAL();
    5f3c:	0f 90       	pop	r0
    5f3e:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    5f40:	0e 94 d8 2d 	call	0x5bb0	; 0x5bb0 <xTaskResumeAll>
    5f44:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    5f46:	89 81       	ldd	r24, Y+1	; 0x01
}
    5f48:	0f 90       	pop	r0
    5f4a:	0f 90       	pop	r0
    5f4c:	0f 90       	pop	r0
    5f4e:	cf 91       	pop	r28
    5f50:	df 91       	pop	r29
    5f52:	08 95       	ret

00005f54 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5f54:	df 93       	push	r29
    5f56:	cf 93       	push	r28
    5f58:	cd b7       	in	r28, 0x3d	; 61
    5f5a:	de b7       	in	r29, 0x3e	; 62
    5f5c:	2f 97       	sbiw	r28, 0x0f	; 15
    5f5e:	0f b6       	in	r0, 0x3f	; 63
    5f60:	f8 94       	cli
    5f62:	de bf       	out	0x3e, r29	; 62
    5f64:	0f be       	out	0x3f, r0	; 63
    5f66:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    5f68:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5f6a:	80 91 a2 06 	lds	r24, 0x06A2
    5f6e:	88 23       	and	r24, r24
    5f70:	09 f0       	breq	.+2      	; 0x5f74 <xTaskIncrementTick+0x20>
    5f72:	74 c1       	rjmp	.+744    	; 0x625c <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5f74:	80 91 95 06 	lds	r24, 0x0695
    5f78:	90 91 96 06 	lds	r25, 0x0696
    5f7c:	01 96       	adiw	r24, 0x01	; 1
    5f7e:	9a 87       	std	Y+10, r25	; 0x0a
    5f80:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    5f82:	89 85       	ldd	r24, Y+9	; 0x09
    5f84:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f86:	90 93 96 06 	sts	0x0696, r25
    5f8a:	80 93 95 06 	sts	0x0695, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    5f8e:	89 85       	ldd	r24, Y+9	; 0x09
    5f90:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f92:	00 97       	sbiw	r24, 0x00	; 0
    5f94:	d9 f4       	brne	.+54     	; 0x5fcc <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    5f96:	80 91 d9 06 	lds	r24, 0x06D9
    5f9a:	90 91 da 06 	lds	r25, 0x06DA
    5f9e:	98 87       	std	Y+8, r25	; 0x08
    5fa0:	8f 83       	std	Y+7, r24	; 0x07
    5fa2:	80 91 db 06 	lds	r24, 0x06DB
    5fa6:	90 91 dc 06 	lds	r25, 0x06DC
    5faa:	90 93 da 06 	sts	0x06DA, r25
    5fae:	80 93 d9 06 	sts	0x06D9, r24
    5fb2:	8f 81       	ldd	r24, Y+7	; 0x07
    5fb4:	98 85       	ldd	r25, Y+8	; 0x08
    5fb6:	90 93 dc 06 	sts	0x06DC, r25
    5fba:	80 93 db 06 	sts	0x06DB, r24
    5fbe:	80 91 9c 06 	lds	r24, 0x069C
    5fc2:	8f 5f       	subi	r24, 0xFF	; 255
    5fc4:	80 93 9c 06 	sts	0x069C, r24
    5fc8:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    5fcc:	20 91 9e 06 	lds	r18, 0x069E
    5fd0:	30 91 9f 06 	lds	r19, 0x069F
    5fd4:	89 85       	ldd	r24, Y+9	; 0x09
    5fd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fd8:	82 17       	cp	r24, r18
    5fda:	93 07       	cpc	r25, r19
    5fdc:	08 f4       	brcc	.+2      	; 0x5fe0 <xTaskIncrementTick+0x8c>
    5fde:	1f c1       	rjmp	.+574    	; 0x621e <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5fe0:	e0 91 d9 06 	lds	r30, 0x06D9
    5fe4:	f0 91 da 06 	lds	r31, 0x06DA
    5fe8:	80 81       	ld	r24, Z
    5fea:	88 23       	and	r24, r24
    5fec:	39 f4       	brne	.+14     	; 0x5ffc <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5fee:	8f ef       	ldi	r24, 0xFF	; 255
    5ff0:	9f ef       	ldi	r25, 0xFF	; 255
    5ff2:	90 93 9f 06 	sts	0x069F, r25
    5ff6:	80 93 9e 06 	sts	0x069E, r24
    5ffa:	11 c1       	rjmp	.+546    	; 0x621e <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5ffc:	e0 91 d9 06 	lds	r30, 0x06D9
    6000:	f0 91 da 06 	lds	r31, 0x06DA
    6004:	05 80       	ldd	r0, Z+5	; 0x05
    6006:	f6 81       	ldd	r31, Z+6	; 0x06
    6008:	e0 2d       	mov	r30, r0
    600a:	86 81       	ldd	r24, Z+6	; 0x06
    600c:	97 81       	ldd	r25, Z+7	; 0x07
    600e:	9f 87       	std	Y+15, r25	; 0x0f
    6010:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    6012:	ee 85       	ldd	r30, Y+14	; 0x0e
    6014:	ff 85       	ldd	r31, Y+15	; 0x0f
    6016:	82 81       	ldd	r24, Z+2	; 0x02
    6018:	93 81       	ldd	r25, Z+3	; 0x03
    601a:	9d 87       	std	Y+13, r25	; 0x0d
    601c:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    601e:	29 85       	ldd	r18, Y+9	; 0x09
    6020:	3a 85       	ldd	r19, Y+10	; 0x0a
    6022:	8c 85       	ldd	r24, Y+12	; 0x0c
    6024:	9d 85       	ldd	r25, Y+13	; 0x0d
    6026:	28 17       	cp	r18, r24
    6028:	39 07       	cpc	r19, r25
    602a:	38 f4       	brcc	.+14     	; 0x603a <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    602c:	8c 85       	ldd	r24, Y+12	; 0x0c
    602e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6030:	90 93 9f 06 	sts	0x069F, r25
    6034:	80 93 9e 06 	sts	0x069E, r24
    6038:	f2 c0       	rjmp	.+484    	; 0x621e <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    603a:	ee 85       	ldd	r30, Y+14	; 0x0e
    603c:	ff 85       	ldd	r31, Y+15	; 0x0f
    603e:	82 85       	ldd	r24, Z+10	; 0x0a
    6040:	93 85       	ldd	r25, Z+11	; 0x0b
    6042:	9e 83       	std	Y+6, r25	; 0x06
    6044:	8d 83       	std	Y+5, r24	; 0x05
    6046:	ee 85       	ldd	r30, Y+14	; 0x0e
    6048:	ff 85       	ldd	r31, Y+15	; 0x0f
    604a:	a4 81       	ldd	r26, Z+4	; 0x04
    604c:	b5 81       	ldd	r27, Z+5	; 0x05
    604e:	ee 85       	ldd	r30, Y+14	; 0x0e
    6050:	ff 85       	ldd	r31, Y+15	; 0x0f
    6052:	86 81       	ldd	r24, Z+6	; 0x06
    6054:	97 81       	ldd	r25, Z+7	; 0x07
    6056:	15 96       	adiw	r26, 0x05	; 5
    6058:	9c 93       	st	X, r25
    605a:	8e 93       	st	-X, r24
    605c:	14 97       	sbiw	r26, 0x04	; 4
    605e:	ee 85       	ldd	r30, Y+14	; 0x0e
    6060:	ff 85       	ldd	r31, Y+15	; 0x0f
    6062:	a6 81       	ldd	r26, Z+6	; 0x06
    6064:	b7 81       	ldd	r27, Z+7	; 0x07
    6066:	ee 85       	ldd	r30, Y+14	; 0x0e
    6068:	ff 85       	ldd	r31, Y+15	; 0x0f
    606a:	84 81       	ldd	r24, Z+4	; 0x04
    606c:	95 81       	ldd	r25, Z+5	; 0x05
    606e:	13 96       	adiw	r26, 0x03	; 3
    6070:	9c 93       	st	X, r25
    6072:	8e 93       	st	-X, r24
    6074:	12 97       	sbiw	r26, 0x02	; 2
    6076:	ed 81       	ldd	r30, Y+5	; 0x05
    6078:	fe 81       	ldd	r31, Y+6	; 0x06
    607a:	21 81       	ldd	r18, Z+1	; 0x01
    607c:	32 81       	ldd	r19, Z+2	; 0x02
    607e:	8e 85       	ldd	r24, Y+14	; 0x0e
    6080:	9f 85       	ldd	r25, Y+15	; 0x0f
    6082:	02 96       	adiw	r24, 0x02	; 2
    6084:	28 17       	cp	r18, r24
    6086:	39 07       	cpc	r19, r25
    6088:	41 f4       	brne	.+16     	; 0x609a <xTaskIncrementTick+0x146>
    608a:	ee 85       	ldd	r30, Y+14	; 0x0e
    608c:	ff 85       	ldd	r31, Y+15	; 0x0f
    608e:	86 81       	ldd	r24, Z+6	; 0x06
    6090:	97 81       	ldd	r25, Z+7	; 0x07
    6092:	ed 81       	ldd	r30, Y+5	; 0x05
    6094:	fe 81       	ldd	r31, Y+6	; 0x06
    6096:	92 83       	std	Z+2, r25	; 0x02
    6098:	81 83       	std	Z+1, r24	; 0x01
    609a:	ee 85       	ldd	r30, Y+14	; 0x0e
    609c:	ff 85       	ldd	r31, Y+15	; 0x0f
    609e:	13 86       	std	Z+11, r1	; 0x0b
    60a0:	12 86       	std	Z+10, r1	; 0x0a
    60a2:	ed 81       	ldd	r30, Y+5	; 0x05
    60a4:	fe 81       	ldd	r31, Y+6	; 0x06
    60a6:	80 81       	ld	r24, Z
    60a8:	81 50       	subi	r24, 0x01	; 1
    60aa:	ed 81       	ldd	r30, Y+5	; 0x05
    60ac:	fe 81       	ldd	r31, Y+6	; 0x06
    60ae:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    60b0:	ee 85       	ldd	r30, Y+14	; 0x0e
    60b2:	ff 85       	ldd	r31, Y+15	; 0x0f
    60b4:	84 89       	ldd	r24, Z+20	; 0x14
    60b6:	95 89       	ldd	r25, Z+21	; 0x15
    60b8:	00 97       	sbiw	r24, 0x00	; 0
    60ba:	d9 f1       	breq	.+118    	; 0x6132 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    60bc:	ee 85       	ldd	r30, Y+14	; 0x0e
    60be:	ff 85       	ldd	r31, Y+15	; 0x0f
    60c0:	84 89       	ldd	r24, Z+20	; 0x14
    60c2:	95 89       	ldd	r25, Z+21	; 0x15
    60c4:	9c 83       	std	Y+4, r25	; 0x04
    60c6:	8b 83       	std	Y+3, r24	; 0x03
    60c8:	ee 85       	ldd	r30, Y+14	; 0x0e
    60ca:	ff 85       	ldd	r31, Y+15	; 0x0f
    60cc:	a6 85       	ldd	r26, Z+14	; 0x0e
    60ce:	b7 85       	ldd	r27, Z+15	; 0x0f
    60d0:	ee 85       	ldd	r30, Y+14	; 0x0e
    60d2:	ff 85       	ldd	r31, Y+15	; 0x0f
    60d4:	80 89       	ldd	r24, Z+16	; 0x10
    60d6:	91 89       	ldd	r25, Z+17	; 0x11
    60d8:	15 96       	adiw	r26, 0x05	; 5
    60da:	9c 93       	st	X, r25
    60dc:	8e 93       	st	-X, r24
    60de:	14 97       	sbiw	r26, 0x04	; 4
    60e0:	ee 85       	ldd	r30, Y+14	; 0x0e
    60e2:	ff 85       	ldd	r31, Y+15	; 0x0f
    60e4:	a0 89       	ldd	r26, Z+16	; 0x10
    60e6:	b1 89       	ldd	r27, Z+17	; 0x11
    60e8:	ee 85       	ldd	r30, Y+14	; 0x0e
    60ea:	ff 85       	ldd	r31, Y+15	; 0x0f
    60ec:	86 85       	ldd	r24, Z+14	; 0x0e
    60ee:	97 85       	ldd	r25, Z+15	; 0x0f
    60f0:	13 96       	adiw	r26, 0x03	; 3
    60f2:	9c 93       	st	X, r25
    60f4:	8e 93       	st	-X, r24
    60f6:	12 97       	sbiw	r26, 0x02	; 2
    60f8:	eb 81       	ldd	r30, Y+3	; 0x03
    60fa:	fc 81       	ldd	r31, Y+4	; 0x04
    60fc:	21 81       	ldd	r18, Z+1	; 0x01
    60fe:	32 81       	ldd	r19, Z+2	; 0x02
    6100:	8e 85       	ldd	r24, Y+14	; 0x0e
    6102:	9f 85       	ldd	r25, Y+15	; 0x0f
    6104:	0c 96       	adiw	r24, 0x0c	; 12
    6106:	28 17       	cp	r18, r24
    6108:	39 07       	cpc	r19, r25
    610a:	41 f4       	brne	.+16     	; 0x611c <xTaskIncrementTick+0x1c8>
    610c:	ee 85       	ldd	r30, Y+14	; 0x0e
    610e:	ff 85       	ldd	r31, Y+15	; 0x0f
    6110:	80 89       	ldd	r24, Z+16	; 0x10
    6112:	91 89       	ldd	r25, Z+17	; 0x11
    6114:	eb 81       	ldd	r30, Y+3	; 0x03
    6116:	fc 81       	ldd	r31, Y+4	; 0x04
    6118:	92 83       	std	Z+2, r25	; 0x02
    611a:	81 83       	std	Z+1, r24	; 0x01
    611c:	ee 85       	ldd	r30, Y+14	; 0x0e
    611e:	ff 85       	ldd	r31, Y+15	; 0x0f
    6120:	15 8a       	std	Z+21, r1	; 0x15
    6122:	14 8a       	std	Z+20, r1	; 0x14
    6124:	eb 81       	ldd	r30, Y+3	; 0x03
    6126:	fc 81       	ldd	r31, Y+4	; 0x04
    6128:	80 81       	ld	r24, Z
    612a:	81 50       	subi	r24, 0x01	; 1
    612c:	eb 81       	ldd	r30, Y+3	; 0x03
    612e:	fc 81       	ldd	r31, Y+4	; 0x04
    6130:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    6132:	ee 85       	ldd	r30, Y+14	; 0x0e
    6134:	ff 85       	ldd	r31, Y+15	; 0x0f
    6136:	96 89       	ldd	r25, Z+22	; 0x16
    6138:	80 91 97 06 	lds	r24, 0x0697
    613c:	89 17       	cp	r24, r25
    613e:	28 f4       	brcc	.+10     	; 0x614a <xTaskIncrementTick+0x1f6>
    6140:	ee 85       	ldd	r30, Y+14	; 0x0e
    6142:	ff 85       	ldd	r31, Y+15	; 0x0f
    6144:	86 89       	ldd	r24, Z+22	; 0x16
    6146:	80 93 97 06 	sts	0x0697, r24
    614a:	ee 85       	ldd	r30, Y+14	; 0x0e
    614c:	ff 85       	ldd	r31, Y+15	; 0x0f
    614e:	86 89       	ldd	r24, Z+22	; 0x16
    6150:	28 2f       	mov	r18, r24
    6152:	30 e0       	ldi	r19, 0x00	; 0
    6154:	c9 01       	movw	r24, r18
    6156:	88 0f       	add	r24, r24
    6158:	99 1f       	adc	r25, r25
    615a:	88 0f       	add	r24, r24
    615c:	99 1f       	adc	r25, r25
    615e:	88 0f       	add	r24, r24
    6160:	99 1f       	adc	r25, r25
    6162:	82 0f       	add	r24, r18
    6164:	93 1f       	adc	r25, r19
    6166:	fc 01       	movw	r30, r24
    6168:	ed 55       	subi	r30, 0x5D	; 93
    616a:	f9 4f       	sbci	r31, 0xF9	; 249
    616c:	81 81       	ldd	r24, Z+1	; 0x01
    616e:	92 81       	ldd	r25, Z+2	; 0x02
    6170:	9a 83       	std	Y+2, r25	; 0x02
    6172:	89 83       	std	Y+1, r24	; 0x01
    6174:	ee 85       	ldd	r30, Y+14	; 0x0e
    6176:	ff 85       	ldd	r31, Y+15	; 0x0f
    6178:	89 81       	ldd	r24, Y+1	; 0x01
    617a:	9a 81       	ldd	r25, Y+2	; 0x02
    617c:	95 83       	std	Z+5, r25	; 0x05
    617e:	84 83       	std	Z+4, r24	; 0x04
    6180:	e9 81       	ldd	r30, Y+1	; 0x01
    6182:	fa 81       	ldd	r31, Y+2	; 0x02
    6184:	84 81       	ldd	r24, Z+4	; 0x04
    6186:	95 81       	ldd	r25, Z+5	; 0x05
    6188:	ee 85       	ldd	r30, Y+14	; 0x0e
    618a:	ff 85       	ldd	r31, Y+15	; 0x0f
    618c:	97 83       	std	Z+7, r25	; 0x07
    618e:	86 83       	std	Z+6, r24	; 0x06
    6190:	e9 81       	ldd	r30, Y+1	; 0x01
    6192:	fa 81       	ldd	r31, Y+2	; 0x02
    6194:	04 80       	ldd	r0, Z+4	; 0x04
    6196:	f5 81       	ldd	r31, Z+5	; 0x05
    6198:	e0 2d       	mov	r30, r0
    619a:	8e 85       	ldd	r24, Y+14	; 0x0e
    619c:	9f 85       	ldd	r25, Y+15	; 0x0f
    619e:	02 96       	adiw	r24, 0x02	; 2
    61a0:	93 83       	std	Z+3, r25	; 0x03
    61a2:	82 83       	std	Z+2, r24	; 0x02
    61a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    61a6:	9f 85       	ldd	r25, Y+15	; 0x0f
    61a8:	02 96       	adiw	r24, 0x02	; 2
    61aa:	e9 81       	ldd	r30, Y+1	; 0x01
    61ac:	fa 81       	ldd	r31, Y+2	; 0x02
    61ae:	95 83       	std	Z+5, r25	; 0x05
    61b0:	84 83       	std	Z+4, r24	; 0x04
    61b2:	ee 85       	ldd	r30, Y+14	; 0x0e
    61b4:	ff 85       	ldd	r31, Y+15	; 0x0f
    61b6:	86 89       	ldd	r24, Z+22	; 0x16
    61b8:	28 2f       	mov	r18, r24
    61ba:	30 e0       	ldi	r19, 0x00	; 0
    61bc:	c9 01       	movw	r24, r18
    61be:	88 0f       	add	r24, r24
    61c0:	99 1f       	adc	r25, r25
    61c2:	88 0f       	add	r24, r24
    61c4:	99 1f       	adc	r25, r25
    61c6:	88 0f       	add	r24, r24
    61c8:	99 1f       	adc	r25, r25
    61ca:	82 0f       	add	r24, r18
    61cc:	93 1f       	adc	r25, r19
    61ce:	8d 55       	subi	r24, 0x5D	; 93
    61d0:	99 4f       	sbci	r25, 0xF9	; 249
    61d2:	ee 85       	ldd	r30, Y+14	; 0x0e
    61d4:	ff 85       	ldd	r31, Y+15	; 0x0f
    61d6:	93 87       	std	Z+11, r25	; 0x0b
    61d8:	82 87       	std	Z+10, r24	; 0x0a
    61da:	ee 85       	ldd	r30, Y+14	; 0x0e
    61dc:	ff 85       	ldd	r31, Y+15	; 0x0f
    61de:	86 89       	ldd	r24, Z+22	; 0x16
    61e0:	28 2f       	mov	r18, r24
    61e2:	30 e0       	ldi	r19, 0x00	; 0
    61e4:	c9 01       	movw	r24, r18
    61e6:	88 0f       	add	r24, r24
    61e8:	99 1f       	adc	r25, r25
    61ea:	88 0f       	add	r24, r24
    61ec:	99 1f       	adc	r25, r25
    61ee:	88 0f       	add	r24, r24
    61f0:	99 1f       	adc	r25, r25
    61f2:	82 0f       	add	r24, r18
    61f4:	93 1f       	adc	r25, r19
    61f6:	fc 01       	movw	r30, r24
    61f8:	ed 55       	subi	r30, 0x5D	; 93
    61fa:	f9 4f       	sbci	r31, 0xF9	; 249
    61fc:	80 81       	ld	r24, Z
    61fe:	8f 5f       	subi	r24, 0xFF	; 255
    6200:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6202:	ee 85       	ldd	r30, Y+14	; 0x0e
    6204:	ff 85       	ldd	r31, Y+15	; 0x0f
    6206:	96 89       	ldd	r25, Z+22	; 0x16
    6208:	e0 91 91 06 	lds	r30, 0x0691
    620c:	f0 91 92 06 	lds	r31, 0x0692
    6210:	86 89       	ldd	r24, Z+22	; 0x16
    6212:	89 17       	cp	r24, r25
    6214:	08 f0       	brcs	.+2      	; 0x6218 <xTaskIncrementTick+0x2c4>
    6216:	e4 ce       	rjmp	.-568    	; 0x5fe0 <xTaskIncrementTick+0x8c>
                        {
                            xSwitchRequired = pdTRUE;
    6218:	81 e0       	ldi	r24, 0x01	; 1
    621a:	8b 87       	std	Y+11, r24	; 0x0b
    621c:	e1 ce       	rjmp	.-574    	; 0x5fe0 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    621e:	e0 91 91 06 	lds	r30, 0x0691
    6222:	f0 91 92 06 	lds	r31, 0x0692
    6226:	86 89       	ldd	r24, Z+22	; 0x16
    6228:	28 2f       	mov	r18, r24
    622a:	30 e0       	ldi	r19, 0x00	; 0
    622c:	c9 01       	movw	r24, r18
    622e:	88 0f       	add	r24, r24
    6230:	99 1f       	adc	r25, r25
    6232:	88 0f       	add	r24, r24
    6234:	99 1f       	adc	r25, r25
    6236:	88 0f       	add	r24, r24
    6238:	99 1f       	adc	r25, r25
    623a:	82 0f       	add	r24, r18
    623c:	93 1f       	adc	r25, r19
    623e:	fc 01       	movw	r30, r24
    6240:	ed 55       	subi	r30, 0x5D	; 93
    6242:	f9 4f       	sbci	r31, 0xF9	; 249
    6244:	80 81       	ld	r24, Z
    6246:	82 30       	cpi	r24, 0x02	; 2
    6248:	10 f0       	brcs	.+4      	; 0x624e <xTaskIncrementTick+0x2fa>
            {
                xSwitchRequired = pdTRUE;
    624a:	81 e0       	ldi	r24, 0x01	; 1
    624c:	8b 87       	std	Y+11, r24	; 0x0b
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    624e:	80 91 9b 06 	lds	r24, 0x069B
    6252:	88 23       	and	r24, r24
    6254:	61 f0       	breq	.+24     	; 0x626e <xTaskIncrementTick+0x31a>
            {
                xSwitchRequired = pdTRUE;
    6256:	81 e0       	ldi	r24, 0x01	; 1
    6258:	8b 87       	std	Y+11, r24	; 0x0b
    625a:	09 c0       	rjmp	.+18     	; 0x626e <xTaskIncrementTick+0x31a>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    625c:	80 91 99 06 	lds	r24, 0x0699
    6260:	90 91 9a 06 	lds	r25, 0x069A
    6264:	01 96       	adiw	r24, 0x01	; 1
    6266:	90 93 9a 06 	sts	0x069A, r25
    626a:	80 93 99 06 	sts	0x0699, r24
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
    626e:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    6270:	2f 96       	adiw	r28, 0x0f	; 15
    6272:	0f b6       	in	r0, 0x3f	; 63
    6274:	f8 94       	cli
    6276:	de bf       	out	0x3e, r29	; 62
    6278:	0f be       	out	0x3f, r0	; 63
    627a:	cd bf       	out	0x3d, r28	; 61
    627c:	cf 91       	pop	r28
    627e:	df 91       	pop	r29
    6280:	08 95       	ret

00006282 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6282:	df 93       	push	r29
    6284:	cf 93       	push	r28
    6286:	00 d0       	rcall	.+0      	; 0x6288 <vTaskSwitchContext+0x6>
    6288:	0f 92       	push	r0
    628a:	cd b7       	in	r28, 0x3d	; 61
    628c:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    628e:	80 91 a2 06 	lds	r24, 0x06A2
    6292:	88 23       	and	r24, r24
    6294:	21 f0       	breq	.+8      	; 0x629e <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    6296:	81 e0       	ldi	r24, 0x01	; 1
    6298:	80 93 9b 06 	sts	0x069B, r24
    629c:	59 c0       	rjmp	.+178    	; 0x6350 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    629e:	10 92 9b 06 	sts	0x069B, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    62a2:	80 91 97 06 	lds	r24, 0x0697
    62a6:	8b 83       	std	Y+3, r24	; 0x03
    62a8:	03 c0       	rjmp	.+6      	; 0x62b0 <vTaskSwitchContext+0x2e>
    62aa:	8b 81       	ldd	r24, Y+3	; 0x03
    62ac:	81 50       	subi	r24, 0x01	; 1
    62ae:	8b 83       	std	Y+3, r24	; 0x03
    62b0:	8b 81       	ldd	r24, Y+3	; 0x03
    62b2:	28 2f       	mov	r18, r24
    62b4:	30 e0       	ldi	r19, 0x00	; 0
    62b6:	c9 01       	movw	r24, r18
    62b8:	88 0f       	add	r24, r24
    62ba:	99 1f       	adc	r25, r25
    62bc:	88 0f       	add	r24, r24
    62be:	99 1f       	adc	r25, r25
    62c0:	88 0f       	add	r24, r24
    62c2:	99 1f       	adc	r25, r25
    62c4:	82 0f       	add	r24, r18
    62c6:	93 1f       	adc	r25, r19
    62c8:	fc 01       	movw	r30, r24
    62ca:	ed 55       	subi	r30, 0x5D	; 93
    62cc:	f9 4f       	sbci	r31, 0xF9	; 249
    62ce:	80 81       	ld	r24, Z
    62d0:	88 23       	and	r24, r24
    62d2:	59 f3       	breq	.-42     	; 0x62aa <vTaskSwitchContext+0x28>
    62d4:	8b 81       	ldd	r24, Y+3	; 0x03
    62d6:	28 2f       	mov	r18, r24
    62d8:	30 e0       	ldi	r19, 0x00	; 0
    62da:	c9 01       	movw	r24, r18
    62dc:	88 0f       	add	r24, r24
    62de:	99 1f       	adc	r25, r25
    62e0:	88 0f       	add	r24, r24
    62e2:	99 1f       	adc	r25, r25
    62e4:	88 0f       	add	r24, r24
    62e6:	99 1f       	adc	r25, r25
    62e8:	82 0f       	add	r24, r18
    62ea:	93 1f       	adc	r25, r19
    62ec:	8d 55       	subi	r24, 0x5D	; 93
    62ee:	99 4f       	sbci	r25, 0xF9	; 249
    62f0:	9a 83       	std	Y+2, r25	; 0x02
    62f2:	89 83       	std	Y+1, r24	; 0x01
    62f4:	e9 81       	ldd	r30, Y+1	; 0x01
    62f6:	fa 81       	ldd	r31, Y+2	; 0x02
    62f8:	01 80       	ldd	r0, Z+1	; 0x01
    62fa:	f2 81       	ldd	r31, Z+2	; 0x02
    62fc:	e0 2d       	mov	r30, r0
    62fe:	82 81       	ldd	r24, Z+2	; 0x02
    6300:	93 81       	ldd	r25, Z+3	; 0x03
    6302:	e9 81       	ldd	r30, Y+1	; 0x01
    6304:	fa 81       	ldd	r31, Y+2	; 0x02
    6306:	92 83       	std	Z+2, r25	; 0x02
    6308:	81 83       	std	Z+1, r24	; 0x01
    630a:	e9 81       	ldd	r30, Y+1	; 0x01
    630c:	fa 81       	ldd	r31, Y+2	; 0x02
    630e:	21 81       	ldd	r18, Z+1	; 0x01
    6310:	32 81       	ldd	r19, Z+2	; 0x02
    6312:	89 81       	ldd	r24, Y+1	; 0x01
    6314:	9a 81       	ldd	r25, Y+2	; 0x02
    6316:	03 96       	adiw	r24, 0x03	; 3
    6318:	28 17       	cp	r18, r24
    631a:	39 07       	cpc	r19, r25
    631c:	59 f4       	brne	.+22     	; 0x6334 <vTaskSwitchContext+0xb2>
    631e:	e9 81       	ldd	r30, Y+1	; 0x01
    6320:	fa 81       	ldd	r31, Y+2	; 0x02
    6322:	01 80       	ldd	r0, Z+1	; 0x01
    6324:	f2 81       	ldd	r31, Z+2	; 0x02
    6326:	e0 2d       	mov	r30, r0
    6328:	82 81       	ldd	r24, Z+2	; 0x02
    632a:	93 81       	ldd	r25, Z+3	; 0x03
    632c:	e9 81       	ldd	r30, Y+1	; 0x01
    632e:	fa 81       	ldd	r31, Y+2	; 0x02
    6330:	92 83       	std	Z+2, r25	; 0x02
    6332:	81 83       	std	Z+1, r24	; 0x01
    6334:	e9 81       	ldd	r30, Y+1	; 0x01
    6336:	fa 81       	ldd	r31, Y+2	; 0x02
    6338:	01 80       	ldd	r0, Z+1	; 0x01
    633a:	f2 81       	ldd	r31, Z+2	; 0x02
    633c:	e0 2d       	mov	r30, r0
    633e:	86 81       	ldd	r24, Z+6	; 0x06
    6340:	97 81       	ldd	r25, Z+7	; 0x07
    6342:	90 93 92 06 	sts	0x0692, r25
    6346:	80 93 91 06 	sts	0x0691, r24
    634a:	8b 81       	ldd	r24, Y+3	; 0x03
    634c:	80 93 97 06 	sts	0x0697, r24
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
    6350:	0f 90       	pop	r0
    6352:	0f 90       	pop	r0
    6354:	0f 90       	pop	r0
    6356:	cf 91       	pop	r28
    6358:	df 91       	pop	r29
    635a:	08 95       	ret

0000635c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    635c:	df 93       	push	r29
    635e:	cf 93       	push	r28
    6360:	00 d0       	rcall	.+0      	; 0x6362 <vTaskPlaceOnEventList+0x6>
    6362:	00 d0       	rcall	.+0      	; 0x6364 <vTaskPlaceOnEventList+0x8>
    6364:	cd b7       	in	r28, 0x3d	; 61
    6366:	de b7       	in	r29, 0x3e	; 62
    6368:	9a 83       	std	Y+2, r25	; 0x02
    636a:	89 83       	std	Y+1, r24	; 0x01
    636c:	7c 83       	std	Y+4, r23	; 0x04
    636e:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6370:	80 91 91 06 	lds	r24, 0x0691
    6374:	90 91 92 06 	lds	r25, 0x0692
    6378:	9c 01       	movw	r18, r24
    637a:	24 5f       	subi	r18, 0xF4	; 244
    637c:	3f 4f       	sbci	r19, 0xFF	; 255
    637e:	89 81       	ldd	r24, Y+1	; 0x01
    6380:	9a 81       	ldd	r25, Y+2	; 0x02
    6382:	b9 01       	movw	r22, r18
    6384:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6388:	8b 81       	ldd	r24, Y+3	; 0x03
    638a:	9c 81       	ldd	r25, Y+4	; 0x04
    638c:	61 e0       	ldi	r22, 0x01	; 1
    638e:	0e 94 a9 3d 	call	0x7b52	; 0x7b52 <prvAddCurrentTaskToDelayedList>
}
    6392:	0f 90       	pop	r0
    6394:	0f 90       	pop	r0
    6396:	0f 90       	pop	r0
    6398:	0f 90       	pop	r0
    639a:	cf 91       	pop	r28
    639c:	df 91       	pop	r29
    639e:	08 95       	ret

000063a0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    63a0:	df 93       	push	r29
    63a2:	cf 93       	push	r28
    63a4:	cd b7       	in	r28, 0x3d	; 61
    63a6:	de b7       	in	r29, 0x3e	; 62
    63a8:	28 97       	sbiw	r28, 0x08	; 8
    63aa:	0f b6       	in	r0, 0x3f	; 63
    63ac:	f8 94       	cli
    63ae:	de bf       	out	0x3e, r29	; 62
    63b0:	0f be       	out	0x3f, r0	; 63
    63b2:	cd bf       	out	0x3d, r28	; 61
    63b4:	9c 83       	std	Y+4, r25	; 0x04
    63b6:	8b 83       	std	Y+3, r24	; 0x03
    63b8:	7e 83       	std	Y+6, r23	; 0x06
    63ba:	6d 83       	std	Y+5, r22	; 0x05
    63bc:	58 87       	std	Y+8, r21	; 0x08
    63be:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    63c0:	e0 91 91 06 	lds	r30, 0x0691
    63c4:	f0 91 92 06 	lds	r31, 0x0692
    63c8:	8d 81       	ldd	r24, Y+5	; 0x05
    63ca:	9e 81       	ldd	r25, Y+6	; 0x06
    63cc:	90 68       	ori	r25, 0x80	; 128
    63ce:	95 87       	std	Z+13, r25	; 0x0d
    63d0:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    63d2:	eb 81       	ldd	r30, Y+3	; 0x03
    63d4:	fc 81       	ldd	r31, Y+4	; 0x04
    63d6:	81 81       	ldd	r24, Z+1	; 0x01
    63d8:	92 81       	ldd	r25, Z+2	; 0x02
    63da:	9a 83       	std	Y+2, r25	; 0x02
    63dc:	89 83       	std	Y+1, r24	; 0x01
    63de:	e0 91 91 06 	lds	r30, 0x0691
    63e2:	f0 91 92 06 	lds	r31, 0x0692
    63e6:	89 81       	ldd	r24, Y+1	; 0x01
    63e8:	9a 81       	ldd	r25, Y+2	; 0x02
    63ea:	97 87       	std	Z+15, r25	; 0x0f
    63ec:	86 87       	std	Z+14, r24	; 0x0e
    63ee:	a0 91 91 06 	lds	r26, 0x0691
    63f2:	b0 91 92 06 	lds	r27, 0x0692
    63f6:	e9 81       	ldd	r30, Y+1	; 0x01
    63f8:	fa 81       	ldd	r31, Y+2	; 0x02
    63fa:	84 81       	ldd	r24, Z+4	; 0x04
    63fc:	95 81       	ldd	r25, Z+5	; 0x05
    63fe:	51 96       	adiw	r26, 0x11	; 17
    6400:	9c 93       	st	X, r25
    6402:	8e 93       	st	-X, r24
    6404:	50 97       	sbiw	r26, 0x10	; 16
    6406:	e9 81       	ldd	r30, Y+1	; 0x01
    6408:	fa 81       	ldd	r31, Y+2	; 0x02
    640a:	04 80       	ldd	r0, Z+4	; 0x04
    640c:	f5 81       	ldd	r31, Z+5	; 0x05
    640e:	e0 2d       	mov	r30, r0
    6410:	80 91 91 06 	lds	r24, 0x0691
    6414:	90 91 92 06 	lds	r25, 0x0692
    6418:	0c 96       	adiw	r24, 0x0c	; 12
    641a:	93 83       	std	Z+3, r25	; 0x03
    641c:	82 83       	std	Z+2, r24	; 0x02
    641e:	80 91 91 06 	lds	r24, 0x0691
    6422:	90 91 92 06 	lds	r25, 0x0692
    6426:	0c 96       	adiw	r24, 0x0c	; 12
    6428:	e9 81       	ldd	r30, Y+1	; 0x01
    642a:	fa 81       	ldd	r31, Y+2	; 0x02
    642c:	95 83       	std	Z+5, r25	; 0x05
    642e:	84 83       	std	Z+4, r24	; 0x04
    6430:	e0 91 91 06 	lds	r30, 0x0691
    6434:	f0 91 92 06 	lds	r31, 0x0692
    6438:	8b 81       	ldd	r24, Y+3	; 0x03
    643a:	9c 81       	ldd	r25, Y+4	; 0x04
    643c:	95 8b       	std	Z+21, r25	; 0x15
    643e:	84 8b       	std	Z+20, r24	; 0x14
    6440:	eb 81       	ldd	r30, Y+3	; 0x03
    6442:	fc 81       	ldd	r31, Y+4	; 0x04
    6444:	80 81       	ld	r24, Z
    6446:	8f 5f       	subi	r24, 0xFF	; 255
    6448:	eb 81       	ldd	r30, Y+3	; 0x03
    644a:	fc 81       	ldd	r31, Y+4	; 0x04
    644c:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    644e:	8f 81       	ldd	r24, Y+7	; 0x07
    6450:	98 85       	ldd	r25, Y+8	; 0x08
    6452:	61 e0       	ldi	r22, 0x01	; 1
    6454:	0e 94 a9 3d 	call	0x7b52	; 0x7b52 <prvAddCurrentTaskToDelayedList>
}
    6458:	28 96       	adiw	r28, 0x08	; 8
    645a:	0f b6       	in	r0, 0x3f	; 63
    645c:	f8 94       	cli
    645e:	de bf       	out	0x3e, r29	; 62
    6460:	0f be       	out	0x3f, r0	; 63
    6462:	cd bf       	out	0x3d, r28	; 61
    6464:	cf 91       	pop	r28
    6466:	df 91       	pop	r29
    6468:	08 95       	ret

0000646a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    646a:	df 93       	push	r29
    646c:	cf 93       	push	r28
    646e:	cd b7       	in	r28, 0x3d	; 61
    6470:	de b7       	in	r29, 0x3e	; 62
    6472:	2d 97       	sbiw	r28, 0x0d	; 13
    6474:	0f b6       	in	r0, 0x3f	; 63
    6476:	f8 94       	cli
    6478:	de bf       	out	0x3e, r29	; 62
    647a:	0f be       	out	0x3f, r0	; 63
    647c:	cd bf       	out	0x3d, r28	; 61
    647e:	9d 87       	std	Y+13, r25	; 0x0d
    6480:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6482:	ec 85       	ldd	r30, Y+12	; 0x0c
    6484:	fd 85       	ldd	r31, Y+13	; 0x0d
    6486:	05 80       	ldd	r0, Z+5	; 0x05
    6488:	f6 81       	ldd	r31, Z+6	; 0x06
    648a:	e0 2d       	mov	r30, r0
    648c:	86 81       	ldd	r24, Z+6	; 0x06
    648e:	97 81       	ldd	r25, Z+7	; 0x07
    6490:	9b 87       	std	Y+11, r25	; 0x0b
    6492:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    6494:	ea 85       	ldd	r30, Y+10	; 0x0a
    6496:	fb 85       	ldd	r31, Y+11	; 0x0b
    6498:	84 89       	ldd	r24, Z+20	; 0x14
    649a:	95 89       	ldd	r25, Z+21	; 0x15
    649c:	98 87       	std	Y+8, r25	; 0x08
    649e:	8f 83       	std	Y+7, r24	; 0x07
    64a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    64a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    64a4:	a6 85       	ldd	r26, Z+14	; 0x0e
    64a6:	b7 85       	ldd	r27, Z+15	; 0x0f
    64a8:	ea 85       	ldd	r30, Y+10	; 0x0a
    64aa:	fb 85       	ldd	r31, Y+11	; 0x0b
    64ac:	80 89       	ldd	r24, Z+16	; 0x10
    64ae:	91 89       	ldd	r25, Z+17	; 0x11
    64b0:	15 96       	adiw	r26, 0x05	; 5
    64b2:	9c 93       	st	X, r25
    64b4:	8e 93       	st	-X, r24
    64b6:	14 97       	sbiw	r26, 0x04	; 4
    64b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    64ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    64bc:	a0 89       	ldd	r26, Z+16	; 0x10
    64be:	b1 89       	ldd	r27, Z+17	; 0x11
    64c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    64c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    64c4:	86 85       	ldd	r24, Z+14	; 0x0e
    64c6:	97 85       	ldd	r25, Z+15	; 0x0f
    64c8:	13 96       	adiw	r26, 0x03	; 3
    64ca:	9c 93       	st	X, r25
    64cc:	8e 93       	st	-X, r24
    64ce:	12 97       	sbiw	r26, 0x02	; 2
    64d0:	ef 81       	ldd	r30, Y+7	; 0x07
    64d2:	f8 85       	ldd	r31, Y+8	; 0x08
    64d4:	21 81       	ldd	r18, Z+1	; 0x01
    64d6:	32 81       	ldd	r19, Z+2	; 0x02
    64d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    64da:	9b 85       	ldd	r25, Y+11	; 0x0b
    64dc:	0c 96       	adiw	r24, 0x0c	; 12
    64de:	28 17       	cp	r18, r24
    64e0:	39 07       	cpc	r19, r25
    64e2:	41 f4       	brne	.+16     	; 0x64f4 <xTaskRemoveFromEventList+0x8a>
    64e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    64e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    64e8:	80 89       	ldd	r24, Z+16	; 0x10
    64ea:	91 89       	ldd	r25, Z+17	; 0x11
    64ec:	ef 81       	ldd	r30, Y+7	; 0x07
    64ee:	f8 85       	ldd	r31, Y+8	; 0x08
    64f0:	92 83       	std	Z+2, r25	; 0x02
    64f2:	81 83       	std	Z+1, r24	; 0x01
    64f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    64f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    64f8:	15 8a       	std	Z+21, r1	; 0x15
    64fa:	14 8a       	std	Z+20, r1	; 0x14
    64fc:	ef 81       	ldd	r30, Y+7	; 0x07
    64fe:	f8 85       	ldd	r31, Y+8	; 0x08
    6500:	80 81       	ld	r24, Z
    6502:	81 50       	subi	r24, 0x01	; 1
    6504:	ef 81       	ldd	r30, Y+7	; 0x07
    6506:	f8 85       	ldd	r31, Y+8	; 0x08
    6508:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    650a:	80 91 a2 06 	lds	r24, 0x06A2
    650e:	88 23       	and	r24, r24
    6510:	09 f0       	breq	.+2      	; 0x6514 <xTaskRemoveFromEventList+0xaa>
    6512:	a4 c0       	rjmp	.+328    	; 0x665c <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    6514:	ea 85       	ldd	r30, Y+10	; 0x0a
    6516:	fb 85       	ldd	r31, Y+11	; 0x0b
    6518:	82 85       	ldd	r24, Z+10	; 0x0a
    651a:	93 85       	ldd	r25, Z+11	; 0x0b
    651c:	9e 83       	std	Y+6, r25	; 0x06
    651e:	8d 83       	std	Y+5, r24	; 0x05
    6520:	ea 85       	ldd	r30, Y+10	; 0x0a
    6522:	fb 85       	ldd	r31, Y+11	; 0x0b
    6524:	a4 81       	ldd	r26, Z+4	; 0x04
    6526:	b5 81       	ldd	r27, Z+5	; 0x05
    6528:	ea 85       	ldd	r30, Y+10	; 0x0a
    652a:	fb 85       	ldd	r31, Y+11	; 0x0b
    652c:	86 81       	ldd	r24, Z+6	; 0x06
    652e:	97 81       	ldd	r25, Z+7	; 0x07
    6530:	15 96       	adiw	r26, 0x05	; 5
    6532:	9c 93       	st	X, r25
    6534:	8e 93       	st	-X, r24
    6536:	14 97       	sbiw	r26, 0x04	; 4
    6538:	ea 85       	ldd	r30, Y+10	; 0x0a
    653a:	fb 85       	ldd	r31, Y+11	; 0x0b
    653c:	a6 81       	ldd	r26, Z+6	; 0x06
    653e:	b7 81       	ldd	r27, Z+7	; 0x07
    6540:	ea 85       	ldd	r30, Y+10	; 0x0a
    6542:	fb 85       	ldd	r31, Y+11	; 0x0b
    6544:	84 81       	ldd	r24, Z+4	; 0x04
    6546:	95 81       	ldd	r25, Z+5	; 0x05
    6548:	13 96       	adiw	r26, 0x03	; 3
    654a:	9c 93       	st	X, r25
    654c:	8e 93       	st	-X, r24
    654e:	12 97       	sbiw	r26, 0x02	; 2
    6550:	ed 81       	ldd	r30, Y+5	; 0x05
    6552:	fe 81       	ldd	r31, Y+6	; 0x06
    6554:	21 81       	ldd	r18, Z+1	; 0x01
    6556:	32 81       	ldd	r19, Z+2	; 0x02
    6558:	8a 85       	ldd	r24, Y+10	; 0x0a
    655a:	9b 85       	ldd	r25, Y+11	; 0x0b
    655c:	02 96       	adiw	r24, 0x02	; 2
    655e:	28 17       	cp	r18, r24
    6560:	39 07       	cpc	r19, r25
    6562:	41 f4       	brne	.+16     	; 0x6574 <xTaskRemoveFromEventList+0x10a>
    6564:	ea 85       	ldd	r30, Y+10	; 0x0a
    6566:	fb 85       	ldd	r31, Y+11	; 0x0b
    6568:	86 81       	ldd	r24, Z+6	; 0x06
    656a:	97 81       	ldd	r25, Z+7	; 0x07
    656c:	ed 81       	ldd	r30, Y+5	; 0x05
    656e:	fe 81       	ldd	r31, Y+6	; 0x06
    6570:	92 83       	std	Z+2, r25	; 0x02
    6572:	81 83       	std	Z+1, r24	; 0x01
    6574:	ea 85       	ldd	r30, Y+10	; 0x0a
    6576:	fb 85       	ldd	r31, Y+11	; 0x0b
    6578:	13 86       	std	Z+11, r1	; 0x0b
    657a:	12 86       	std	Z+10, r1	; 0x0a
    657c:	ed 81       	ldd	r30, Y+5	; 0x05
    657e:	fe 81       	ldd	r31, Y+6	; 0x06
    6580:	80 81       	ld	r24, Z
    6582:	81 50       	subi	r24, 0x01	; 1
    6584:	ed 81       	ldd	r30, Y+5	; 0x05
    6586:	fe 81       	ldd	r31, Y+6	; 0x06
    6588:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    658a:	ea 85       	ldd	r30, Y+10	; 0x0a
    658c:	fb 85       	ldd	r31, Y+11	; 0x0b
    658e:	96 89       	ldd	r25, Z+22	; 0x16
    6590:	80 91 97 06 	lds	r24, 0x0697
    6594:	89 17       	cp	r24, r25
    6596:	28 f4       	brcc	.+10     	; 0x65a2 <xTaskRemoveFromEventList+0x138>
    6598:	ea 85       	ldd	r30, Y+10	; 0x0a
    659a:	fb 85       	ldd	r31, Y+11	; 0x0b
    659c:	86 89       	ldd	r24, Z+22	; 0x16
    659e:	80 93 97 06 	sts	0x0697, r24
    65a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    65a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    65a6:	86 89       	ldd	r24, Z+22	; 0x16
    65a8:	28 2f       	mov	r18, r24
    65aa:	30 e0       	ldi	r19, 0x00	; 0
    65ac:	c9 01       	movw	r24, r18
    65ae:	88 0f       	add	r24, r24
    65b0:	99 1f       	adc	r25, r25
    65b2:	88 0f       	add	r24, r24
    65b4:	99 1f       	adc	r25, r25
    65b6:	88 0f       	add	r24, r24
    65b8:	99 1f       	adc	r25, r25
    65ba:	82 0f       	add	r24, r18
    65bc:	93 1f       	adc	r25, r19
    65be:	fc 01       	movw	r30, r24
    65c0:	ed 55       	subi	r30, 0x5D	; 93
    65c2:	f9 4f       	sbci	r31, 0xF9	; 249
    65c4:	81 81       	ldd	r24, Z+1	; 0x01
    65c6:	92 81       	ldd	r25, Z+2	; 0x02
    65c8:	9c 83       	std	Y+4, r25	; 0x04
    65ca:	8b 83       	std	Y+3, r24	; 0x03
    65cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    65ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    65d0:	8b 81       	ldd	r24, Y+3	; 0x03
    65d2:	9c 81       	ldd	r25, Y+4	; 0x04
    65d4:	95 83       	std	Z+5, r25	; 0x05
    65d6:	84 83       	std	Z+4, r24	; 0x04
    65d8:	eb 81       	ldd	r30, Y+3	; 0x03
    65da:	fc 81       	ldd	r31, Y+4	; 0x04
    65dc:	84 81       	ldd	r24, Z+4	; 0x04
    65de:	95 81       	ldd	r25, Z+5	; 0x05
    65e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    65e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    65e4:	97 83       	std	Z+7, r25	; 0x07
    65e6:	86 83       	std	Z+6, r24	; 0x06
    65e8:	eb 81       	ldd	r30, Y+3	; 0x03
    65ea:	fc 81       	ldd	r31, Y+4	; 0x04
    65ec:	04 80       	ldd	r0, Z+4	; 0x04
    65ee:	f5 81       	ldd	r31, Z+5	; 0x05
    65f0:	e0 2d       	mov	r30, r0
    65f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    65f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    65f6:	02 96       	adiw	r24, 0x02	; 2
    65f8:	93 83       	std	Z+3, r25	; 0x03
    65fa:	82 83       	std	Z+2, r24	; 0x02
    65fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    65fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    6600:	02 96       	adiw	r24, 0x02	; 2
    6602:	eb 81       	ldd	r30, Y+3	; 0x03
    6604:	fc 81       	ldd	r31, Y+4	; 0x04
    6606:	95 83       	std	Z+5, r25	; 0x05
    6608:	84 83       	std	Z+4, r24	; 0x04
    660a:	ea 85       	ldd	r30, Y+10	; 0x0a
    660c:	fb 85       	ldd	r31, Y+11	; 0x0b
    660e:	86 89       	ldd	r24, Z+22	; 0x16
    6610:	28 2f       	mov	r18, r24
    6612:	30 e0       	ldi	r19, 0x00	; 0
    6614:	c9 01       	movw	r24, r18
    6616:	88 0f       	add	r24, r24
    6618:	99 1f       	adc	r25, r25
    661a:	88 0f       	add	r24, r24
    661c:	99 1f       	adc	r25, r25
    661e:	88 0f       	add	r24, r24
    6620:	99 1f       	adc	r25, r25
    6622:	82 0f       	add	r24, r18
    6624:	93 1f       	adc	r25, r19
    6626:	8d 55       	subi	r24, 0x5D	; 93
    6628:	99 4f       	sbci	r25, 0xF9	; 249
    662a:	ea 85       	ldd	r30, Y+10	; 0x0a
    662c:	fb 85       	ldd	r31, Y+11	; 0x0b
    662e:	93 87       	std	Z+11, r25	; 0x0b
    6630:	82 87       	std	Z+10, r24	; 0x0a
    6632:	ea 85       	ldd	r30, Y+10	; 0x0a
    6634:	fb 85       	ldd	r31, Y+11	; 0x0b
    6636:	86 89       	ldd	r24, Z+22	; 0x16
    6638:	28 2f       	mov	r18, r24
    663a:	30 e0       	ldi	r19, 0x00	; 0
    663c:	c9 01       	movw	r24, r18
    663e:	88 0f       	add	r24, r24
    6640:	99 1f       	adc	r25, r25
    6642:	88 0f       	add	r24, r24
    6644:	99 1f       	adc	r25, r25
    6646:	88 0f       	add	r24, r24
    6648:	99 1f       	adc	r25, r25
    664a:	82 0f       	add	r24, r18
    664c:	93 1f       	adc	r25, r19
    664e:	fc 01       	movw	r30, r24
    6650:	ed 55       	subi	r30, 0x5D	; 93
    6652:	f9 4f       	sbci	r31, 0xF9	; 249
    6654:	80 81       	ld	r24, Z
    6656:	8f 5f       	subi	r24, 0xFF	; 255
    6658:	80 83       	st	Z, r24
    665a:	30 c0       	rjmp	.+96     	; 0x66bc <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    665c:	80 91 de 06 	lds	r24, 0x06DE
    6660:	90 91 df 06 	lds	r25, 0x06DF
    6664:	9a 83       	std	Y+2, r25	; 0x02
    6666:	89 83       	std	Y+1, r24	; 0x01
    6668:	ea 85       	ldd	r30, Y+10	; 0x0a
    666a:	fb 85       	ldd	r31, Y+11	; 0x0b
    666c:	89 81       	ldd	r24, Y+1	; 0x01
    666e:	9a 81       	ldd	r25, Y+2	; 0x02
    6670:	97 87       	std	Z+15, r25	; 0x0f
    6672:	86 87       	std	Z+14, r24	; 0x0e
    6674:	e9 81       	ldd	r30, Y+1	; 0x01
    6676:	fa 81       	ldd	r31, Y+2	; 0x02
    6678:	84 81       	ldd	r24, Z+4	; 0x04
    667a:	95 81       	ldd	r25, Z+5	; 0x05
    667c:	ea 85       	ldd	r30, Y+10	; 0x0a
    667e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6680:	91 8b       	std	Z+17, r25	; 0x11
    6682:	80 8b       	std	Z+16, r24	; 0x10
    6684:	e9 81       	ldd	r30, Y+1	; 0x01
    6686:	fa 81       	ldd	r31, Y+2	; 0x02
    6688:	04 80       	ldd	r0, Z+4	; 0x04
    668a:	f5 81       	ldd	r31, Z+5	; 0x05
    668c:	e0 2d       	mov	r30, r0
    668e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6690:	9b 85       	ldd	r25, Y+11	; 0x0b
    6692:	0c 96       	adiw	r24, 0x0c	; 12
    6694:	93 83       	std	Z+3, r25	; 0x03
    6696:	82 83       	std	Z+2, r24	; 0x02
    6698:	8a 85       	ldd	r24, Y+10	; 0x0a
    669a:	9b 85       	ldd	r25, Y+11	; 0x0b
    669c:	0c 96       	adiw	r24, 0x0c	; 12
    669e:	e9 81       	ldd	r30, Y+1	; 0x01
    66a0:	fa 81       	ldd	r31, Y+2	; 0x02
    66a2:	95 83       	std	Z+5, r25	; 0x05
    66a4:	84 83       	std	Z+4, r24	; 0x04
    66a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    66a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    66aa:	8d ed       	ldi	r24, 0xDD	; 221
    66ac:	96 e0       	ldi	r25, 0x06	; 6
    66ae:	95 8b       	std	Z+21, r25	; 0x15
    66b0:	84 8b       	std	Z+20, r24	; 0x14
    66b2:	80 91 dd 06 	lds	r24, 0x06DD
    66b6:	8f 5f       	subi	r24, 0xFF	; 255
    66b8:	80 93 dd 06 	sts	0x06DD, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    66bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    66be:	fb 85       	ldd	r31, Y+11	; 0x0b
    66c0:	96 89       	ldd	r25, Z+22	; 0x16
    66c2:	e0 91 91 06 	lds	r30, 0x0691
    66c6:	f0 91 92 06 	lds	r31, 0x0692
    66ca:	86 89       	ldd	r24, Z+22	; 0x16
    66cc:	89 17       	cp	r24, r25
    66ce:	30 f4       	brcc	.+12     	; 0x66dc <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    66d0:	81 e0       	ldi	r24, 0x01	; 1
    66d2:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    66d4:	81 e0       	ldi	r24, 0x01	; 1
    66d6:	80 93 9b 06 	sts	0x069B, r24
    66da:	01 c0       	rjmp	.+2      	; 0x66de <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    66dc:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    66de:	89 85       	ldd	r24, Y+9	; 0x09
}
    66e0:	2d 96       	adiw	r28, 0x0d	; 13
    66e2:	0f b6       	in	r0, 0x3f	; 63
    66e4:	f8 94       	cli
    66e6:	de bf       	out	0x3e, r29	; 62
    66e8:	0f be       	out	0x3f, r0	; 63
    66ea:	cd bf       	out	0x3d, r28	; 61
    66ec:	cf 91       	pop	r28
    66ee:	df 91       	pop	r29
    66f0:	08 95       	ret

000066f2 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    66f2:	df 93       	push	r29
    66f4:	cf 93       	push	r28
    66f6:	cd b7       	in	r28, 0x3d	; 61
    66f8:	de b7       	in	r29, 0x3e	; 62
    66fa:	2c 97       	sbiw	r28, 0x0c	; 12
    66fc:	0f b6       	in	r0, 0x3f	; 63
    66fe:	f8 94       	cli
    6700:	de bf       	out	0x3e, r29	; 62
    6702:	0f be       	out	0x3f, r0	; 63
    6704:	cd bf       	out	0x3d, r28	; 61
    6706:	9a 87       	std	Y+10, r25	; 0x0a
    6708:	89 87       	std	Y+9, r24	; 0x09
    670a:	7c 87       	std	Y+12, r23	; 0x0c
    670c:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    670e:	8b 85       	ldd	r24, Y+11	; 0x0b
    6710:	9c 85       	ldd	r25, Y+12	; 0x0c
    6712:	90 68       	ori	r25, 0x80	; 128
    6714:	e9 85       	ldd	r30, Y+9	; 0x09
    6716:	fa 85       	ldd	r31, Y+10	; 0x0a
    6718:	91 83       	std	Z+1, r25	; 0x01
    671a:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    671c:	e9 85       	ldd	r30, Y+9	; 0x09
    671e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6720:	86 81       	ldd	r24, Z+6	; 0x06
    6722:	97 81       	ldd	r25, Z+7	; 0x07
    6724:	98 87       	std	Y+8, r25	; 0x08
    6726:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    6728:	e9 85       	ldd	r30, Y+9	; 0x09
    672a:	fa 85       	ldd	r31, Y+10	; 0x0a
    672c:	80 85       	ldd	r24, Z+8	; 0x08
    672e:	91 85       	ldd	r25, Z+9	; 0x09
    6730:	9e 83       	std	Y+6, r25	; 0x06
    6732:	8d 83       	std	Y+5, r24	; 0x05
    6734:	e9 85       	ldd	r30, Y+9	; 0x09
    6736:	fa 85       	ldd	r31, Y+10	; 0x0a
    6738:	a2 81       	ldd	r26, Z+2	; 0x02
    673a:	b3 81       	ldd	r27, Z+3	; 0x03
    673c:	e9 85       	ldd	r30, Y+9	; 0x09
    673e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6740:	84 81       	ldd	r24, Z+4	; 0x04
    6742:	95 81       	ldd	r25, Z+5	; 0x05
    6744:	15 96       	adiw	r26, 0x05	; 5
    6746:	9c 93       	st	X, r25
    6748:	8e 93       	st	-X, r24
    674a:	14 97       	sbiw	r26, 0x04	; 4
    674c:	e9 85       	ldd	r30, Y+9	; 0x09
    674e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6750:	a4 81       	ldd	r26, Z+4	; 0x04
    6752:	b5 81       	ldd	r27, Z+5	; 0x05
    6754:	e9 85       	ldd	r30, Y+9	; 0x09
    6756:	fa 85       	ldd	r31, Y+10	; 0x0a
    6758:	82 81       	ldd	r24, Z+2	; 0x02
    675a:	93 81       	ldd	r25, Z+3	; 0x03
    675c:	13 96       	adiw	r26, 0x03	; 3
    675e:	9c 93       	st	X, r25
    6760:	8e 93       	st	-X, r24
    6762:	12 97       	sbiw	r26, 0x02	; 2
    6764:	ed 81       	ldd	r30, Y+5	; 0x05
    6766:	fe 81       	ldd	r31, Y+6	; 0x06
    6768:	21 81       	ldd	r18, Z+1	; 0x01
    676a:	32 81       	ldd	r19, Z+2	; 0x02
    676c:	89 85       	ldd	r24, Y+9	; 0x09
    676e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6770:	28 17       	cp	r18, r24
    6772:	39 07       	cpc	r19, r25
    6774:	41 f4       	brne	.+16     	; 0x6786 <vTaskRemoveFromUnorderedEventList+0x94>
    6776:	e9 85       	ldd	r30, Y+9	; 0x09
    6778:	fa 85       	ldd	r31, Y+10	; 0x0a
    677a:	84 81       	ldd	r24, Z+4	; 0x04
    677c:	95 81       	ldd	r25, Z+5	; 0x05
    677e:	ed 81       	ldd	r30, Y+5	; 0x05
    6780:	fe 81       	ldd	r31, Y+6	; 0x06
    6782:	92 83       	std	Z+2, r25	; 0x02
    6784:	81 83       	std	Z+1, r24	; 0x01
    6786:	e9 85       	ldd	r30, Y+9	; 0x09
    6788:	fa 85       	ldd	r31, Y+10	; 0x0a
    678a:	11 86       	std	Z+9, r1	; 0x09
    678c:	10 86       	std	Z+8, r1	; 0x08
    678e:	ed 81       	ldd	r30, Y+5	; 0x05
    6790:	fe 81       	ldd	r31, Y+6	; 0x06
    6792:	80 81       	ld	r24, Z
    6794:	81 50       	subi	r24, 0x01	; 1
    6796:	ed 81       	ldd	r30, Y+5	; 0x05
    6798:	fe 81       	ldd	r31, Y+6	; 0x06
    679a:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    679c:	ef 81       	ldd	r30, Y+7	; 0x07
    679e:	f8 85       	ldd	r31, Y+8	; 0x08
    67a0:	82 85       	ldd	r24, Z+10	; 0x0a
    67a2:	93 85       	ldd	r25, Z+11	; 0x0b
    67a4:	9c 83       	std	Y+4, r25	; 0x04
    67a6:	8b 83       	std	Y+3, r24	; 0x03
    67a8:	ef 81       	ldd	r30, Y+7	; 0x07
    67aa:	f8 85       	ldd	r31, Y+8	; 0x08
    67ac:	a4 81       	ldd	r26, Z+4	; 0x04
    67ae:	b5 81       	ldd	r27, Z+5	; 0x05
    67b0:	ef 81       	ldd	r30, Y+7	; 0x07
    67b2:	f8 85       	ldd	r31, Y+8	; 0x08
    67b4:	86 81       	ldd	r24, Z+6	; 0x06
    67b6:	97 81       	ldd	r25, Z+7	; 0x07
    67b8:	15 96       	adiw	r26, 0x05	; 5
    67ba:	9c 93       	st	X, r25
    67bc:	8e 93       	st	-X, r24
    67be:	14 97       	sbiw	r26, 0x04	; 4
    67c0:	ef 81       	ldd	r30, Y+7	; 0x07
    67c2:	f8 85       	ldd	r31, Y+8	; 0x08
    67c4:	a6 81       	ldd	r26, Z+6	; 0x06
    67c6:	b7 81       	ldd	r27, Z+7	; 0x07
    67c8:	ef 81       	ldd	r30, Y+7	; 0x07
    67ca:	f8 85       	ldd	r31, Y+8	; 0x08
    67cc:	84 81       	ldd	r24, Z+4	; 0x04
    67ce:	95 81       	ldd	r25, Z+5	; 0x05
    67d0:	13 96       	adiw	r26, 0x03	; 3
    67d2:	9c 93       	st	X, r25
    67d4:	8e 93       	st	-X, r24
    67d6:	12 97       	sbiw	r26, 0x02	; 2
    67d8:	eb 81       	ldd	r30, Y+3	; 0x03
    67da:	fc 81       	ldd	r31, Y+4	; 0x04
    67dc:	21 81       	ldd	r18, Z+1	; 0x01
    67de:	32 81       	ldd	r19, Z+2	; 0x02
    67e0:	8f 81       	ldd	r24, Y+7	; 0x07
    67e2:	98 85       	ldd	r25, Y+8	; 0x08
    67e4:	02 96       	adiw	r24, 0x02	; 2
    67e6:	28 17       	cp	r18, r24
    67e8:	39 07       	cpc	r19, r25
    67ea:	41 f4       	brne	.+16     	; 0x67fc <vTaskRemoveFromUnorderedEventList+0x10a>
    67ec:	ef 81       	ldd	r30, Y+7	; 0x07
    67ee:	f8 85       	ldd	r31, Y+8	; 0x08
    67f0:	86 81       	ldd	r24, Z+6	; 0x06
    67f2:	97 81       	ldd	r25, Z+7	; 0x07
    67f4:	eb 81       	ldd	r30, Y+3	; 0x03
    67f6:	fc 81       	ldd	r31, Y+4	; 0x04
    67f8:	92 83       	std	Z+2, r25	; 0x02
    67fa:	81 83       	std	Z+1, r24	; 0x01
    67fc:	ef 81       	ldd	r30, Y+7	; 0x07
    67fe:	f8 85       	ldd	r31, Y+8	; 0x08
    6800:	13 86       	std	Z+11, r1	; 0x0b
    6802:	12 86       	std	Z+10, r1	; 0x0a
    6804:	eb 81       	ldd	r30, Y+3	; 0x03
    6806:	fc 81       	ldd	r31, Y+4	; 0x04
    6808:	80 81       	ld	r24, Z
    680a:	81 50       	subi	r24, 0x01	; 1
    680c:	eb 81       	ldd	r30, Y+3	; 0x03
    680e:	fc 81       	ldd	r31, Y+4	; 0x04
    6810:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    6812:	ef 81       	ldd	r30, Y+7	; 0x07
    6814:	f8 85       	ldd	r31, Y+8	; 0x08
    6816:	96 89       	ldd	r25, Z+22	; 0x16
    6818:	80 91 97 06 	lds	r24, 0x0697
    681c:	89 17       	cp	r24, r25
    681e:	28 f4       	brcc	.+10     	; 0x682a <vTaskRemoveFromUnorderedEventList+0x138>
    6820:	ef 81       	ldd	r30, Y+7	; 0x07
    6822:	f8 85       	ldd	r31, Y+8	; 0x08
    6824:	86 89       	ldd	r24, Z+22	; 0x16
    6826:	80 93 97 06 	sts	0x0697, r24
    682a:	ef 81       	ldd	r30, Y+7	; 0x07
    682c:	f8 85       	ldd	r31, Y+8	; 0x08
    682e:	86 89       	ldd	r24, Z+22	; 0x16
    6830:	28 2f       	mov	r18, r24
    6832:	30 e0       	ldi	r19, 0x00	; 0
    6834:	c9 01       	movw	r24, r18
    6836:	88 0f       	add	r24, r24
    6838:	99 1f       	adc	r25, r25
    683a:	88 0f       	add	r24, r24
    683c:	99 1f       	adc	r25, r25
    683e:	88 0f       	add	r24, r24
    6840:	99 1f       	adc	r25, r25
    6842:	82 0f       	add	r24, r18
    6844:	93 1f       	adc	r25, r19
    6846:	fc 01       	movw	r30, r24
    6848:	ed 55       	subi	r30, 0x5D	; 93
    684a:	f9 4f       	sbci	r31, 0xF9	; 249
    684c:	81 81       	ldd	r24, Z+1	; 0x01
    684e:	92 81       	ldd	r25, Z+2	; 0x02
    6850:	9a 83       	std	Y+2, r25	; 0x02
    6852:	89 83       	std	Y+1, r24	; 0x01
    6854:	ef 81       	ldd	r30, Y+7	; 0x07
    6856:	f8 85       	ldd	r31, Y+8	; 0x08
    6858:	89 81       	ldd	r24, Y+1	; 0x01
    685a:	9a 81       	ldd	r25, Y+2	; 0x02
    685c:	95 83       	std	Z+5, r25	; 0x05
    685e:	84 83       	std	Z+4, r24	; 0x04
    6860:	e9 81       	ldd	r30, Y+1	; 0x01
    6862:	fa 81       	ldd	r31, Y+2	; 0x02
    6864:	84 81       	ldd	r24, Z+4	; 0x04
    6866:	95 81       	ldd	r25, Z+5	; 0x05
    6868:	ef 81       	ldd	r30, Y+7	; 0x07
    686a:	f8 85       	ldd	r31, Y+8	; 0x08
    686c:	97 83       	std	Z+7, r25	; 0x07
    686e:	86 83       	std	Z+6, r24	; 0x06
    6870:	e9 81       	ldd	r30, Y+1	; 0x01
    6872:	fa 81       	ldd	r31, Y+2	; 0x02
    6874:	04 80       	ldd	r0, Z+4	; 0x04
    6876:	f5 81       	ldd	r31, Z+5	; 0x05
    6878:	e0 2d       	mov	r30, r0
    687a:	8f 81       	ldd	r24, Y+7	; 0x07
    687c:	98 85       	ldd	r25, Y+8	; 0x08
    687e:	02 96       	adiw	r24, 0x02	; 2
    6880:	93 83       	std	Z+3, r25	; 0x03
    6882:	82 83       	std	Z+2, r24	; 0x02
    6884:	8f 81       	ldd	r24, Y+7	; 0x07
    6886:	98 85       	ldd	r25, Y+8	; 0x08
    6888:	02 96       	adiw	r24, 0x02	; 2
    688a:	e9 81       	ldd	r30, Y+1	; 0x01
    688c:	fa 81       	ldd	r31, Y+2	; 0x02
    688e:	95 83       	std	Z+5, r25	; 0x05
    6890:	84 83       	std	Z+4, r24	; 0x04
    6892:	ef 81       	ldd	r30, Y+7	; 0x07
    6894:	f8 85       	ldd	r31, Y+8	; 0x08
    6896:	86 89       	ldd	r24, Z+22	; 0x16
    6898:	28 2f       	mov	r18, r24
    689a:	30 e0       	ldi	r19, 0x00	; 0
    689c:	c9 01       	movw	r24, r18
    689e:	88 0f       	add	r24, r24
    68a0:	99 1f       	adc	r25, r25
    68a2:	88 0f       	add	r24, r24
    68a4:	99 1f       	adc	r25, r25
    68a6:	88 0f       	add	r24, r24
    68a8:	99 1f       	adc	r25, r25
    68aa:	82 0f       	add	r24, r18
    68ac:	93 1f       	adc	r25, r19
    68ae:	8d 55       	subi	r24, 0x5D	; 93
    68b0:	99 4f       	sbci	r25, 0xF9	; 249
    68b2:	ef 81       	ldd	r30, Y+7	; 0x07
    68b4:	f8 85       	ldd	r31, Y+8	; 0x08
    68b6:	93 87       	std	Z+11, r25	; 0x0b
    68b8:	82 87       	std	Z+10, r24	; 0x0a
    68ba:	ef 81       	ldd	r30, Y+7	; 0x07
    68bc:	f8 85       	ldd	r31, Y+8	; 0x08
    68be:	86 89       	ldd	r24, Z+22	; 0x16
    68c0:	28 2f       	mov	r18, r24
    68c2:	30 e0       	ldi	r19, 0x00	; 0
    68c4:	c9 01       	movw	r24, r18
    68c6:	88 0f       	add	r24, r24
    68c8:	99 1f       	adc	r25, r25
    68ca:	88 0f       	add	r24, r24
    68cc:	99 1f       	adc	r25, r25
    68ce:	88 0f       	add	r24, r24
    68d0:	99 1f       	adc	r25, r25
    68d2:	82 0f       	add	r24, r18
    68d4:	93 1f       	adc	r25, r19
    68d6:	fc 01       	movw	r30, r24
    68d8:	ed 55       	subi	r30, 0x5D	; 93
    68da:	f9 4f       	sbci	r31, 0xF9	; 249
    68dc:	80 81       	ld	r24, Z
    68de:	8f 5f       	subi	r24, 0xFF	; 255
    68e0:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    68e2:	ef 81       	ldd	r30, Y+7	; 0x07
    68e4:	f8 85       	ldd	r31, Y+8	; 0x08
    68e6:	96 89       	ldd	r25, Z+22	; 0x16
    68e8:	e0 91 91 06 	lds	r30, 0x0691
    68ec:	f0 91 92 06 	lds	r31, 0x0692
    68f0:	86 89       	ldd	r24, Z+22	; 0x16
    68f2:	89 17       	cp	r24, r25
    68f4:	18 f4       	brcc	.+6      	; 0x68fc <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    68f6:	81 e0       	ldi	r24, 0x01	; 1
    68f8:	80 93 9b 06 	sts	0x069B, r24
    }
}
    68fc:	2c 96       	adiw	r28, 0x0c	; 12
    68fe:	0f b6       	in	r0, 0x3f	; 63
    6900:	f8 94       	cli
    6902:	de bf       	out	0x3e, r29	; 62
    6904:	0f be       	out	0x3f, r0	; 63
    6906:	cd bf       	out	0x3d, r28	; 61
    6908:	cf 91       	pop	r28
    690a:	df 91       	pop	r29
    690c:	08 95       	ret

0000690e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    690e:	df 93       	push	r29
    6910:	cf 93       	push	r28
    6912:	00 d0       	rcall	.+0      	; 0x6914 <vTaskSetTimeOutState+0x6>
    6914:	cd b7       	in	r28, 0x3d	; 61
    6916:	de b7       	in	r29, 0x3e	; 62
    6918:	9a 83       	std	Y+2, r25	; 0x02
    691a:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    691c:	0f b6       	in	r0, 0x3f	; 63
    691e:	f8 94       	cli
    6920:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    6922:	80 91 9c 06 	lds	r24, 0x069C
    6926:	e9 81       	ldd	r30, Y+1	; 0x01
    6928:	fa 81       	ldd	r31, Y+2	; 0x02
    692a:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    692c:	80 91 95 06 	lds	r24, 0x0695
    6930:	90 91 96 06 	lds	r25, 0x0696
    6934:	e9 81       	ldd	r30, Y+1	; 0x01
    6936:	fa 81       	ldd	r31, Y+2	; 0x02
    6938:	92 83       	std	Z+2, r25	; 0x02
    693a:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    693c:	0f 90       	pop	r0
    693e:	0f be       	out	0x3f, r0	; 63
}
    6940:	0f 90       	pop	r0
    6942:	0f 90       	pop	r0
    6944:	cf 91       	pop	r28
    6946:	df 91       	pop	r29
    6948:	08 95       	ret

0000694a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    694a:	df 93       	push	r29
    694c:	cf 93       	push	r28
    694e:	00 d0       	rcall	.+0      	; 0x6950 <vTaskInternalSetTimeOutState+0x6>
    6950:	cd b7       	in	r28, 0x3d	; 61
    6952:	de b7       	in	r29, 0x3e	; 62
    6954:	9a 83       	std	Y+2, r25	; 0x02
    6956:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    6958:	80 91 9c 06 	lds	r24, 0x069C
    695c:	e9 81       	ldd	r30, Y+1	; 0x01
    695e:	fa 81       	ldd	r31, Y+2	; 0x02
    6960:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    6962:	80 91 95 06 	lds	r24, 0x0695
    6966:	90 91 96 06 	lds	r25, 0x0696
    696a:	e9 81       	ldd	r30, Y+1	; 0x01
    696c:	fa 81       	ldd	r31, Y+2	; 0x02
    696e:	92 83       	std	Z+2, r25	; 0x02
    6970:	81 83       	std	Z+1, r24	; 0x01
}
    6972:	0f 90       	pop	r0
    6974:	0f 90       	pop	r0
    6976:	cf 91       	pop	r28
    6978:	df 91       	pop	r29
    697a:	08 95       	ret

0000697c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    697c:	df 93       	push	r29
    697e:	cf 93       	push	r28
    6980:	cd b7       	in	r28, 0x3d	; 61
    6982:	de b7       	in	r29, 0x3e	; 62
    6984:	29 97       	sbiw	r28, 0x09	; 9
    6986:	0f b6       	in	r0, 0x3f	; 63
    6988:	f8 94       	cli
    698a:	de bf       	out	0x3e, r29	; 62
    698c:	0f be       	out	0x3f, r0	; 63
    698e:	cd bf       	out	0x3d, r28	; 61
    6990:	9f 83       	std	Y+7, r25	; 0x07
    6992:	8e 83       	std	Y+6, r24	; 0x06
    6994:	79 87       	std	Y+9, r23	; 0x09
    6996:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    6998:	0f b6       	in	r0, 0x3f	; 63
    699a:	f8 94       	cli
    699c:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    699e:	80 91 95 06 	lds	r24, 0x0695
    69a2:	90 91 96 06 	lds	r25, 0x0696
    69a6:	9c 83       	std	Y+4, r25	; 0x04
    69a8:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    69aa:	ee 81       	ldd	r30, Y+6	; 0x06
    69ac:	ff 81       	ldd	r31, Y+7	; 0x07
    69ae:	21 81       	ldd	r18, Z+1	; 0x01
    69b0:	32 81       	ldd	r19, Z+2	; 0x02
    69b2:	8b 81       	ldd	r24, Y+3	; 0x03
    69b4:	9c 81       	ldd	r25, Y+4	; 0x04
    69b6:	82 1b       	sub	r24, r18
    69b8:	93 0b       	sbc	r25, r19
    69ba:	9a 83       	std	Y+2, r25	; 0x02
    69bc:	89 83       	std	Y+1, r24	; 0x01
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    69be:	e8 85       	ldd	r30, Y+8	; 0x08
    69c0:	f9 85       	ldd	r31, Y+9	; 0x09
    69c2:	80 81       	ld	r24, Z
    69c4:	91 81       	ldd	r25, Z+1	; 0x01
    69c6:	2f ef       	ldi	r18, 0xFF	; 255
    69c8:	8f 3f       	cpi	r24, 0xFF	; 255
    69ca:	92 07       	cpc	r25, r18
    69cc:	11 f4       	brne	.+4      	; 0x69d2 <xTaskCheckForTimeOut+0x56>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
    69ce:	1d 82       	std	Y+5, r1	; 0x05
    69d0:	3a c0       	rjmp	.+116    	; 0x6a46 <xTaskCheckForTimeOut+0xca>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    69d2:	ee 81       	ldd	r30, Y+6	; 0x06
    69d4:	ff 81       	ldd	r31, Y+7	; 0x07
    69d6:	90 81       	ld	r25, Z
    69d8:	80 91 9c 06 	lds	r24, 0x069C
    69dc:	98 17       	cp	r25, r24
    69de:	81 f0       	breq	.+32     	; 0x6a00 <xTaskCheckForTimeOut+0x84>
    69e0:	ee 81       	ldd	r30, Y+6	; 0x06
    69e2:	ff 81       	ldd	r31, Y+7	; 0x07
    69e4:	21 81       	ldd	r18, Z+1	; 0x01
    69e6:	32 81       	ldd	r19, Z+2	; 0x02
    69e8:	8b 81       	ldd	r24, Y+3	; 0x03
    69ea:	9c 81       	ldd	r25, Y+4	; 0x04
    69ec:	82 17       	cp	r24, r18
    69ee:	93 07       	cpc	r25, r19
    69f0:	38 f0       	brcs	.+14     	; 0x6a00 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    69f2:	81 e0       	ldi	r24, 0x01	; 1
    69f4:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    69f6:	e8 85       	ldd	r30, Y+8	; 0x08
    69f8:	f9 85       	ldd	r31, Y+9	; 0x09
    69fa:	11 82       	std	Z+1, r1	; 0x01
    69fc:	10 82       	st	Z, r1
    69fe:	23 c0       	rjmp	.+70     	; 0x6a46 <xTaskCheckForTimeOut+0xca>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    6a00:	e8 85       	ldd	r30, Y+8	; 0x08
    6a02:	f9 85       	ldd	r31, Y+9	; 0x09
    6a04:	20 81       	ld	r18, Z
    6a06:	31 81       	ldd	r19, Z+1	; 0x01
    6a08:	89 81       	ldd	r24, Y+1	; 0x01
    6a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    6a0c:	82 17       	cp	r24, r18
    6a0e:	93 07       	cpc	r25, r19
    6a10:	a0 f4       	brcc	.+40     	; 0x6a3a <xTaskCheckForTimeOut+0xbe>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    6a12:	e8 85       	ldd	r30, Y+8	; 0x08
    6a14:	f9 85       	ldd	r31, Y+9	; 0x09
    6a16:	20 81       	ld	r18, Z
    6a18:	31 81       	ldd	r19, Z+1	; 0x01
    6a1a:	89 81       	ldd	r24, Y+1	; 0x01
    6a1c:	9a 81       	ldd	r25, Y+2	; 0x02
    6a1e:	a9 01       	movw	r20, r18
    6a20:	48 1b       	sub	r20, r24
    6a22:	59 0b       	sbc	r21, r25
    6a24:	ca 01       	movw	r24, r20
    6a26:	e8 85       	ldd	r30, Y+8	; 0x08
    6a28:	f9 85       	ldd	r31, Y+9	; 0x09
    6a2a:	91 83       	std	Z+1, r25	; 0x01
    6a2c:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    6a2e:	8e 81       	ldd	r24, Y+6	; 0x06
    6a30:	9f 81       	ldd	r25, Y+7	; 0x07
    6a32:	0e 94 a5 34 	call	0x694a	; 0x694a <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    6a36:	1d 82       	std	Y+5, r1	; 0x05
    6a38:	06 c0       	rjmp	.+12     	; 0x6a46 <xTaskCheckForTimeOut+0xca>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    6a3a:	e8 85       	ldd	r30, Y+8	; 0x08
    6a3c:	f9 85       	ldd	r31, Y+9	; 0x09
    6a3e:	11 82       	std	Z+1, r1	; 0x01
    6a40:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    6a42:	81 e0       	ldi	r24, 0x01	; 1
    6a44:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    6a46:	0f 90       	pop	r0
    6a48:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    6a4a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6a4c:	29 96       	adiw	r28, 0x09	; 9
    6a4e:	0f b6       	in	r0, 0x3f	; 63
    6a50:	f8 94       	cli
    6a52:	de bf       	out	0x3e, r29	; 62
    6a54:	0f be       	out	0x3f, r0	; 63
    6a56:	cd bf       	out	0x3d, r28	; 61
    6a58:	cf 91       	pop	r28
    6a5a:	df 91       	pop	r29
    6a5c:	08 95       	ret

00006a5e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    6a5e:	df 93       	push	r29
    6a60:	cf 93       	push	r28
    6a62:	cd b7       	in	r28, 0x3d	; 61
    6a64:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    6a66:	81 e0       	ldi	r24, 0x01	; 1
    6a68:	80 93 9b 06 	sts	0x069B, r24
}
    6a6c:	cf 91       	pop	r28
    6a6e:	df 91       	pop	r29
    6a70:	08 95       	ret

00006a72 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    6a72:	df 93       	push	r29
    6a74:	cf 93       	push	r28
    6a76:	00 d0       	rcall	.+0      	; 0x6a78 <prvIdleTask+0x6>
    6a78:	cd b7       	in	r28, 0x3d	; 61
    6a7a:	de b7       	in	r29, 0x3e	; 62
    6a7c:	9a 83       	std	Y+2, r25	; 0x02
    6a7e:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    6a80:	0e 94 84 35 	call	0x6b08	; 0x6b08 <prvCheckTasksWaitingTermination>
    6a84:	fd cf       	rjmp	.-6      	; 0x6a80 <prvIdleTask+0xe>

00006a86 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    6a86:	df 93       	push	r29
    6a88:	cf 93       	push	r28
    6a8a:	0f 92       	push	r0
    6a8c:	cd b7       	in	r28, 0x3d	; 61
    6a8e:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6a90:	19 82       	std	Y+1, r1	; 0x01
    6a92:	13 c0       	rjmp	.+38     	; 0x6aba <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6a94:	89 81       	ldd	r24, Y+1	; 0x01
    6a96:	28 2f       	mov	r18, r24
    6a98:	30 e0       	ldi	r19, 0x00	; 0
    6a9a:	c9 01       	movw	r24, r18
    6a9c:	88 0f       	add	r24, r24
    6a9e:	99 1f       	adc	r25, r25
    6aa0:	88 0f       	add	r24, r24
    6aa2:	99 1f       	adc	r25, r25
    6aa4:	88 0f       	add	r24, r24
    6aa6:	99 1f       	adc	r25, r25
    6aa8:	82 0f       	add	r24, r18
    6aaa:	93 1f       	adc	r25, r19
    6aac:	8d 55       	subi	r24, 0x5D	; 93
    6aae:	99 4f       	sbci	r25, 0xF9	; 249
    6ab0:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6ab4:	89 81       	ldd	r24, Y+1	; 0x01
    6ab6:	8f 5f       	subi	r24, 0xFF	; 255
    6ab8:	89 83       	std	Y+1, r24	; 0x01
    6aba:	89 81       	ldd	r24, Y+1	; 0x01
    6abc:	84 30       	cpi	r24, 0x04	; 4
    6abe:	50 f3       	brcs	.-44     	; 0x6a94 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    6ac0:	87 ec       	ldi	r24, 0xC7	; 199
    6ac2:	96 e0       	ldi	r25, 0x06	; 6
    6ac4:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    6ac8:	80 ed       	ldi	r24, 0xD0	; 208
    6aca:	96 e0       	ldi	r25, 0x06	; 6
    6acc:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    6ad0:	8d ed       	ldi	r24, 0xDD	; 221
    6ad2:	96 e0       	ldi	r25, 0x06	; 6
    6ad4:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    6ad8:	86 ee       	ldi	r24, 0xE6	; 230
    6ada:	96 e0       	ldi	r25, 0x06	; 6
    6adc:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
    6ae0:	8f ee       	ldi	r24, 0xEF	; 239
    6ae2:	96 e0       	ldi	r25, 0x06	; 6
    6ae4:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    6ae8:	87 ec       	ldi	r24, 0xC7	; 199
    6aea:	96 e0       	ldi	r25, 0x06	; 6
    6aec:	90 93 da 06 	sts	0x06DA, r25
    6af0:	80 93 d9 06 	sts	0x06D9, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6af4:	80 ed       	ldi	r24, 0xD0	; 208
    6af6:	96 e0       	ldi	r25, 0x06	; 6
    6af8:	90 93 dc 06 	sts	0x06DC, r25
    6afc:	80 93 db 06 	sts	0x06DB, r24
}
    6b00:	0f 90       	pop	r0
    6b02:	cf 91       	pop	r28
    6b04:	df 91       	pop	r29
    6b06:	08 95       	ret

00006b08 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6b08:	df 93       	push	r29
    6b0a:	cf 93       	push	r28
    6b0c:	00 d0       	rcall	.+0      	; 0x6b0e <prvCheckTasksWaitingTermination+0x6>
    6b0e:	cd b7       	in	r28, 0x3d	; 61
    6b10:	de b7       	in	r29, 0x3e	; 62
    6b12:	20 c0       	rjmp	.+64     	; 0x6b54 <prvCheckTasksWaitingTermination+0x4c>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    6b14:	0f b6       	in	r0, 0x3f	; 63
    6b16:	f8 94       	cli
    6b18:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6b1a:	e0 91 eb 06 	lds	r30, 0x06EB
    6b1e:	f0 91 ec 06 	lds	r31, 0x06EC
    6b22:	86 81       	ldd	r24, Z+6	; 0x06
    6b24:	97 81       	ldd	r25, Z+7	; 0x07
    6b26:	9a 83       	std	Y+2, r25	; 0x02
    6b28:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6b2a:	89 81       	ldd	r24, Y+1	; 0x01
    6b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    6b2e:	02 96       	adiw	r24, 0x02	; 2
    6b30:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
                --uxCurrentNumberOfTasks;
    6b34:	80 91 94 06 	lds	r24, 0x0694
    6b38:	81 50       	subi	r24, 0x01	; 1
    6b3a:	80 93 94 06 	sts	0x0694, r24
                --uxDeletedTasksWaitingCleanUp;
    6b3e:	80 91 93 06 	lds	r24, 0x0693
    6b42:	81 50       	subi	r24, 0x01	; 1
    6b44:	80 93 93 06 	sts	0x0693, r24
            }
            taskEXIT_CRITICAL();
    6b48:	0f 90       	pop	r0
    6b4a:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    6b4c:	89 81       	ldd	r24, Y+1	; 0x01
    6b4e:	9a 81       	ldd	r25, Y+2	; 0x02
    6b50:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    6b54:	80 91 93 06 	lds	r24, 0x0693
    6b58:	88 23       	and	r24, r24
    6b5a:	e1 f6       	brne	.-72     	; 0x6b14 <prvCheckTasksWaitingTermination+0xc>

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    6b5c:	0f 90       	pop	r0
    6b5e:	0f 90       	pop	r0
    6b60:	cf 91       	pop	r28
    6b62:	df 91       	pop	r29
    6b64:	08 95       	ret

00006b66 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    6b66:	df 93       	push	r29
    6b68:	cf 93       	push	r28
    6b6a:	00 d0       	rcall	.+0      	; 0x6b6c <prvDeleteTCB+0x6>
    6b6c:	cd b7       	in	r28, 0x3d	; 61
    6b6e:	de b7       	in	r29, 0x3e	; 62
    6b70:	9a 83       	std	Y+2, r25	; 0x02
    6b72:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    6b74:	e9 81       	ldd	r30, Y+1	; 0x01
    6b76:	fa 81       	ldd	r31, Y+2	; 0x02
    6b78:	87 89       	ldd	r24, Z+23	; 0x17
    6b7a:	90 8d       	ldd	r25, Z+24	; 0x18
    6b7c:	0e 94 a3 13 	call	0x2746	; 0x2746 <vPortFree>
            vPortFree( pxTCB );
    6b80:	89 81       	ldd	r24, Y+1	; 0x01
    6b82:	9a 81       	ldd	r25, Y+2	; 0x02
    6b84:	0e 94 a3 13 	call	0x2746	; 0x2746 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    6b88:	0f 90       	pop	r0
    6b8a:	0f 90       	pop	r0
    6b8c:	cf 91       	pop	r28
    6b8e:	df 91       	pop	r29
    6b90:	08 95       	ret

00006b92 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    6b92:	df 93       	push	r29
    6b94:	cf 93       	push	r28
    6b96:	cd b7       	in	r28, 0x3d	; 61
    6b98:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6b9a:	e0 91 d9 06 	lds	r30, 0x06D9
    6b9e:	f0 91 da 06 	lds	r31, 0x06DA
    6ba2:	80 81       	ld	r24, Z
    6ba4:	88 23       	and	r24, r24
    6ba6:	39 f4       	brne	.+14     	; 0x6bb6 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    6ba8:	8f ef       	ldi	r24, 0xFF	; 255
    6baa:	9f ef       	ldi	r25, 0xFF	; 255
    6bac:	90 93 9f 06 	sts	0x069F, r25
    6bb0:	80 93 9e 06 	sts	0x069E, r24
    6bb4:	0d c0       	rjmp	.+26     	; 0x6bd0 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    6bb6:	e0 91 d9 06 	lds	r30, 0x06D9
    6bba:	f0 91 da 06 	lds	r31, 0x06DA
    6bbe:	05 80       	ldd	r0, Z+5	; 0x05
    6bc0:	f6 81       	ldd	r31, Z+6	; 0x06
    6bc2:	e0 2d       	mov	r30, r0
    6bc4:	80 81       	ld	r24, Z
    6bc6:	91 81       	ldd	r25, Z+1	; 0x01
    6bc8:	90 93 9f 06 	sts	0x069F, r25
    6bcc:	80 93 9e 06 	sts	0x069E, r24
    }
}
    6bd0:	cf 91       	pop	r28
    6bd2:	df 91       	pop	r29
    6bd4:	08 95       	ret

00006bd6 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    6bd6:	df 93       	push	r29
    6bd8:	cf 93       	push	r28
    6bda:	00 d0       	rcall	.+0      	; 0x6bdc <xTaskGetCurrentTaskHandle+0x6>
    6bdc:	cd b7       	in	r28, 0x3d	; 61
    6bde:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    6be0:	80 91 91 06 	lds	r24, 0x0691
    6be4:	90 91 92 06 	lds	r25, 0x0692
    6be8:	9a 83       	std	Y+2, r25	; 0x02
    6bea:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    6bec:	89 81       	ldd	r24, Y+1	; 0x01
    6bee:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6bf0:	0f 90       	pop	r0
    6bf2:	0f 90       	pop	r0
    6bf4:	cf 91       	pop	r28
    6bf6:	df 91       	pop	r29
    6bf8:	08 95       	ret

00006bfa <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    6bfa:	df 93       	push	r29
    6bfc:	cf 93       	push	r28
    6bfe:	00 d0       	rcall	.+0      	; 0x6c00 <uxTaskResetEventItemValue+0x6>
    6c00:	cd b7       	in	r28, 0x3d	; 61
    6c02:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    6c04:	e0 91 91 06 	lds	r30, 0x0691
    6c08:	f0 91 92 06 	lds	r31, 0x0692
    6c0c:	84 85       	ldd	r24, Z+12	; 0x0c
    6c0e:	95 85       	ldd	r25, Z+13	; 0x0d
    6c10:	9a 83       	std	Y+2, r25	; 0x02
    6c12:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6c14:	a0 91 91 06 	lds	r26, 0x0691
    6c18:	b0 91 92 06 	lds	r27, 0x0692
    6c1c:	e0 91 91 06 	lds	r30, 0x0691
    6c20:	f0 91 92 06 	lds	r31, 0x0692
    6c24:	86 89       	ldd	r24, Z+22	; 0x16
    6c26:	28 2f       	mov	r18, r24
    6c28:	30 e0       	ldi	r19, 0x00	; 0
    6c2a:	84 e0       	ldi	r24, 0x04	; 4
    6c2c:	90 e0       	ldi	r25, 0x00	; 0
    6c2e:	82 1b       	sub	r24, r18
    6c30:	93 0b       	sbc	r25, r19
    6c32:	1d 96       	adiw	r26, 0x0d	; 13
    6c34:	9c 93       	st	X, r25
    6c36:	8e 93       	st	-X, r24
    6c38:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    6c3a:	89 81       	ldd	r24, Y+1	; 0x01
    6c3c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6c3e:	0f 90       	pop	r0
    6c40:	0f 90       	pop	r0
    6c42:	cf 91       	pop	r28
    6c44:	df 91       	pop	r29
    6c46:	08 95       	ret

00006c48 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    6c48:	df 93       	push	r29
    6c4a:	cf 93       	push	r28
    6c4c:	cd b7       	in	r28, 0x3d	; 61
    6c4e:	de b7       	in	r29, 0x3e	; 62
    6c50:	28 97       	sbiw	r28, 0x08	; 8
    6c52:	0f b6       	in	r0, 0x3f	; 63
    6c54:	f8 94       	cli
    6c56:	de bf       	out	0x3e, r29	; 62
    6c58:	0f be       	out	0x3f, r0	; 63
    6c5a:	cd bf       	out	0x3d, r28	; 61
    6c5c:	8d 83       	std	Y+5, r24	; 0x05
    6c5e:	6e 83       	std	Y+6, r22	; 0x06
    6c60:	58 87       	std	Y+8, r21	; 0x08
    6c62:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    6c64:	0f b6       	in	r0, 0x3f	; 63
    6c66:	f8 94       	cli
    6c68:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    6c6a:	20 91 91 06 	lds	r18, 0x0691
    6c6e:	30 91 92 06 	lds	r19, 0x0692
    6c72:	8d 81       	ldd	r24, Y+5	; 0x05
    6c74:	88 2f       	mov	r24, r24
    6c76:	90 e0       	ldi	r25, 0x00	; 0
    6c78:	88 0f       	add	r24, r24
    6c7a:	99 1f       	adc	r25, r25
    6c7c:	88 0f       	add	r24, r24
    6c7e:	99 1f       	adc	r25, r25
    6c80:	82 0f       	add	r24, r18
    6c82:	93 1f       	adc	r25, r19
    6c84:	fc 01       	movw	r30, r24
    6c86:	b9 96       	adiw	r30, 0x29	; 41
    6c88:	80 81       	ld	r24, Z
    6c8a:	91 81       	ldd	r25, Z+1	; 0x01
    6c8c:	a2 81       	ldd	r26, Z+2	; 0x02
    6c8e:	b3 81       	ldd	r27, Z+3	; 0x03
    6c90:	00 97       	sbiw	r24, 0x00	; 0
    6c92:	a1 05       	cpc	r26, r1
    6c94:	b1 05       	cpc	r27, r1
    6c96:	c1 f4       	brne	.+48     	; 0x6cc8 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    6c98:	20 91 91 06 	lds	r18, 0x0691
    6c9c:	30 91 92 06 	lds	r19, 0x0692
    6ca0:	8d 81       	ldd	r24, Y+5	; 0x05
    6ca2:	88 2f       	mov	r24, r24
    6ca4:	90 e0       	ldi	r25, 0x00	; 0
    6ca6:	82 0f       	add	r24, r18
    6ca8:	93 1f       	adc	r25, r19
    6caa:	fc 01       	movw	r30, r24
    6cac:	bd 96       	adiw	r30, 0x2d	; 45
    6cae:	81 e0       	ldi	r24, 0x01	; 1
    6cb0:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    6cb2:	8f 81       	ldd	r24, Y+7	; 0x07
    6cb4:	98 85       	ldd	r25, Y+8	; 0x08
    6cb6:	00 97       	sbiw	r24, 0x00	; 0
    6cb8:	39 f0       	breq	.+14     	; 0x6cc8 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6cba:	8f 81       	ldd	r24, Y+7	; 0x07
    6cbc:	98 85       	ldd	r25, Y+8	; 0x08
    6cbe:	61 e0       	ldi	r22, 0x01	; 1
    6cc0:	0e 94 a9 3d 	call	0x7b52	; 0x7b52 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    6cc4:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6cc8:	0f 90       	pop	r0
    6cca:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    6ccc:	0f b6       	in	r0, 0x3f	; 63
    6cce:	f8 94       	cli
    6cd0:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    6cd2:	20 91 91 06 	lds	r18, 0x0691
    6cd6:	30 91 92 06 	lds	r19, 0x0692
    6cda:	8d 81       	ldd	r24, Y+5	; 0x05
    6cdc:	88 2f       	mov	r24, r24
    6cde:	90 e0       	ldi	r25, 0x00	; 0
    6ce0:	88 0f       	add	r24, r24
    6ce2:	99 1f       	adc	r25, r25
    6ce4:	88 0f       	add	r24, r24
    6ce6:	99 1f       	adc	r25, r25
    6ce8:	82 0f       	add	r24, r18
    6cea:	93 1f       	adc	r25, r19
    6cec:	fc 01       	movw	r30, r24
    6cee:	b9 96       	adiw	r30, 0x29	; 41
    6cf0:	80 81       	ld	r24, Z
    6cf2:	91 81       	ldd	r25, Z+1	; 0x01
    6cf4:	a2 81       	ldd	r26, Z+2	; 0x02
    6cf6:	b3 81       	ldd	r27, Z+3	; 0x03
    6cf8:	89 83       	std	Y+1, r24	; 0x01
    6cfa:	9a 83       	std	Y+2, r25	; 0x02
    6cfc:	ab 83       	std	Y+3, r26	; 0x03
    6cfe:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    6d00:	89 81       	ldd	r24, Y+1	; 0x01
    6d02:	9a 81       	ldd	r25, Y+2	; 0x02
    6d04:	ab 81       	ldd	r26, Y+3	; 0x03
    6d06:	bc 81       	ldd	r27, Y+4	; 0x04
    6d08:	00 97       	sbiw	r24, 0x00	; 0
    6d0a:	a1 05       	cpc	r26, r1
    6d0c:	b1 05       	cpc	r27, r1
    6d0e:	a9 f1       	breq	.+106    	; 0x6d7a <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    6d10:	8e 81       	ldd	r24, Y+6	; 0x06
    6d12:	88 23       	and	r24, r24
    6d14:	a1 f0       	breq	.+40     	; 0x6d3e <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    6d16:	20 91 91 06 	lds	r18, 0x0691
    6d1a:	30 91 92 06 	lds	r19, 0x0692
    6d1e:	8d 81       	ldd	r24, Y+5	; 0x05
    6d20:	88 2f       	mov	r24, r24
    6d22:	90 e0       	ldi	r25, 0x00	; 0
    6d24:	88 0f       	add	r24, r24
    6d26:	99 1f       	adc	r25, r25
    6d28:	88 0f       	add	r24, r24
    6d2a:	99 1f       	adc	r25, r25
    6d2c:	82 0f       	add	r24, r18
    6d2e:	93 1f       	adc	r25, r19
    6d30:	fc 01       	movw	r30, r24
    6d32:	b9 96       	adiw	r30, 0x29	; 41
    6d34:	10 82       	st	Z, r1
    6d36:	11 82       	std	Z+1, r1	; 0x01
    6d38:	12 82       	std	Z+2, r1	; 0x02
    6d3a:	13 82       	std	Z+3, r1	; 0x03
    6d3c:	1e c0       	rjmp	.+60     	; 0x6d7a <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    6d3e:	e0 91 91 06 	lds	r30, 0x0691
    6d42:	f0 91 92 06 	lds	r31, 0x0692
    6d46:	8d 81       	ldd	r24, Y+5	; 0x05
    6d48:	68 2f       	mov	r22, r24
    6d4a:	70 e0       	ldi	r23, 0x00	; 0
    6d4c:	89 81       	ldd	r24, Y+1	; 0x01
    6d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    6d50:	ab 81       	ldd	r26, Y+3	; 0x03
    6d52:	bc 81       	ldd	r27, Y+4	; 0x04
    6d54:	9c 01       	movw	r18, r24
    6d56:	ad 01       	movw	r20, r26
    6d58:	21 50       	subi	r18, 0x01	; 1
    6d5a:	30 40       	sbci	r19, 0x00	; 0
    6d5c:	40 40       	sbci	r20, 0x00	; 0
    6d5e:	50 40       	sbci	r21, 0x00	; 0
    6d60:	cb 01       	movw	r24, r22
    6d62:	88 0f       	add	r24, r24
    6d64:	99 1f       	adc	r25, r25
    6d66:	88 0f       	add	r24, r24
    6d68:	99 1f       	adc	r25, r25
    6d6a:	8e 0f       	add	r24, r30
    6d6c:	9f 1f       	adc	r25, r31
    6d6e:	fc 01       	movw	r30, r24
    6d70:	b9 96       	adiw	r30, 0x29	; 41
    6d72:	20 83       	st	Z, r18
    6d74:	31 83       	std	Z+1, r19	; 0x01
    6d76:	42 83       	std	Z+2, r20	; 0x02
    6d78:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    6d7a:	20 91 91 06 	lds	r18, 0x0691
    6d7e:	30 91 92 06 	lds	r19, 0x0692
    6d82:	8d 81       	ldd	r24, Y+5	; 0x05
    6d84:	88 2f       	mov	r24, r24
    6d86:	90 e0       	ldi	r25, 0x00	; 0
    6d88:	82 0f       	add	r24, r18
    6d8a:	93 1f       	adc	r25, r19
    6d8c:	fc 01       	movw	r30, r24
    6d8e:	bd 96       	adiw	r30, 0x2d	; 45
    6d90:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    6d92:	0f 90       	pop	r0
    6d94:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    6d96:	89 81       	ldd	r24, Y+1	; 0x01
    6d98:	9a 81       	ldd	r25, Y+2	; 0x02
    6d9a:	ab 81       	ldd	r26, Y+3	; 0x03
    6d9c:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    6d9e:	bc 01       	movw	r22, r24
    6da0:	cd 01       	movw	r24, r26
    6da2:	28 96       	adiw	r28, 0x08	; 8
    6da4:	0f b6       	in	r0, 0x3f	; 63
    6da6:	f8 94       	cli
    6da8:	de bf       	out	0x3e, r29	; 62
    6daa:	0f be       	out	0x3f, r0	; 63
    6dac:	cd bf       	out	0x3d, r28	; 61
    6dae:	cf 91       	pop	r28
    6db0:	df 91       	pop	r29
    6db2:	08 95       	ret

00006db4 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    6db4:	cf 92       	push	r12
    6db6:	df 92       	push	r13
    6db8:	ef 92       	push	r14
    6dba:	ff 92       	push	r15
    6dbc:	0f 93       	push	r16
    6dbe:	1f 93       	push	r17
    6dc0:	df 93       	push	r29
    6dc2:	cf 93       	push	r28
    6dc4:	cd b7       	in	r28, 0x3d	; 61
    6dc6:	de b7       	in	r29, 0x3e	; 62
    6dc8:	2e 97       	sbiw	r28, 0x0e	; 14
    6dca:	0f b6       	in	r0, 0x3f	; 63
    6dcc:	f8 94       	cli
    6dce:	de bf       	out	0x3e, r29	; 62
    6dd0:	0f be       	out	0x3f, r0	; 63
    6dd2:	cd bf       	out	0x3d, r28	; 61
    6dd4:	8a 83       	std	Y+2, r24	; 0x02
    6dd6:	4b 83       	std	Y+3, r20	; 0x03
    6dd8:	5c 83       	std	Y+4, r21	; 0x04
    6dda:	6d 83       	std	Y+5, r22	; 0x05
    6ddc:	7e 83       	std	Y+6, r23	; 0x06
    6dde:	0f 83       	std	Y+7, r16	; 0x07
    6de0:	18 87       	std	Y+8, r17	; 0x08
    6de2:	29 87       	std	Y+9, r18	; 0x09
    6de4:	3a 87       	std	Y+10, r19	; 0x0a
    6de6:	fc 86       	std	Y+12, r15	; 0x0c
    6de8:	eb 86       	std	Y+11, r14	; 0x0b
    6dea:	de 86       	std	Y+14, r13	; 0x0e
    6dec:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    6dee:	0f b6       	in	r0, 0x3f	; 63
    6df0:	f8 94       	cli
    6df2:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    6df4:	20 91 91 06 	lds	r18, 0x0691
    6df8:	30 91 92 06 	lds	r19, 0x0692
    6dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    6dfe:	88 2f       	mov	r24, r24
    6e00:	90 e0       	ldi	r25, 0x00	; 0
    6e02:	82 0f       	add	r24, r18
    6e04:	93 1f       	adc	r25, r19
    6e06:	fc 01       	movw	r30, r24
    6e08:	bd 96       	adiw	r30, 0x2d	; 45
    6e0a:	80 81       	ld	r24, Z
    6e0c:	82 30       	cpi	r24, 0x02	; 2
    6e0e:	09 f4       	brne	.+2      	; 0x6e12 <xTaskGenericNotifyWait+0x5e>
    6e10:	47 c0       	rjmp	.+142    	; 0x6ea0 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    6e12:	60 91 91 06 	lds	r22, 0x0691
    6e16:	70 91 92 06 	lds	r23, 0x0692
    6e1a:	8a 81       	ldd	r24, Y+2	; 0x02
    6e1c:	08 2f       	mov	r16, r24
    6e1e:	10 e0       	ldi	r17, 0x00	; 0
    6e20:	8a 81       	ldd	r24, Y+2	; 0x02
    6e22:	88 2f       	mov	r24, r24
    6e24:	90 e0       	ldi	r25, 0x00	; 0
    6e26:	88 0f       	add	r24, r24
    6e28:	99 1f       	adc	r25, r25
    6e2a:	88 0f       	add	r24, r24
    6e2c:	99 1f       	adc	r25, r25
    6e2e:	86 0f       	add	r24, r22
    6e30:	97 1f       	adc	r25, r23
    6e32:	fc 01       	movw	r30, r24
    6e34:	b9 96       	adiw	r30, 0x29	; 41
    6e36:	20 81       	ld	r18, Z
    6e38:	31 81       	ldd	r19, Z+1	; 0x01
    6e3a:	42 81       	ldd	r20, Z+2	; 0x02
    6e3c:	53 81       	ldd	r21, Z+3	; 0x03
    6e3e:	8b 81       	ldd	r24, Y+3	; 0x03
    6e40:	9c 81       	ldd	r25, Y+4	; 0x04
    6e42:	ad 81       	ldd	r26, Y+5	; 0x05
    6e44:	be 81       	ldd	r27, Y+6	; 0x06
    6e46:	80 95       	com	r24
    6e48:	90 95       	com	r25
    6e4a:	a0 95       	com	r26
    6e4c:	b0 95       	com	r27
    6e4e:	28 23       	and	r18, r24
    6e50:	39 23       	and	r19, r25
    6e52:	4a 23       	and	r20, r26
    6e54:	5b 23       	and	r21, r27
    6e56:	c8 01       	movw	r24, r16
    6e58:	88 0f       	add	r24, r24
    6e5a:	99 1f       	adc	r25, r25
    6e5c:	88 0f       	add	r24, r24
    6e5e:	99 1f       	adc	r25, r25
    6e60:	86 0f       	add	r24, r22
    6e62:	97 1f       	adc	r25, r23
    6e64:	fc 01       	movw	r30, r24
    6e66:	b9 96       	adiw	r30, 0x29	; 41
    6e68:	20 83       	st	Z, r18
    6e6a:	31 83       	std	Z+1, r19	; 0x01
    6e6c:	42 83       	std	Z+2, r20	; 0x02
    6e6e:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    6e70:	20 91 91 06 	lds	r18, 0x0691
    6e74:	30 91 92 06 	lds	r19, 0x0692
    6e78:	8a 81       	ldd	r24, Y+2	; 0x02
    6e7a:	88 2f       	mov	r24, r24
    6e7c:	90 e0       	ldi	r25, 0x00	; 0
    6e7e:	82 0f       	add	r24, r18
    6e80:	93 1f       	adc	r25, r19
    6e82:	fc 01       	movw	r30, r24
    6e84:	bd 96       	adiw	r30, 0x2d	; 45
    6e86:	81 e0       	ldi	r24, 0x01	; 1
    6e88:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    6e8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e8c:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e8e:	00 97       	sbiw	r24, 0x00	; 0
    6e90:	39 f0       	breq	.+14     	; 0x6ea0 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6e92:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e94:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e96:	61 e0       	ldi	r22, 0x01	; 1
    6e98:	0e 94 a9 3d 	call	0x7b52	; 0x7b52 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    6e9c:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6ea0:	0f 90       	pop	r0
    6ea2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    6ea4:	0f b6       	in	r0, 0x3f	; 63
    6ea6:	f8 94       	cli
    6ea8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    6eaa:	8b 85       	ldd	r24, Y+11	; 0x0b
    6eac:	9c 85       	ldd	r25, Y+12	; 0x0c
    6eae:	00 97       	sbiw	r24, 0x00	; 0
    6eb0:	c9 f0       	breq	.+50     	; 0x6ee4 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    6eb2:	20 91 91 06 	lds	r18, 0x0691
    6eb6:	30 91 92 06 	lds	r19, 0x0692
    6eba:	8a 81       	ldd	r24, Y+2	; 0x02
    6ebc:	88 2f       	mov	r24, r24
    6ebe:	90 e0       	ldi	r25, 0x00	; 0
    6ec0:	88 0f       	add	r24, r24
    6ec2:	99 1f       	adc	r25, r25
    6ec4:	88 0f       	add	r24, r24
    6ec6:	99 1f       	adc	r25, r25
    6ec8:	82 0f       	add	r24, r18
    6eca:	93 1f       	adc	r25, r19
    6ecc:	fc 01       	movw	r30, r24
    6ece:	b9 96       	adiw	r30, 0x29	; 41
    6ed0:	80 81       	ld	r24, Z
    6ed2:	91 81       	ldd	r25, Z+1	; 0x01
    6ed4:	a2 81       	ldd	r26, Z+2	; 0x02
    6ed6:	b3 81       	ldd	r27, Z+3	; 0x03
    6ed8:	eb 85       	ldd	r30, Y+11	; 0x0b
    6eda:	fc 85       	ldd	r31, Y+12	; 0x0c
    6edc:	80 83       	st	Z, r24
    6ede:	91 83       	std	Z+1, r25	; 0x01
    6ee0:	a2 83       	std	Z+2, r26	; 0x02
    6ee2:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    6ee4:	20 91 91 06 	lds	r18, 0x0691
    6ee8:	30 91 92 06 	lds	r19, 0x0692
    6eec:	8a 81       	ldd	r24, Y+2	; 0x02
    6eee:	88 2f       	mov	r24, r24
    6ef0:	90 e0       	ldi	r25, 0x00	; 0
    6ef2:	82 0f       	add	r24, r18
    6ef4:	93 1f       	adc	r25, r19
    6ef6:	fc 01       	movw	r30, r24
    6ef8:	bd 96       	adiw	r30, 0x2d	; 45
    6efa:	80 81       	ld	r24, Z
    6efc:	82 30       	cpi	r24, 0x02	; 2
    6efe:	11 f0       	breq	.+4      	; 0x6f04 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    6f00:	19 82       	std	Y+1, r1	; 0x01
    6f02:	31 c0       	rjmp	.+98     	; 0x6f66 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    6f04:	60 91 91 06 	lds	r22, 0x0691
    6f08:	70 91 92 06 	lds	r23, 0x0692
    6f0c:	8a 81       	ldd	r24, Y+2	; 0x02
    6f0e:	08 2f       	mov	r16, r24
    6f10:	10 e0       	ldi	r17, 0x00	; 0
    6f12:	8a 81       	ldd	r24, Y+2	; 0x02
    6f14:	88 2f       	mov	r24, r24
    6f16:	90 e0       	ldi	r25, 0x00	; 0
    6f18:	88 0f       	add	r24, r24
    6f1a:	99 1f       	adc	r25, r25
    6f1c:	88 0f       	add	r24, r24
    6f1e:	99 1f       	adc	r25, r25
    6f20:	86 0f       	add	r24, r22
    6f22:	97 1f       	adc	r25, r23
    6f24:	fc 01       	movw	r30, r24
    6f26:	b9 96       	adiw	r30, 0x29	; 41
    6f28:	20 81       	ld	r18, Z
    6f2a:	31 81       	ldd	r19, Z+1	; 0x01
    6f2c:	42 81       	ldd	r20, Z+2	; 0x02
    6f2e:	53 81       	ldd	r21, Z+3	; 0x03
    6f30:	8f 81       	ldd	r24, Y+7	; 0x07
    6f32:	98 85       	ldd	r25, Y+8	; 0x08
    6f34:	a9 85       	ldd	r26, Y+9	; 0x09
    6f36:	ba 85       	ldd	r27, Y+10	; 0x0a
    6f38:	80 95       	com	r24
    6f3a:	90 95       	com	r25
    6f3c:	a0 95       	com	r26
    6f3e:	b0 95       	com	r27
    6f40:	28 23       	and	r18, r24
    6f42:	39 23       	and	r19, r25
    6f44:	4a 23       	and	r20, r26
    6f46:	5b 23       	and	r21, r27
    6f48:	c8 01       	movw	r24, r16
    6f4a:	88 0f       	add	r24, r24
    6f4c:	99 1f       	adc	r25, r25
    6f4e:	88 0f       	add	r24, r24
    6f50:	99 1f       	adc	r25, r25
    6f52:	86 0f       	add	r24, r22
    6f54:	97 1f       	adc	r25, r23
    6f56:	fc 01       	movw	r30, r24
    6f58:	b9 96       	adiw	r30, 0x29	; 41
    6f5a:	20 83       	st	Z, r18
    6f5c:	31 83       	std	Z+1, r19	; 0x01
    6f5e:	42 83       	std	Z+2, r20	; 0x02
    6f60:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    6f62:	81 e0       	ldi	r24, 0x01	; 1
    6f64:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    6f66:	20 91 91 06 	lds	r18, 0x0691
    6f6a:	30 91 92 06 	lds	r19, 0x0692
    6f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    6f70:	88 2f       	mov	r24, r24
    6f72:	90 e0       	ldi	r25, 0x00	; 0
    6f74:	82 0f       	add	r24, r18
    6f76:	93 1f       	adc	r25, r19
    6f78:	fc 01       	movw	r30, r24
    6f7a:	bd 96       	adiw	r30, 0x2d	; 45
    6f7c:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    6f7e:	0f 90       	pop	r0
    6f80:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6f82:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6f84:	2e 96       	adiw	r28, 0x0e	; 14
    6f86:	0f b6       	in	r0, 0x3f	; 63
    6f88:	f8 94       	cli
    6f8a:	de bf       	out	0x3e, r29	; 62
    6f8c:	0f be       	out	0x3f, r0	; 63
    6f8e:	cd bf       	out	0x3d, r28	; 61
    6f90:	cf 91       	pop	r28
    6f92:	df 91       	pop	r29
    6f94:	1f 91       	pop	r17
    6f96:	0f 91       	pop	r16
    6f98:	ff 90       	pop	r15
    6f9a:	ef 90       	pop	r14
    6f9c:	df 90       	pop	r13
    6f9e:	cf 90       	pop	r12
    6fa0:	08 95       	ret

00006fa2 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    6fa2:	ef 92       	push	r14
    6fa4:	ff 92       	push	r15
    6fa6:	0f 93       	push	r16
    6fa8:	1f 93       	push	r17
    6faa:	df 93       	push	r29
    6fac:	cf 93       	push	r28
    6fae:	cd b7       	in	r28, 0x3d	; 61
    6fb0:	de b7       	in	r29, 0x3e	; 62
    6fb2:	64 97       	sbiw	r28, 0x14	; 20
    6fb4:	0f b6       	in	r0, 0x3f	; 63
    6fb6:	f8 94       	cli
    6fb8:	de bf       	out	0x3e, r29	; 62
    6fba:	0f be       	out	0x3f, r0	; 63
    6fbc:	cd bf       	out	0x3d, r28	; 61
    6fbe:	9a 87       	std	Y+10, r25	; 0x0a
    6fc0:	89 87       	std	Y+9, r24	; 0x09
    6fc2:	6b 87       	std	Y+11, r22	; 0x0b
    6fc4:	2c 87       	std	Y+12, r18	; 0x0c
    6fc6:	3d 87       	std	Y+13, r19	; 0x0d
    6fc8:	4e 87       	std	Y+14, r20	; 0x0e
    6fca:	5f 87       	std	Y+15, r21	; 0x0f
    6fcc:	08 8b       	std	Y+16, r16	; 0x10
    6fce:	fa 8a       	std	Y+18, r15	; 0x12
    6fd0:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    6fd2:	81 e0       	ldi	r24, 0x01	; 1
    6fd4:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    6fd6:	89 85       	ldd	r24, Y+9	; 0x09
    6fd8:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fda:	98 87       	std	Y+8, r25	; 0x08
    6fdc:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    6fde:	0f b6       	in	r0, 0x3f	; 63
    6fe0:	f8 94       	cli
    6fe2:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    6fe4:	89 89       	ldd	r24, Y+17	; 0x11
    6fe6:	9a 89       	ldd	r25, Y+18	; 0x12
    6fe8:	00 97       	sbiw	r24, 0x00	; 0
    6fea:	b9 f0       	breq	.+46     	; 0x701a <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    6fec:	8b 85       	ldd	r24, Y+11	; 0x0b
    6fee:	88 2f       	mov	r24, r24
    6ff0:	90 e0       	ldi	r25, 0x00	; 0
    6ff2:	2f 81       	ldd	r18, Y+7	; 0x07
    6ff4:	38 85       	ldd	r19, Y+8	; 0x08
    6ff6:	88 0f       	add	r24, r24
    6ff8:	99 1f       	adc	r25, r25
    6ffa:	88 0f       	add	r24, r24
    6ffc:	99 1f       	adc	r25, r25
    6ffe:	82 0f       	add	r24, r18
    7000:	93 1f       	adc	r25, r19
    7002:	fc 01       	movw	r30, r24
    7004:	b9 96       	adiw	r30, 0x29	; 41
    7006:	80 81       	ld	r24, Z
    7008:	91 81       	ldd	r25, Z+1	; 0x01
    700a:	a2 81       	ldd	r26, Z+2	; 0x02
    700c:	b3 81       	ldd	r27, Z+3	; 0x03
    700e:	e9 89       	ldd	r30, Y+17	; 0x11
    7010:	fa 89       	ldd	r31, Y+18	; 0x12
    7012:	80 83       	st	Z, r24
    7014:	91 83       	std	Z+1, r25	; 0x01
    7016:	a2 83       	std	Z+2, r26	; 0x02
    7018:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    701a:	8b 85       	ldd	r24, Y+11	; 0x0b
    701c:	28 2f       	mov	r18, r24
    701e:	30 e0       	ldi	r19, 0x00	; 0
    7020:	8f 81       	ldd	r24, Y+7	; 0x07
    7022:	98 85       	ldd	r25, Y+8	; 0x08
    7024:	82 0f       	add	r24, r18
    7026:	93 1f       	adc	r25, r19
    7028:	fc 01       	movw	r30, r24
    702a:	bd 96       	adiw	r30, 0x2d	; 45
    702c:	80 81       	ld	r24, Z
    702e:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    7030:	8b 85       	ldd	r24, Y+11	; 0x0b
    7032:	28 2f       	mov	r18, r24
    7034:	30 e0       	ldi	r19, 0x00	; 0
    7036:	8f 81       	ldd	r24, Y+7	; 0x07
    7038:	98 85       	ldd	r25, Y+8	; 0x08
    703a:	82 0f       	add	r24, r18
    703c:	93 1f       	adc	r25, r19
    703e:	fc 01       	movw	r30, r24
    7040:	bd 96       	adiw	r30, 0x2d	; 45
    7042:	82 e0       	ldi	r24, 0x02	; 2
    7044:	80 83       	st	Z, r24

            switch( eAction )
    7046:	88 89       	ldd	r24, Y+16	; 0x10
    7048:	28 2f       	mov	r18, r24
    704a:	30 e0       	ldi	r19, 0x00	; 0
    704c:	3c 8b       	std	Y+20, r19	; 0x14
    704e:	2b 8b       	std	Y+19, r18	; 0x13
    7050:	8b 89       	ldd	r24, Y+19	; 0x13
    7052:	9c 89       	ldd	r25, Y+20	; 0x14
    7054:	82 30       	cpi	r24, 0x02	; 2
    7056:	91 05       	cpc	r25, r1
    7058:	09 f4       	brne	.+2      	; 0x705c <xTaskGenericNotify+0xba>
    705a:	46 c0       	rjmp	.+140    	; 0x70e8 <xTaskGenericNotify+0x146>
    705c:	2b 89       	ldd	r18, Y+19	; 0x13
    705e:	3c 89       	ldd	r19, Y+20	; 0x14
    7060:	23 30       	cpi	r18, 0x03	; 3
    7062:	31 05       	cpc	r19, r1
    7064:	34 f4       	brge	.+12     	; 0x7072 <xTaskGenericNotify+0xd0>
    7066:	8b 89       	ldd	r24, Y+19	; 0x13
    7068:	9c 89       	ldd	r25, Y+20	; 0x14
    706a:	81 30       	cpi	r24, 0x01	; 1
    706c:	91 05       	cpc	r25, r1
    706e:	71 f0       	breq	.+28     	; 0x708c <xTaskGenericNotify+0xea>
    7070:	93 c0       	rjmp	.+294    	; 0x7198 <xTaskGenericNotify+0x1f6>
    7072:	2b 89       	ldd	r18, Y+19	; 0x13
    7074:	3c 89       	ldd	r19, Y+20	; 0x14
    7076:	23 30       	cpi	r18, 0x03	; 3
    7078:	31 05       	cpc	r19, r1
    707a:	09 f4       	brne	.+2      	; 0x707e <xTaskGenericNotify+0xdc>
    707c:	5d c0       	rjmp	.+186    	; 0x7138 <xTaskGenericNotify+0x196>
    707e:	8b 89       	ldd	r24, Y+19	; 0x13
    7080:	9c 89       	ldd	r25, Y+20	; 0x14
    7082:	84 30       	cpi	r24, 0x04	; 4
    7084:	91 05       	cpc	r25, r1
    7086:	09 f4       	brne	.+2      	; 0x708a <xTaskGenericNotify+0xe8>
    7088:	6d c0       	rjmp	.+218    	; 0x7164 <xTaskGenericNotify+0x1c2>
    708a:	86 c0       	rjmp	.+268    	; 0x7198 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    708c:	8b 85       	ldd	r24, Y+11	; 0x0b
    708e:	08 2f       	mov	r16, r24
    7090:	10 e0       	ldi	r17, 0x00	; 0
    7092:	8b 85       	ldd	r24, Y+11	; 0x0b
    7094:	88 2f       	mov	r24, r24
    7096:	90 e0       	ldi	r25, 0x00	; 0
    7098:	2f 81       	ldd	r18, Y+7	; 0x07
    709a:	38 85       	ldd	r19, Y+8	; 0x08
    709c:	88 0f       	add	r24, r24
    709e:	99 1f       	adc	r25, r25
    70a0:	88 0f       	add	r24, r24
    70a2:	99 1f       	adc	r25, r25
    70a4:	82 0f       	add	r24, r18
    70a6:	93 1f       	adc	r25, r19
    70a8:	fc 01       	movw	r30, r24
    70aa:	b9 96       	adiw	r30, 0x29	; 41
    70ac:	20 81       	ld	r18, Z
    70ae:	31 81       	ldd	r19, Z+1	; 0x01
    70b0:	42 81       	ldd	r20, Z+2	; 0x02
    70b2:	53 81       	ldd	r21, Z+3	; 0x03
    70b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    70b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    70b8:	ae 85       	ldd	r26, Y+14	; 0x0e
    70ba:	bf 85       	ldd	r27, Y+15	; 0x0f
    70bc:	ba 01       	movw	r22, r20
    70be:	a9 01       	movw	r20, r18
    70c0:	48 2b       	or	r20, r24
    70c2:	59 2b       	or	r21, r25
    70c4:	6a 2b       	or	r22, r26
    70c6:	7b 2b       	or	r23, r27
    70c8:	2f 81       	ldd	r18, Y+7	; 0x07
    70ca:	38 85       	ldd	r19, Y+8	; 0x08
    70cc:	c8 01       	movw	r24, r16
    70ce:	88 0f       	add	r24, r24
    70d0:	99 1f       	adc	r25, r25
    70d2:	88 0f       	add	r24, r24
    70d4:	99 1f       	adc	r25, r25
    70d6:	82 0f       	add	r24, r18
    70d8:	93 1f       	adc	r25, r19
    70da:	fc 01       	movw	r30, r24
    70dc:	b9 96       	adiw	r30, 0x29	; 41
    70de:	40 83       	st	Z, r20
    70e0:	51 83       	std	Z+1, r21	; 0x01
    70e2:	62 83       	std	Z+2, r22	; 0x02
    70e4:	73 83       	std	Z+3, r23	; 0x03
    70e6:	58 c0       	rjmp	.+176    	; 0x7198 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    70e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    70ea:	08 2f       	mov	r16, r24
    70ec:	10 e0       	ldi	r17, 0x00	; 0
    70ee:	2f 81       	ldd	r18, Y+7	; 0x07
    70f0:	38 85       	ldd	r19, Y+8	; 0x08
    70f2:	c8 01       	movw	r24, r16
    70f4:	88 0f       	add	r24, r24
    70f6:	99 1f       	adc	r25, r25
    70f8:	88 0f       	add	r24, r24
    70fa:	99 1f       	adc	r25, r25
    70fc:	82 0f       	add	r24, r18
    70fe:	93 1f       	adc	r25, r19
    7100:	fc 01       	movw	r30, r24
    7102:	b9 96       	adiw	r30, 0x29	; 41
    7104:	80 81       	ld	r24, Z
    7106:	91 81       	ldd	r25, Z+1	; 0x01
    7108:	a2 81       	ldd	r26, Z+2	; 0x02
    710a:	b3 81       	ldd	r27, Z+3	; 0x03
    710c:	ac 01       	movw	r20, r24
    710e:	bd 01       	movw	r22, r26
    7110:	4f 5f       	subi	r20, 0xFF	; 255
    7112:	5f 4f       	sbci	r21, 0xFF	; 255
    7114:	6f 4f       	sbci	r22, 0xFF	; 255
    7116:	7f 4f       	sbci	r23, 0xFF	; 255
    7118:	2f 81       	ldd	r18, Y+7	; 0x07
    711a:	38 85       	ldd	r19, Y+8	; 0x08
    711c:	c8 01       	movw	r24, r16
    711e:	88 0f       	add	r24, r24
    7120:	99 1f       	adc	r25, r25
    7122:	88 0f       	add	r24, r24
    7124:	99 1f       	adc	r25, r25
    7126:	82 0f       	add	r24, r18
    7128:	93 1f       	adc	r25, r19
    712a:	fc 01       	movw	r30, r24
    712c:	b9 96       	adiw	r30, 0x29	; 41
    712e:	40 83       	st	Z, r20
    7130:	51 83       	std	Z+1, r21	; 0x01
    7132:	62 83       	std	Z+2, r22	; 0x02
    7134:	73 83       	std	Z+3, r23	; 0x03
    7136:	30 c0       	rjmp	.+96     	; 0x7198 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    7138:	8b 85       	ldd	r24, Y+11	; 0x0b
    713a:	88 2f       	mov	r24, r24
    713c:	90 e0       	ldi	r25, 0x00	; 0
    713e:	2f 81       	ldd	r18, Y+7	; 0x07
    7140:	38 85       	ldd	r19, Y+8	; 0x08
    7142:	88 0f       	add	r24, r24
    7144:	99 1f       	adc	r25, r25
    7146:	88 0f       	add	r24, r24
    7148:	99 1f       	adc	r25, r25
    714a:	82 0f       	add	r24, r18
    714c:	93 1f       	adc	r25, r19
    714e:	fc 01       	movw	r30, r24
    7150:	b9 96       	adiw	r30, 0x29	; 41
    7152:	8c 85       	ldd	r24, Y+12	; 0x0c
    7154:	9d 85       	ldd	r25, Y+13	; 0x0d
    7156:	ae 85       	ldd	r26, Y+14	; 0x0e
    7158:	bf 85       	ldd	r27, Y+15	; 0x0f
    715a:	80 83       	st	Z, r24
    715c:	91 83       	std	Z+1, r25	; 0x01
    715e:	a2 83       	std	Z+2, r26	; 0x02
    7160:	b3 83       	std	Z+3, r27	; 0x03
    7162:	1a c0       	rjmp	.+52     	; 0x7198 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    7164:	8d 81       	ldd	r24, Y+5	; 0x05
    7166:	82 30       	cpi	r24, 0x02	; 2
    7168:	b1 f0       	breq	.+44     	; 0x7196 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    716a:	8b 85       	ldd	r24, Y+11	; 0x0b
    716c:	88 2f       	mov	r24, r24
    716e:	90 e0       	ldi	r25, 0x00	; 0
    7170:	2f 81       	ldd	r18, Y+7	; 0x07
    7172:	38 85       	ldd	r19, Y+8	; 0x08
    7174:	88 0f       	add	r24, r24
    7176:	99 1f       	adc	r25, r25
    7178:	88 0f       	add	r24, r24
    717a:	99 1f       	adc	r25, r25
    717c:	82 0f       	add	r24, r18
    717e:	93 1f       	adc	r25, r19
    7180:	fc 01       	movw	r30, r24
    7182:	b9 96       	adiw	r30, 0x29	; 41
    7184:	8c 85       	ldd	r24, Y+12	; 0x0c
    7186:	9d 85       	ldd	r25, Y+13	; 0x0d
    7188:	ae 85       	ldd	r26, Y+14	; 0x0e
    718a:	bf 85       	ldd	r27, Y+15	; 0x0f
    718c:	80 83       	st	Z, r24
    718e:	91 83       	std	Z+1, r25	; 0x01
    7190:	a2 83       	std	Z+2, r26	; 0x02
    7192:	b3 83       	std	Z+3, r27	; 0x03
    7194:	01 c0       	rjmp	.+2      	; 0x7198 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    7196:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    7198:	8d 81       	ldd	r24, Y+5	; 0x05
    719a:	81 30       	cpi	r24, 0x01	; 1
    719c:	09 f0       	breq	.+2      	; 0x71a0 <xTaskGenericNotify+0x1fe>
    719e:	af c0       	rjmp	.+350    	; 0x72fe <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    71a0:	ef 81       	ldd	r30, Y+7	; 0x07
    71a2:	f8 85       	ldd	r31, Y+8	; 0x08
    71a4:	82 85       	ldd	r24, Z+10	; 0x0a
    71a6:	93 85       	ldd	r25, Z+11	; 0x0b
    71a8:	9c 83       	std	Y+4, r25	; 0x04
    71aa:	8b 83       	std	Y+3, r24	; 0x03
    71ac:	ef 81       	ldd	r30, Y+7	; 0x07
    71ae:	f8 85       	ldd	r31, Y+8	; 0x08
    71b0:	a4 81       	ldd	r26, Z+4	; 0x04
    71b2:	b5 81       	ldd	r27, Z+5	; 0x05
    71b4:	ef 81       	ldd	r30, Y+7	; 0x07
    71b6:	f8 85       	ldd	r31, Y+8	; 0x08
    71b8:	86 81       	ldd	r24, Z+6	; 0x06
    71ba:	97 81       	ldd	r25, Z+7	; 0x07
    71bc:	15 96       	adiw	r26, 0x05	; 5
    71be:	9c 93       	st	X, r25
    71c0:	8e 93       	st	-X, r24
    71c2:	14 97       	sbiw	r26, 0x04	; 4
    71c4:	ef 81       	ldd	r30, Y+7	; 0x07
    71c6:	f8 85       	ldd	r31, Y+8	; 0x08
    71c8:	a6 81       	ldd	r26, Z+6	; 0x06
    71ca:	b7 81       	ldd	r27, Z+7	; 0x07
    71cc:	ef 81       	ldd	r30, Y+7	; 0x07
    71ce:	f8 85       	ldd	r31, Y+8	; 0x08
    71d0:	84 81       	ldd	r24, Z+4	; 0x04
    71d2:	95 81       	ldd	r25, Z+5	; 0x05
    71d4:	13 96       	adiw	r26, 0x03	; 3
    71d6:	9c 93       	st	X, r25
    71d8:	8e 93       	st	-X, r24
    71da:	12 97       	sbiw	r26, 0x02	; 2
    71dc:	eb 81       	ldd	r30, Y+3	; 0x03
    71de:	fc 81       	ldd	r31, Y+4	; 0x04
    71e0:	21 81       	ldd	r18, Z+1	; 0x01
    71e2:	32 81       	ldd	r19, Z+2	; 0x02
    71e4:	8f 81       	ldd	r24, Y+7	; 0x07
    71e6:	98 85       	ldd	r25, Y+8	; 0x08
    71e8:	02 96       	adiw	r24, 0x02	; 2
    71ea:	28 17       	cp	r18, r24
    71ec:	39 07       	cpc	r19, r25
    71ee:	41 f4       	brne	.+16     	; 0x7200 <xTaskGenericNotify+0x25e>
    71f0:	ef 81       	ldd	r30, Y+7	; 0x07
    71f2:	f8 85       	ldd	r31, Y+8	; 0x08
    71f4:	86 81       	ldd	r24, Z+6	; 0x06
    71f6:	97 81       	ldd	r25, Z+7	; 0x07
    71f8:	eb 81       	ldd	r30, Y+3	; 0x03
    71fa:	fc 81       	ldd	r31, Y+4	; 0x04
    71fc:	92 83       	std	Z+2, r25	; 0x02
    71fe:	81 83       	std	Z+1, r24	; 0x01
    7200:	ef 81       	ldd	r30, Y+7	; 0x07
    7202:	f8 85       	ldd	r31, Y+8	; 0x08
    7204:	13 86       	std	Z+11, r1	; 0x0b
    7206:	12 86       	std	Z+10, r1	; 0x0a
    7208:	eb 81       	ldd	r30, Y+3	; 0x03
    720a:	fc 81       	ldd	r31, Y+4	; 0x04
    720c:	80 81       	ld	r24, Z
    720e:	81 50       	subi	r24, 0x01	; 1
    7210:	eb 81       	ldd	r30, Y+3	; 0x03
    7212:	fc 81       	ldd	r31, Y+4	; 0x04
    7214:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    7216:	ef 81       	ldd	r30, Y+7	; 0x07
    7218:	f8 85       	ldd	r31, Y+8	; 0x08
    721a:	96 89       	ldd	r25, Z+22	; 0x16
    721c:	80 91 97 06 	lds	r24, 0x0697
    7220:	89 17       	cp	r24, r25
    7222:	28 f4       	brcc	.+10     	; 0x722e <xTaskGenericNotify+0x28c>
    7224:	ef 81       	ldd	r30, Y+7	; 0x07
    7226:	f8 85       	ldd	r31, Y+8	; 0x08
    7228:	86 89       	ldd	r24, Z+22	; 0x16
    722a:	80 93 97 06 	sts	0x0697, r24
    722e:	ef 81       	ldd	r30, Y+7	; 0x07
    7230:	f8 85       	ldd	r31, Y+8	; 0x08
    7232:	86 89       	ldd	r24, Z+22	; 0x16
    7234:	28 2f       	mov	r18, r24
    7236:	30 e0       	ldi	r19, 0x00	; 0
    7238:	c9 01       	movw	r24, r18
    723a:	88 0f       	add	r24, r24
    723c:	99 1f       	adc	r25, r25
    723e:	88 0f       	add	r24, r24
    7240:	99 1f       	adc	r25, r25
    7242:	88 0f       	add	r24, r24
    7244:	99 1f       	adc	r25, r25
    7246:	82 0f       	add	r24, r18
    7248:	93 1f       	adc	r25, r19
    724a:	fc 01       	movw	r30, r24
    724c:	ed 55       	subi	r30, 0x5D	; 93
    724e:	f9 4f       	sbci	r31, 0xF9	; 249
    7250:	81 81       	ldd	r24, Z+1	; 0x01
    7252:	92 81       	ldd	r25, Z+2	; 0x02
    7254:	9a 83       	std	Y+2, r25	; 0x02
    7256:	89 83       	std	Y+1, r24	; 0x01
    7258:	ef 81       	ldd	r30, Y+7	; 0x07
    725a:	f8 85       	ldd	r31, Y+8	; 0x08
    725c:	89 81       	ldd	r24, Y+1	; 0x01
    725e:	9a 81       	ldd	r25, Y+2	; 0x02
    7260:	95 83       	std	Z+5, r25	; 0x05
    7262:	84 83       	std	Z+4, r24	; 0x04
    7264:	e9 81       	ldd	r30, Y+1	; 0x01
    7266:	fa 81       	ldd	r31, Y+2	; 0x02
    7268:	84 81       	ldd	r24, Z+4	; 0x04
    726a:	95 81       	ldd	r25, Z+5	; 0x05
    726c:	ef 81       	ldd	r30, Y+7	; 0x07
    726e:	f8 85       	ldd	r31, Y+8	; 0x08
    7270:	97 83       	std	Z+7, r25	; 0x07
    7272:	86 83       	std	Z+6, r24	; 0x06
    7274:	e9 81       	ldd	r30, Y+1	; 0x01
    7276:	fa 81       	ldd	r31, Y+2	; 0x02
    7278:	04 80       	ldd	r0, Z+4	; 0x04
    727a:	f5 81       	ldd	r31, Z+5	; 0x05
    727c:	e0 2d       	mov	r30, r0
    727e:	8f 81       	ldd	r24, Y+7	; 0x07
    7280:	98 85       	ldd	r25, Y+8	; 0x08
    7282:	02 96       	adiw	r24, 0x02	; 2
    7284:	93 83       	std	Z+3, r25	; 0x03
    7286:	82 83       	std	Z+2, r24	; 0x02
    7288:	8f 81       	ldd	r24, Y+7	; 0x07
    728a:	98 85       	ldd	r25, Y+8	; 0x08
    728c:	02 96       	adiw	r24, 0x02	; 2
    728e:	e9 81       	ldd	r30, Y+1	; 0x01
    7290:	fa 81       	ldd	r31, Y+2	; 0x02
    7292:	95 83       	std	Z+5, r25	; 0x05
    7294:	84 83       	std	Z+4, r24	; 0x04
    7296:	ef 81       	ldd	r30, Y+7	; 0x07
    7298:	f8 85       	ldd	r31, Y+8	; 0x08
    729a:	86 89       	ldd	r24, Z+22	; 0x16
    729c:	28 2f       	mov	r18, r24
    729e:	30 e0       	ldi	r19, 0x00	; 0
    72a0:	c9 01       	movw	r24, r18
    72a2:	88 0f       	add	r24, r24
    72a4:	99 1f       	adc	r25, r25
    72a6:	88 0f       	add	r24, r24
    72a8:	99 1f       	adc	r25, r25
    72aa:	88 0f       	add	r24, r24
    72ac:	99 1f       	adc	r25, r25
    72ae:	82 0f       	add	r24, r18
    72b0:	93 1f       	adc	r25, r19
    72b2:	8d 55       	subi	r24, 0x5D	; 93
    72b4:	99 4f       	sbci	r25, 0xF9	; 249
    72b6:	ef 81       	ldd	r30, Y+7	; 0x07
    72b8:	f8 85       	ldd	r31, Y+8	; 0x08
    72ba:	93 87       	std	Z+11, r25	; 0x0b
    72bc:	82 87       	std	Z+10, r24	; 0x0a
    72be:	ef 81       	ldd	r30, Y+7	; 0x07
    72c0:	f8 85       	ldd	r31, Y+8	; 0x08
    72c2:	86 89       	ldd	r24, Z+22	; 0x16
    72c4:	28 2f       	mov	r18, r24
    72c6:	30 e0       	ldi	r19, 0x00	; 0
    72c8:	c9 01       	movw	r24, r18
    72ca:	88 0f       	add	r24, r24
    72cc:	99 1f       	adc	r25, r25
    72ce:	88 0f       	add	r24, r24
    72d0:	99 1f       	adc	r25, r25
    72d2:	88 0f       	add	r24, r24
    72d4:	99 1f       	adc	r25, r25
    72d6:	82 0f       	add	r24, r18
    72d8:	93 1f       	adc	r25, r19
    72da:	fc 01       	movw	r30, r24
    72dc:	ed 55       	subi	r30, 0x5D	; 93
    72de:	f9 4f       	sbci	r31, 0xF9	; 249
    72e0:	80 81       	ld	r24, Z
    72e2:	8f 5f       	subi	r24, 0xFF	; 255
    72e4:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    72e6:	ef 81       	ldd	r30, Y+7	; 0x07
    72e8:	f8 85       	ldd	r31, Y+8	; 0x08
    72ea:	96 89       	ldd	r25, Z+22	; 0x16
    72ec:	e0 91 91 06 	lds	r30, 0x0691
    72f0:	f0 91 92 06 	lds	r31, 0x0692
    72f4:	86 89       	ldd	r24, Z+22	; 0x16
    72f6:	89 17       	cp	r24, r25
    72f8:	10 f4       	brcc	.+4      	; 0x72fe <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    72fa:	0e 94 51 18 	call	0x30a2	; 0x30a2 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    72fe:	0f 90       	pop	r0
    7300:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    7302:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    7304:	64 96       	adiw	r28, 0x14	; 20
    7306:	0f b6       	in	r0, 0x3f	; 63
    7308:	f8 94       	cli
    730a:	de bf       	out	0x3e, r29	; 62
    730c:	0f be       	out	0x3f, r0	; 63
    730e:	cd bf       	out	0x3d, r28	; 61
    7310:	cf 91       	pop	r28
    7312:	df 91       	pop	r29
    7314:	1f 91       	pop	r17
    7316:	0f 91       	pop	r16
    7318:	ff 90       	pop	r15
    731a:	ef 90       	pop	r14
    731c:	08 95       	ret

0000731e <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    731e:	cf 92       	push	r12
    7320:	df 92       	push	r13
    7322:	ef 92       	push	r14
    7324:	ff 92       	push	r15
    7326:	0f 93       	push	r16
    7328:	1f 93       	push	r17
    732a:	df 93       	push	r29
    732c:	cf 93       	push	r28
    732e:	cd b7       	in	r28, 0x3d	; 61
    7330:	de b7       	in	r29, 0x3e	; 62
    7332:	69 97       	sbiw	r28, 0x19	; 25
    7334:	0f b6       	in	r0, 0x3f	; 63
    7336:	f8 94       	cli
    7338:	de bf       	out	0x3e, r29	; 62
    733a:	0f be       	out	0x3f, r0	; 63
    733c:	cd bf       	out	0x3d, r28	; 61
    733e:	9d 87       	std	Y+13, r25	; 0x0d
    7340:	8c 87       	std	Y+12, r24	; 0x0c
    7342:	6e 87       	std	Y+14, r22	; 0x0e
    7344:	2f 87       	std	Y+15, r18	; 0x0f
    7346:	38 8b       	std	Y+16, r19	; 0x10
    7348:	49 8b       	std	Y+17, r20	; 0x11
    734a:	5a 8b       	std	Y+18, r21	; 0x12
    734c:	0b 8b       	std	Y+19, r16	; 0x13
    734e:	fd 8a       	std	Y+21, r15	; 0x15
    7350:	ec 8a       	std	Y+20, r14	; 0x14
    7352:	df 8a       	std	Y+23, r13	; 0x17
    7354:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    7356:	81 e0       	ldi	r24, 0x01	; 1
    7358:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    735a:	8c 85       	ldd	r24, Y+12	; 0x0c
    735c:	9d 85       	ldd	r25, Y+13	; 0x0d
    735e:	9b 87       	std	Y+11, r25	; 0x0b
    7360:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7362:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    7364:	8c 89       	ldd	r24, Y+20	; 0x14
    7366:	9d 89       	ldd	r25, Y+21	; 0x15
    7368:	00 97       	sbiw	r24, 0x00	; 0
    736a:	b9 f0       	breq	.+46     	; 0x739a <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    736c:	8e 85       	ldd	r24, Y+14	; 0x0e
    736e:	88 2f       	mov	r24, r24
    7370:	90 e0       	ldi	r25, 0x00	; 0
    7372:	2a 85       	ldd	r18, Y+10	; 0x0a
    7374:	3b 85       	ldd	r19, Y+11	; 0x0b
    7376:	88 0f       	add	r24, r24
    7378:	99 1f       	adc	r25, r25
    737a:	88 0f       	add	r24, r24
    737c:	99 1f       	adc	r25, r25
    737e:	82 0f       	add	r24, r18
    7380:	93 1f       	adc	r25, r19
    7382:	fc 01       	movw	r30, r24
    7384:	b9 96       	adiw	r30, 0x29	; 41
    7386:	80 81       	ld	r24, Z
    7388:	91 81       	ldd	r25, Z+1	; 0x01
    738a:	a2 81       	ldd	r26, Z+2	; 0x02
    738c:	b3 81       	ldd	r27, Z+3	; 0x03
    738e:	ec 89       	ldd	r30, Y+20	; 0x14
    7390:	fd 89       	ldd	r31, Y+21	; 0x15
    7392:	80 83       	st	Z, r24
    7394:	91 83       	std	Z+1, r25	; 0x01
    7396:	a2 83       	std	Z+2, r26	; 0x02
    7398:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    739a:	8e 85       	ldd	r24, Y+14	; 0x0e
    739c:	28 2f       	mov	r18, r24
    739e:	30 e0       	ldi	r19, 0x00	; 0
    73a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    73a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    73a4:	82 0f       	add	r24, r18
    73a6:	93 1f       	adc	r25, r19
    73a8:	fc 01       	movw	r30, r24
    73aa:	bd 96       	adiw	r30, 0x2d	; 45
    73ac:	80 81       	ld	r24, Z
    73ae:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    73b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    73b2:	28 2f       	mov	r18, r24
    73b4:	30 e0       	ldi	r19, 0x00	; 0
    73b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    73b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    73ba:	82 0f       	add	r24, r18
    73bc:	93 1f       	adc	r25, r19
    73be:	fc 01       	movw	r30, r24
    73c0:	bd 96       	adiw	r30, 0x2d	; 45
    73c2:	82 e0       	ldi	r24, 0x02	; 2
    73c4:	80 83       	st	Z, r24

            switch( eAction )
    73c6:	8b 89       	ldd	r24, Y+19	; 0x13
    73c8:	28 2f       	mov	r18, r24
    73ca:	30 e0       	ldi	r19, 0x00	; 0
    73cc:	39 8f       	std	Y+25, r19	; 0x19
    73ce:	28 8f       	std	Y+24, r18	; 0x18
    73d0:	88 8d       	ldd	r24, Y+24	; 0x18
    73d2:	99 8d       	ldd	r25, Y+25	; 0x19
    73d4:	82 30       	cpi	r24, 0x02	; 2
    73d6:	91 05       	cpc	r25, r1
    73d8:	09 f4       	brne	.+2      	; 0x73dc <xTaskGenericNotifyFromISR+0xbe>
    73da:	46 c0       	rjmp	.+140    	; 0x7468 <xTaskGenericNotifyFromISR+0x14a>
    73dc:	28 8d       	ldd	r18, Y+24	; 0x18
    73de:	39 8d       	ldd	r19, Y+25	; 0x19
    73e0:	23 30       	cpi	r18, 0x03	; 3
    73e2:	31 05       	cpc	r19, r1
    73e4:	34 f4       	brge	.+12     	; 0x73f2 <xTaskGenericNotifyFromISR+0xd4>
    73e6:	88 8d       	ldd	r24, Y+24	; 0x18
    73e8:	99 8d       	ldd	r25, Y+25	; 0x19
    73ea:	81 30       	cpi	r24, 0x01	; 1
    73ec:	91 05       	cpc	r25, r1
    73ee:	71 f0       	breq	.+28     	; 0x740c <xTaskGenericNotifyFromISR+0xee>
    73f0:	93 c0       	rjmp	.+294    	; 0x7518 <xTaskGenericNotifyFromISR+0x1fa>
    73f2:	28 8d       	ldd	r18, Y+24	; 0x18
    73f4:	39 8d       	ldd	r19, Y+25	; 0x19
    73f6:	23 30       	cpi	r18, 0x03	; 3
    73f8:	31 05       	cpc	r19, r1
    73fa:	09 f4       	brne	.+2      	; 0x73fe <xTaskGenericNotifyFromISR+0xe0>
    73fc:	5d c0       	rjmp	.+186    	; 0x74b8 <xTaskGenericNotifyFromISR+0x19a>
    73fe:	88 8d       	ldd	r24, Y+24	; 0x18
    7400:	99 8d       	ldd	r25, Y+25	; 0x19
    7402:	84 30       	cpi	r24, 0x04	; 4
    7404:	91 05       	cpc	r25, r1
    7406:	09 f4       	brne	.+2      	; 0x740a <xTaskGenericNotifyFromISR+0xec>
    7408:	6d c0       	rjmp	.+218    	; 0x74e4 <xTaskGenericNotifyFromISR+0x1c6>
    740a:	86 c0       	rjmp	.+268    	; 0x7518 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    740c:	8e 85       	ldd	r24, Y+14	; 0x0e
    740e:	08 2f       	mov	r16, r24
    7410:	10 e0       	ldi	r17, 0x00	; 0
    7412:	8e 85       	ldd	r24, Y+14	; 0x0e
    7414:	88 2f       	mov	r24, r24
    7416:	90 e0       	ldi	r25, 0x00	; 0
    7418:	2a 85       	ldd	r18, Y+10	; 0x0a
    741a:	3b 85       	ldd	r19, Y+11	; 0x0b
    741c:	88 0f       	add	r24, r24
    741e:	99 1f       	adc	r25, r25
    7420:	88 0f       	add	r24, r24
    7422:	99 1f       	adc	r25, r25
    7424:	82 0f       	add	r24, r18
    7426:	93 1f       	adc	r25, r19
    7428:	fc 01       	movw	r30, r24
    742a:	b9 96       	adiw	r30, 0x29	; 41
    742c:	20 81       	ld	r18, Z
    742e:	31 81       	ldd	r19, Z+1	; 0x01
    7430:	42 81       	ldd	r20, Z+2	; 0x02
    7432:	53 81       	ldd	r21, Z+3	; 0x03
    7434:	8f 85       	ldd	r24, Y+15	; 0x0f
    7436:	98 89       	ldd	r25, Y+16	; 0x10
    7438:	a9 89       	ldd	r26, Y+17	; 0x11
    743a:	ba 89       	ldd	r27, Y+18	; 0x12
    743c:	ba 01       	movw	r22, r20
    743e:	a9 01       	movw	r20, r18
    7440:	48 2b       	or	r20, r24
    7442:	59 2b       	or	r21, r25
    7444:	6a 2b       	or	r22, r26
    7446:	7b 2b       	or	r23, r27
    7448:	2a 85       	ldd	r18, Y+10	; 0x0a
    744a:	3b 85       	ldd	r19, Y+11	; 0x0b
    744c:	c8 01       	movw	r24, r16
    744e:	88 0f       	add	r24, r24
    7450:	99 1f       	adc	r25, r25
    7452:	88 0f       	add	r24, r24
    7454:	99 1f       	adc	r25, r25
    7456:	82 0f       	add	r24, r18
    7458:	93 1f       	adc	r25, r19
    745a:	fc 01       	movw	r30, r24
    745c:	b9 96       	adiw	r30, 0x29	; 41
    745e:	40 83       	st	Z, r20
    7460:	51 83       	std	Z+1, r21	; 0x01
    7462:	62 83       	std	Z+2, r22	; 0x02
    7464:	73 83       	std	Z+3, r23	; 0x03
    7466:	58 c0       	rjmp	.+176    	; 0x7518 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    7468:	8e 85       	ldd	r24, Y+14	; 0x0e
    746a:	08 2f       	mov	r16, r24
    746c:	10 e0       	ldi	r17, 0x00	; 0
    746e:	2a 85       	ldd	r18, Y+10	; 0x0a
    7470:	3b 85       	ldd	r19, Y+11	; 0x0b
    7472:	c8 01       	movw	r24, r16
    7474:	88 0f       	add	r24, r24
    7476:	99 1f       	adc	r25, r25
    7478:	88 0f       	add	r24, r24
    747a:	99 1f       	adc	r25, r25
    747c:	82 0f       	add	r24, r18
    747e:	93 1f       	adc	r25, r19
    7480:	fc 01       	movw	r30, r24
    7482:	b9 96       	adiw	r30, 0x29	; 41
    7484:	80 81       	ld	r24, Z
    7486:	91 81       	ldd	r25, Z+1	; 0x01
    7488:	a2 81       	ldd	r26, Z+2	; 0x02
    748a:	b3 81       	ldd	r27, Z+3	; 0x03
    748c:	ac 01       	movw	r20, r24
    748e:	bd 01       	movw	r22, r26
    7490:	4f 5f       	subi	r20, 0xFF	; 255
    7492:	5f 4f       	sbci	r21, 0xFF	; 255
    7494:	6f 4f       	sbci	r22, 0xFF	; 255
    7496:	7f 4f       	sbci	r23, 0xFF	; 255
    7498:	2a 85       	ldd	r18, Y+10	; 0x0a
    749a:	3b 85       	ldd	r19, Y+11	; 0x0b
    749c:	c8 01       	movw	r24, r16
    749e:	88 0f       	add	r24, r24
    74a0:	99 1f       	adc	r25, r25
    74a2:	88 0f       	add	r24, r24
    74a4:	99 1f       	adc	r25, r25
    74a6:	82 0f       	add	r24, r18
    74a8:	93 1f       	adc	r25, r19
    74aa:	fc 01       	movw	r30, r24
    74ac:	b9 96       	adiw	r30, 0x29	; 41
    74ae:	40 83       	st	Z, r20
    74b0:	51 83       	std	Z+1, r21	; 0x01
    74b2:	62 83       	std	Z+2, r22	; 0x02
    74b4:	73 83       	std	Z+3, r23	; 0x03
    74b6:	30 c0       	rjmp	.+96     	; 0x7518 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    74b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    74ba:	88 2f       	mov	r24, r24
    74bc:	90 e0       	ldi	r25, 0x00	; 0
    74be:	2a 85       	ldd	r18, Y+10	; 0x0a
    74c0:	3b 85       	ldd	r19, Y+11	; 0x0b
    74c2:	88 0f       	add	r24, r24
    74c4:	99 1f       	adc	r25, r25
    74c6:	88 0f       	add	r24, r24
    74c8:	99 1f       	adc	r25, r25
    74ca:	82 0f       	add	r24, r18
    74cc:	93 1f       	adc	r25, r19
    74ce:	fc 01       	movw	r30, r24
    74d0:	b9 96       	adiw	r30, 0x29	; 41
    74d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    74d4:	98 89       	ldd	r25, Y+16	; 0x10
    74d6:	a9 89       	ldd	r26, Y+17	; 0x11
    74d8:	ba 89       	ldd	r27, Y+18	; 0x12
    74da:	80 83       	st	Z, r24
    74dc:	91 83       	std	Z+1, r25	; 0x01
    74de:	a2 83       	std	Z+2, r26	; 0x02
    74e0:	b3 83       	std	Z+3, r27	; 0x03
    74e2:	1a c0       	rjmp	.+52     	; 0x7518 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    74e4:	89 85       	ldd	r24, Y+9	; 0x09
    74e6:	82 30       	cpi	r24, 0x02	; 2
    74e8:	b1 f0       	breq	.+44     	; 0x7516 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    74ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    74ec:	88 2f       	mov	r24, r24
    74ee:	90 e0       	ldi	r25, 0x00	; 0
    74f0:	2a 85       	ldd	r18, Y+10	; 0x0a
    74f2:	3b 85       	ldd	r19, Y+11	; 0x0b
    74f4:	88 0f       	add	r24, r24
    74f6:	99 1f       	adc	r25, r25
    74f8:	88 0f       	add	r24, r24
    74fa:	99 1f       	adc	r25, r25
    74fc:	82 0f       	add	r24, r18
    74fe:	93 1f       	adc	r25, r19
    7500:	fc 01       	movw	r30, r24
    7502:	b9 96       	adiw	r30, 0x29	; 41
    7504:	8f 85       	ldd	r24, Y+15	; 0x0f
    7506:	98 89       	ldd	r25, Y+16	; 0x10
    7508:	a9 89       	ldd	r26, Y+17	; 0x11
    750a:	ba 89       	ldd	r27, Y+18	; 0x12
    750c:	80 83       	st	Z, r24
    750e:	91 83       	std	Z+1, r25	; 0x01
    7510:	a2 83       	std	Z+2, r26	; 0x02
    7512:	b3 83       	std	Z+3, r27	; 0x03
    7514:	01 c0       	rjmp	.+2      	; 0x7518 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    7516:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    7518:	89 85       	ldd	r24, Y+9	; 0x09
    751a:	81 30       	cpi	r24, 0x01	; 1
    751c:	09 f0       	breq	.+2      	; 0x7520 <xTaskGenericNotifyFromISR+0x202>
    751e:	ee c0       	rjmp	.+476    	; 0x76fc <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7520:	80 91 a2 06 	lds	r24, 0x06A2
    7524:	88 23       	and	r24, r24
    7526:	09 f0       	breq	.+2      	; 0x752a <xTaskGenericNotifyFromISR+0x20c>
    7528:	a4 c0       	rjmp	.+328    	; 0x7672 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    752a:	ea 85       	ldd	r30, Y+10	; 0x0a
    752c:	fb 85       	ldd	r31, Y+11	; 0x0b
    752e:	82 85       	ldd	r24, Z+10	; 0x0a
    7530:	93 85       	ldd	r25, Z+11	; 0x0b
    7532:	9e 83       	std	Y+6, r25	; 0x06
    7534:	8d 83       	std	Y+5, r24	; 0x05
    7536:	ea 85       	ldd	r30, Y+10	; 0x0a
    7538:	fb 85       	ldd	r31, Y+11	; 0x0b
    753a:	a4 81       	ldd	r26, Z+4	; 0x04
    753c:	b5 81       	ldd	r27, Z+5	; 0x05
    753e:	ea 85       	ldd	r30, Y+10	; 0x0a
    7540:	fb 85       	ldd	r31, Y+11	; 0x0b
    7542:	86 81       	ldd	r24, Z+6	; 0x06
    7544:	97 81       	ldd	r25, Z+7	; 0x07
    7546:	15 96       	adiw	r26, 0x05	; 5
    7548:	9c 93       	st	X, r25
    754a:	8e 93       	st	-X, r24
    754c:	14 97       	sbiw	r26, 0x04	; 4
    754e:	ea 85       	ldd	r30, Y+10	; 0x0a
    7550:	fb 85       	ldd	r31, Y+11	; 0x0b
    7552:	a6 81       	ldd	r26, Z+6	; 0x06
    7554:	b7 81       	ldd	r27, Z+7	; 0x07
    7556:	ea 85       	ldd	r30, Y+10	; 0x0a
    7558:	fb 85       	ldd	r31, Y+11	; 0x0b
    755a:	84 81       	ldd	r24, Z+4	; 0x04
    755c:	95 81       	ldd	r25, Z+5	; 0x05
    755e:	13 96       	adiw	r26, 0x03	; 3
    7560:	9c 93       	st	X, r25
    7562:	8e 93       	st	-X, r24
    7564:	12 97       	sbiw	r26, 0x02	; 2
    7566:	ed 81       	ldd	r30, Y+5	; 0x05
    7568:	fe 81       	ldd	r31, Y+6	; 0x06
    756a:	21 81       	ldd	r18, Z+1	; 0x01
    756c:	32 81       	ldd	r19, Z+2	; 0x02
    756e:	8a 85       	ldd	r24, Y+10	; 0x0a
    7570:	9b 85       	ldd	r25, Y+11	; 0x0b
    7572:	02 96       	adiw	r24, 0x02	; 2
    7574:	28 17       	cp	r18, r24
    7576:	39 07       	cpc	r19, r25
    7578:	41 f4       	brne	.+16     	; 0x758a <xTaskGenericNotifyFromISR+0x26c>
    757a:	ea 85       	ldd	r30, Y+10	; 0x0a
    757c:	fb 85       	ldd	r31, Y+11	; 0x0b
    757e:	86 81       	ldd	r24, Z+6	; 0x06
    7580:	97 81       	ldd	r25, Z+7	; 0x07
    7582:	ed 81       	ldd	r30, Y+5	; 0x05
    7584:	fe 81       	ldd	r31, Y+6	; 0x06
    7586:	92 83       	std	Z+2, r25	; 0x02
    7588:	81 83       	std	Z+1, r24	; 0x01
    758a:	ea 85       	ldd	r30, Y+10	; 0x0a
    758c:	fb 85       	ldd	r31, Y+11	; 0x0b
    758e:	13 86       	std	Z+11, r1	; 0x0b
    7590:	12 86       	std	Z+10, r1	; 0x0a
    7592:	ed 81       	ldd	r30, Y+5	; 0x05
    7594:	fe 81       	ldd	r31, Y+6	; 0x06
    7596:	80 81       	ld	r24, Z
    7598:	81 50       	subi	r24, 0x01	; 1
    759a:	ed 81       	ldd	r30, Y+5	; 0x05
    759c:	fe 81       	ldd	r31, Y+6	; 0x06
    759e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    75a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    75a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    75a4:	96 89       	ldd	r25, Z+22	; 0x16
    75a6:	80 91 97 06 	lds	r24, 0x0697
    75aa:	89 17       	cp	r24, r25
    75ac:	28 f4       	brcc	.+10     	; 0x75b8 <xTaskGenericNotifyFromISR+0x29a>
    75ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    75b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    75b2:	86 89       	ldd	r24, Z+22	; 0x16
    75b4:	80 93 97 06 	sts	0x0697, r24
    75b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    75ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    75bc:	86 89       	ldd	r24, Z+22	; 0x16
    75be:	28 2f       	mov	r18, r24
    75c0:	30 e0       	ldi	r19, 0x00	; 0
    75c2:	c9 01       	movw	r24, r18
    75c4:	88 0f       	add	r24, r24
    75c6:	99 1f       	adc	r25, r25
    75c8:	88 0f       	add	r24, r24
    75ca:	99 1f       	adc	r25, r25
    75cc:	88 0f       	add	r24, r24
    75ce:	99 1f       	adc	r25, r25
    75d0:	82 0f       	add	r24, r18
    75d2:	93 1f       	adc	r25, r19
    75d4:	fc 01       	movw	r30, r24
    75d6:	ed 55       	subi	r30, 0x5D	; 93
    75d8:	f9 4f       	sbci	r31, 0xF9	; 249
    75da:	81 81       	ldd	r24, Z+1	; 0x01
    75dc:	92 81       	ldd	r25, Z+2	; 0x02
    75de:	9c 83       	std	Y+4, r25	; 0x04
    75e0:	8b 83       	std	Y+3, r24	; 0x03
    75e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    75e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    75e6:	8b 81       	ldd	r24, Y+3	; 0x03
    75e8:	9c 81       	ldd	r25, Y+4	; 0x04
    75ea:	95 83       	std	Z+5, r25	; 0x05
    75ec:	84 83       	std	Z+4, r24	; 0x04
    75ee:	eb 81       	ldd	r30, Y+3	; 0x03
    75f0:	fc 81       	ldd	r31, Y+4	; 0x04
    75f2:	84 81       	ldd	r24, Z+4	; 0x04
    75f4:	95 81       	ldd	r25, Z+5	; 0x05
    75f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    75f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    75fa:	97 83       	std	Z+7, r25	; 0x07
    75fc:	86 83       	std	Z+6, r24	; 0x06
    75fe:	eb 81       	ldd	r30, Y+3	; 0x03
    7600:	fc 81       	ldd	r31, Y+4	; 0x04
    7602:	04 80       	ldd	r0, Z+4	; 0x04
    7604:	f5 81       	ldd	r31, Z+5	; 0x05
    7606:	e0 2d       	mov	r30, r0
    7608:	8a 85       	ldd	r24, Y+10	; 0x0a
    760a:	9b 85       	ldd	r25, Y+11	; 0x0b
    760c:	02 96       	adiw	r24, 0x02	; 2
    760e:	93 83       	std	Z+3, r25	; 0x03
    7610:	82 83       	std	Z+2, r24	; 0x02
    7612:	8a 85       	ldd	r24, Y+10	; 0x0a
    7614:	9b 85       	ldd	r25, Y+11	; 0x0b
    7616:	02 96       	adiw	r24, 0x02	; 2
    7618:	eb 81       	ldd	r30, Y+3	; 0x03
    761a:	fc 81       	ldd	r31, Y+4	; 0x04
    761c:	95 83       	std	Z+5, r25	; 0x05
    761e:	84 83       	std	Z+4, r24	; 0x04
    7620:	ea 85       	ldd	r30, Y+10	; 0x0a
    7622:	fb 85       	ldd	r31, Y+11	; 0x0b
    7624:	86 89       	ldd	r24, Z+22	; 0x16
    7626:	28 2f       	mov	r18, r24
    7628:	30 e0       	ldi	r19, 0x00	; 0
    762a:	c9 01       	movw	r24, r18
    762c:	88 0f       	add	r24, r24
    762e:	99 1f       	adc	r25, r25
    7630:	88 0f       	add	r24, r24
    7632:	99 1f       	adc	r25, r25
    7634:	88 0f       	add	r24, r24
    7636:	99 1f       	adc	r25, r25
    7638:	82 0f       	add	r24, r18
    763a:	93 1f       	adc	r25, r19
    763c:	8d 55       	subi	r24, 0x5D	; 93
    763e:	99 4f       	sbci	r25, 0xF9	; 249
    7640:	ea 85       	ldd	r30, Y+10	; 0x0a
    7642:	fb 85       	ldd	r31, Y+11	; 0x0b
    7644:	93 87       	std	Z+11, r25	; 0x0b
    7646:	82 87       	std	Z+10, r24	; 0x0a
    7648:	ea 85       	ldd	r30, Y+10	; 0x0a
    764a:	fb 85       	ldd	r31, Y+11	; 0x0b
    764c:	86 89       	ldd	r24, Z+22	; 0x16
    764e:	28 2f       	mov	r18, r24
    7650:	30 e0       	ldi	r19, 0x00	; 0
    7652:	c9 01       	movw	r24, r18
    7654:	88 0f       	add	r24, r24
    7656:	99 1f       	adc	r25, r25
    7658:	88 0f       	add	r24, r24
    765a:	99 1f       	adc	r25, r25
    765c:	88 0f       	add	r24, r24
    765e:	99 1f       	adc	r25, r25
    7660:	82 0f       	add	r24, r18
    7662:	93 1f       	adc	r25, r19
    7664:	fc 01       	movw	r30, r24
    7666:	ed 55       	subi	r30, 0x5D	; 93
    7668:	f9 4f       	sbci	r31, 0xF9	; 249
    766a:	80 81       	ld	r24, Z
    766c:	8f 5f       	subi	r24, 0xFF	; 255
    766e:	80 83       	st	Z, r24
    7670:	30 c0       	rjmp	.+96     	; 0x76d2 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    7672:	80 91 de 06 	lds	r24, 0x06DE
    7676:	90 91 df 06 	lds	r25, 0x06DF
    767a:	9a 83       	std	Y+2, r25	; 0x02
    767c:	89 83       	std	Y+1, r24	; 0x01
    767e:	ea 85       	ldd	r30, Y+10	; 0x0a
    7680:	fb 85       	ldd	r31, Y+11	; 0x0b
    7682:	89 81       	ldd	r24, Y+1	; 0x01
    7684:	9a 81       	ldd	r25, Y+2	; 0x02
    7686:	97 87       	std	Z+15, r25	; 0x0f
    7688:	86 87       	std	Z+14, r24	; 0x0e
    768a:	e9 81       	ldd	r30, Y+1	; 0x01
    768c:	fa 81       	ldd	r31, Y+2	; 0x02
    768e:	84 81       	ldd	r24, Z+4	; 0x04
    7690:	95 81       	ldd	r25, Z+5	; 0x05
    7692:	ea 85       	ldd	r30, Y+10	; 0x0a
    7694:	fb 85       	ldd	r31, Y+11	; 0x0b
    7696:	91 8b       	std	Z+17, r25	; 0x11
    7698:	80 8b       	std	Z+16, r24	; 0x10
    769a:	e9 81       	ldd	r30, Y+1	; 0x01
    769c:	fa 81       	ldd	r31, Y+2	; 0x02
    769e:	04 80       	ldd	r0, Z+4	; 0x04
    76a0:	f5 81       	ldd	r31, Z+5	; 0x05
    76a2:	e0 2d       	mov	r30, r0
    76a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    76a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    76a8:	0c 96       	adiw	r24, 0x0c	; 12
    76aa:	93 83       	std	Z+3, r25	; 0x03
    76ac:	82 83       	std	Z+2, r24	; 0x02
    76ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    76b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    76b2:	0c 96       	adiw	r24, 0x0c	; 12
    76b4:	e9 81       	ldd	r30, Y+1	; 0x01
    76b6:	fa 81       	ldd	r31, Y+2	; 0x02
    76b8:	95 83       	std	Z+5, r25	; 0x05
    76ba:	84 83       	std	Z+4, r24	; 0x04
    76bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    76be:	fb 85       	ldd	r31, Y+11	; 0x0b
    76c0:	8d ed       	ldi	r24, 0xDD	; 221
    76c2:	96 e0       	ldi	r25, 0x06	; 6
    76c4:	95 8b       	std	Z+21, r25	; 0x15
    76c6:	84 8b       	std	Z+20, r24	; 0x14
    76c8:	80 91 dd 06 	lds	r24, 0x06DD
    76cc:	8f 5f       	subi	r24, 0xFF	; 255
    76ce:	80 93 dd 06 	sts	0x06DD, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    76d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    76d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    76d6:	96 89       	ldd	r25, Z+22	; 0x16
    76d8:	e0 91 91 06 	lds	r30, 0x0691
    76dc:	f0 91 92 06 	lds	r31, 0x0692
    76e0:	86 89       	ldd	r24, Z+22	; 0x16
    76e2:	89 17       	cp	r24, r25
    76e4:	58 f4       	brcc	.+22     	; 0x76fc <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    76e6:	8e 89       	ldd	r24, Y+22	; 0x16
    76e8:	9f 89       	ldd	r25, Y+23	; 0x17
    76ea:	00 97       	sbiw	r24, 0x00	; 0
    76ec:	21 f0       	breq	.+8      	; 0x76f6 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    76ee:	ee 89       	ldd	r30, Y+22	; 0x16
    76f0:	ff 89       	ldd	r31, Y+23	; 0x17
    76f2:	81 e0       	ldi	r24, 0x01	; 1
    76f4:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    76f6:	81 e0       	ldi	r24, 0x01	; 1
    76f8:	80 93 9b 06 	sts	0x069B, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    76fc:	88 85       	ldd	r24, Y+8	; 0x08
    }
    76fe:	69 96       	adiw	r28, 0x19	; 25
    7700:	0f b6       	in	r0, 0x3f	; 63
    7702:	f8 94       	cli
    7704:	de bf       	out	0x3e, r29	; 62
    7706:	0f be       	out	0x3f, r0	; 63
    7708:	cd bf       	out	0x3d, r28	; 61
    770a:	cf 91       	pop	r28
    770c:	df 91       	pop	r29
    770e:	1f 91       	pop	r17
    7710:	0f 91       	pop	r16
    7712:	ff 90       	pop	r15
    7714:	ef 90       	pop	r14
    7716:	df 90       	pop	r13
    7718:	cf 90       	pop	r12
    771a:	08 95       	ret

0000771c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    771c:	0f 93       	push	r16
    771e:	1f 93       	push	r17
    7720:	df 93       	push	r29
    7722:	cf 93       	push	r28
    7724:	cd b7       	in	r28, 0x3d	; 61
    7726:	de b7       	in	r29, 0x3e	; 62
    7728:	2f 97       	sbiw	r28, 0x0f	; 15
    772a:	0f b6       	in	r0, 0x3f	; 63
    772c:	f8 94       	cli
    772e:	de bf       	out	0x3e, r29	; 62
    7730:	0f be       	out	0x3f, r0	; 63
    7732:	cd bf       	out	0x3d, r28	; 61
    7734:	9c 87       	std	Y+12, r25	; 0x0c
    7736:	8b 87       	std	Y+11, r24	; 0x0b
    7738:	6d 87       	std	Y+13, r22	; 0x0d
    773a:	5f 87       	std	Y+15, r21	; 0x0f
    773c:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    773e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7740:	9c 85       	ldd	r25, Y+12	; 0x0c
    7742:	9a 87       	std	Y+10, r25	; 0x0a
    7744:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7746:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    7748:	8d 85       	ldd	r24, Y+13	; 0x0d
    774a:	28 2f       	mov	r18, r24
    774c:	30 e0       	ldi	r19, 0x00	; 0
    774e:	89 85       	ldd	r24, Y+9	; 0x09
    7750:	9a 85       	ldd	r25, Y+10	; 0x0a
    7752:	82 0f       	add	r24, r18
    7754:	93 1f       	adc	r25, r19
    7756:	fc 01       	movw	r30, r24
    7758:	bd 96       	adiw	r30, 0x2d	; 45
    775a:	80 81       	ld	r24, Z
    775c:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    775e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7760:	28 2f       	mov	r18, r24
    7762:	30 e0       	ldi	r19, 0x00	; 0
    7764:	89 85       	ldd	r24, Y+9	; 0x09
    7766:	9a 85       	ldd	r25, Y+10	; 0x0a
    7768:	82 0f       	add	r24, r18
    776a:	93 1f       	adc	r25, r19
    776c:	fc 01       	movw	r30, r24
    776e:	bd 96       	adiw	r30, 0x2d	; 45
    7770:	82 e0       	ldi	r24, 0x02	; 2
    7772:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    7774:	8d 85       	ldd	r24, Y+13	; 0x0d
    7776:	08 2f       	mov	r16, r24
    7778:	10 e0       	ldi	r17, 0x00	; 0
    777a:	29 85       	ldd	r18, Y+9	; 0x09
    777c:	3a 85       	ldd	r19, Y+10	; 0x0a
    777e:	c8 01       	movw	r24, r16
    7780:	88 0f       	add	r24, r24
    7782:	99 1f       	adc	r25, r25
    7784:	88 0f       	add	r24, r24
    7786:	99 1f       	adc	r25, r25
    7788:	82 0f       	add	r24, r18
    778a:	93 1f       	adc	r25, r19
    778c:	fc 01       	movw	r30, r24
    778e:	b9 96       	adiw	r30, 0x29	; 41
    7790:	80 81       	ld	r24, Z
    7792:	91 81       	ldd	r25, Z+1	; 0x01
    7794:	a2 81       	ldd	r26, Z+2	; 0x02
    7796:	b3 81       	ldd	r27, Z+3	; 0x03
    7798:	ac 01       	movw	r20, r24
    779a:	bd 01       	movw	r22, r26
    779c:	4f 5f       	subi	r20, 0xFF	; 255
    779e:	5f 4f       	sbci	r21, 0xFF	; 255
    77a0:	6f 4f       	sbci	r22, 0xFF	; 255
    77a2:	7f 4f       	sbci	r23, 0xFF	; 255
    77a4:	29 85       	ldd	r18, Y+9	; 0x09
    77a6:	3a 85       	ldd	r19, Y+10	; 0x0a
    77a8:	c8 01       	movw	r24, r16
    77aa:	88 0f       	add	r24, r24
    77ac:	99 1f       	adc	r25, r25
    77ae:	88 0f       	add	r24, r24
    77b0:	99 1f       	adc	r25, r25
    77b2:	82 0f       	add	r24, r18
    77b4:	93 1f       	adc	r25, r19
    77b6:	fc 01       	movw	r30, r24
    77b8:	b9 96       	adiw	r30, 0x29	; 41
    77ba:	40 83       	st	Z, r20
    77bc:	51 83       	std	Z+1, r21	; 0x01
    77be:	62 83       	std	Z+2, r22	; 0x02
    77c0:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    77c2:	88 85       	ldd	r24, Y+8	; 0x08
    77c4:	81 30       	cpi	r24, 0x01	; 1
    77c6:	09 f0       	breq	.+2      	; 0x77ca <vTaskGenericNotifyGiveFromISR+0xae>
    77c8:	ee c0       	rjmp	.+476    	; 0x79a6 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    77ca:	80 91 a2 06 	lds	r24, 0x06A2
    77ce:	88 23       	and	r24, r24
    77d0:	09 f0       	breq	.+2      	; 0x77d4 <vTaskGenericNotifyGiveFromISR+0xb8>
    77d2:	a4 c0       	rjmp	.+328    	; 0x791c <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    77d4:	e9 85       	ldd	r30, Y+9	; 0x09
    77d6:	fa 85       	ldd	r31, Y+10	; 0x0a
    77d8:	82 85       	ldd	r24, Z+10	; 0x0a
    77da:	93 85       	ldd	r25, Z+11	; 0x0b
    77dc:	9e 83       	std	Y+6, r25	; 0x06
    77de:	8d 83       	std	Y+5, r24	; 0x05
    77e0:	e9 85       	ldd	r30, Y+9	; 0x09
    77e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    77e4:	a4 81       	ldd	r26, Z+4	; 0x04
    77e6:	b5 81       	ldd	r27, Z+5	; 0x05
    77e8:	e9 85       	ldd	r30, Y+9	; 0x09
    77ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    77ec:	86 81       	ldd	r24, Z+6	; 0x06
    77ee:	97 81       	ldd	r25, Z+7	; 0x07
    77f0:	15 96       	adiw	r26, 0x05	; 5
    77f2:	9c 93       	st	X, r25
    77f4:	8e 93       	st	-X, r24
    77f6:	14 97       	sbiw	r26, 0x04	; 4
    77f8:	e9 85       	ldd	r30, Y+9	; 0x09
    77fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    77fc:	a6 81       	ldd	r26, Z+6	; 0x06
    77fe:	b7 81       	ldd	r27, Z+7	; 0x07
    7800:	e9 85       	ldd	r30, Y+9	; 0x09
    7802:	fa 85       	ldd	r31, Y+10	; 0x0a
    7804:	84 81       	ldd	r24, Z+4	; 0x04
    7806:	95 81       	ldd	r25, Z+5	; 0x05
    7808:	13 96       	adiw	r26, 0x03	; 3
    780a:	9c 93       	st	X, r25
    780c:	8e 93       	st	-X, r24
    780e:	12 97       	sbiw	r26, 0x02	; 2
    7810:	ed 81       	ldd	r30, Y+5	; 0x05
    7812:	fe 81       	ldd	r31, Y+6	; 0x06
    7814:	21 81       	ldd	r18, Z+1	; 0x01
    7816:	32 81       	ldd	r19, Z+2	; 0x02
    7818:	89 85       	ldd	r24, Y+9	; 0x09
    781a:	9a 85       	ldd	r25, Y+10	; 0x0a
    781c:	02 96       	adiw	r24, 0x02	; 2
    781e:	28 17       	cp	r18, r24
    7820:	39 07       	cpc	r19, r25
    7822:	41 f4       	brne	.+16     	; 0x7834 <vTaskGenericNotifyGiveFromISR+0x118>
    7824:	e9 85       	ldd	r30, Y+9	; 0x09
    7826:	fa 85       	ldd	r31, Y+10	; 0x0a
    7828:	86 81       	ldd	r24, Z+6	; 0x06
    782a:	97 81       	ldd	r25, Z+7	; 0x07
    782c:	ed 81       	ldd	r30, Y+5	; 0x05
    782e:	fe 81       	ldd	r31, Y+6	; 0x06
    7830:	92 83       	std	Z+2, r25	; 0x02
    7832:	81 83       	std	Z+1, r24	; 0x01
    7834:	e9 85       	ldd	r30, Y+9	; 0x09
    7836:	fa 85       	ldd	r31, Y+10	; 0x0a
    7838:	13 86       	std	Z+11, r1	; 0x0b
    783a:	12 86       	std	Z+10, r1	; 0x0a
    783c:	ed 81       	ldd	r30, Y+5	; 0x05
    783e:	fe 81       	ldd	r31, Y+6	; 0x06
    7840:	80 81       	ld	r24, Z
    7842:	81 50       	subi	r24, 0x01	; 1
    7844:	ed 81       	ldd	r30, Y+5	; 0x05
    7846:	fe 81       	ldd	r31, Y+6	; 0x06
    7848:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    784a:	e9 85       	ldd	r30, Y+9	; 0x09
    784c:	fa 85       	ldd	r31, Y+10	; 0x0a
    784e:	96 89       	ldd	r25, Z+22	; 0x16
    7850:	80 91 97 06 	lds	r24, 0x0697
    7854:	89 17       	cp	r24, r25
    7856:	28 f4       	brcc	.+10     	; 0x7862 <vTaskGenericNotifyGiveFromISR+0x146>
    7858:	e9 85       	ldd	r30, Y+9	; 0x09
    785a:	fa 85       	ldd	r31, Y+10	; 0x0a
    785c:	86 89       	ldd	r24, Z+22	; 0x16
    785e:	80 93 97 06 	sts	0x0697, r24
    7862:	e9 85       	ldd	r30, Y+9	; 0x09
    7864:	fa 85       	ldd	r31, Y+10	; 0x0a
    7866:	86 89       	ldd	r24, Z+22	; 0x16
    7868:	28 2f       	mov	r18, r24
    786a:	30 e0       	ldi	r19, 0x00	; 0
    786c:	c9 01       	movw	r24, r18
    786e:	88 0f       	add	r24, r24
    7870:	99 1f       	adc	r25, r25
    7872:	88 0f       	add	r24, r24
    7874:	99 1f       	adc	r25, r25
    7876:	88 0f       	add	r24, r24
    7878:	99 1f       	adc	r25, r25
    787a:	82 0f       	add	r24, r18
    787c:	93 1f       	adc	r25, r19
    787e:	fc 01       	movw	r30, r24
    7880:	ed 55       	subi	r30, 0x5D	; 93
    7882:	f9 4f       	sbci	r31, 0xF9	; 249
    7884:	81 81       	ldd	r24, Z+1	; 0x01
    7886:	92 81       	ldd	r25, Z+2	; 0x02
    7888:	9c 83       	std	Y+4, r25	; 0x04
    788a:	8b 83       	std	Y+3, r24	; 0x03
    788c:	e9 85       	ldd	r30, Y+9	; 0x09
    788e:	fa 85       	ldd	r31, Y+10	; 0x0a
    7890:	8b 81       	ldd	r24, Y+3	; 0x03
    7892:	9c 81       	ldd	r25, Y+4	; 0x04
    7894:	95 83       	std	Z+5, r25	; 0x05
    7896:	84 83       	std	Z+4, r24	; 0x04
    7898:	eb 81       	ldd	r30, Y+3	; 0x03
    789a:	fc 81       	ldd	r31, Y+4	; 0x04
    789c:	84 81       	ldd	r24, Z+4	; 0x04
    789e:	95 81       	ldd	r25, Z+5	; 0x05
    78a0:	e9 85       	ldd	r30, Y+9	; 0x09
    78a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    78a4:	97 83       	std	Z+7, r25	; 0x07
    78a6:	86 83       	std	Z+6, r24	; 0x06
    78a8:	eb 81       	ldd	r30, Y+3	; 0x03
    78aa:	fc 81       	ldd	r31, Y+4	; 0x04
    78ac:	04 80       	ldd	r0, Z+4	; 0x04
    78ae:	f5 81       	ldd	r31, Z+5	; 0x05
    78b0:	e0 2d       	mov	r30, r0
    78b2:	89 85       	ldd	r24, Y+9	; 0x09
    78b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    78b6:	02 96       	adiw	r24, 0x02	; 2
    78b8:	93 83       	std	Z+3, r25	; 0x03
    78ba:	82 83       	std	Z+2, r24	; 0x02
    78bc:	89 85       	ldd	r24, Y+9	; 0x09
    78be:	9a 85       	ldd	r25, Y+10	; 0x0a
    78c0:	02 96       	adiw	r24, 0x02	; 2
    78c2:	eb 81       	ldd	r30, Y+3	; 0x03
    78c4:	fc 81       	ldd	r31, Y+4	; 0x04
    78c6:	95 83       	std	Z+5, r25	; 0x05
    78c8:	84 83       	std	Z+4, r24	; 0x04
    78ca:	e9 85       	ldd	r30, Y+9	; 0x09
    78cc:	fa 85       	ldd	r31, Y+10	; 0x0a
    78ce:	86 89       	ldd	r24, Z+22	; 0x16
    78d0:	28 2f       	mov	r18, r24
    78d2:	30 e0       	ldi	r19, 0x00	; 0
    78d4:	c9 01       	movw	r24, r18
    78d6:	88 0f       	add	r24, r24
    78d8:	99 1f       	adc	r25, r25
    78da:	88 0f       	add	r24, r24
    78dc:	99 1f       	adc	r25, r25
    78de:	88 0f       	add	r24, r24
    78e0:	99 1f       	adc	r25, r25
    78e2:	82 0f       	add	r24, r18
    78e4:	93 1f       	adc	r25, r19
    78e6:	8d 55       	subi	r24, 0x5D	; 93
    78e8:	99 4f       	sbci	r25, 0xF9	; 249
    78ea:	e9 85       	ldd	r30, Y+9	; 0x09
    78ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    78ee:	93 87       	std	Z+11, r25	; 0x0b
    78f0:	82 87       	std	Z+10, r24	; 0x0a
    78f2:	e9 85       	ldd	r30, Y+9	; 0x09
    78f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    78f6:	86 89       	ldd	r24, Z+22	; 0x16
    78f8:	28 2f       	mov	r18, r24
    78fa:	30 e0       	ldi	r19, 0x00	; 0
    78fc:	c9 01       	movw	r24, r18
    78fe:	88 0f       	add	r24, r24
    7900:	99 1f       	adc	r25, r25
    7902:	88 0f       	add	r24, r24
    7904:	99 1f       	adc	r25, r25
    7906:	88 0f       	add	r24, r24
    7908:	99 1f       	adc	r25, r25
    790a:	82 0f       	add	r24, r18
    790c:	93 1f       	adc	r25, r19
    790e:	fc 01       	movw	r30, r24
    7910:	ed 55       	subi	r30, 0x5D	; 93
    7912:	f9 4f       	sbci	r31, 0xF9	; 249
    7914:	80 81       	ld	r24, Z
    7916:	8f 5f       	subi	r24, 0xFF	; 255
    7918:	80 83       	st	Z, r24
    791a:	30 c0       	rjmp	.+96     	; 0x797c <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    791c:	80 91 de 06 	lds	r24, 0x06DE
    7920:	90 91 df 06 	lds	r25, 0x06DF
    7924:	9a 83       	std	Y+2, r25	; 0x02
    7926:	89 83       	std	Y+1, r24	; 0x01
    7928:	e9 85       	ldd	r30, Y+9	; 0x09
    792a:	fa 85       	ldd	r31, Y+10	; 0x0a
    792c:	89 81       	ldd	r24, Y+1	; 0x01
    792e:	9a 81       	ldd	r25, Y+2	; 0x02
    7930:	97 87       	std	Z+15, r25	; 0x0f
    7932:	86 87       	std	Z+14, r24	; 0x0e
    7934:	e9 81       	ldd	r30, Y+1	; 0x01
    7936:	fa 81       	ldd	r31, Y+2	; 0x02
    7938:	84 81       	ldd	r24, Z+4	; 0x04
    793a:	95 81       	ldd	r25, Z+5	; 0x05
    793c:	e9 85       	ldd	r30, Y+9	; 0x09
    793e:	fa 85       	ldd	r31, Y+10	; 0x0a
    7940:	91 8b       	std	Z+17, r25	; 0x11
    7942:	80 8b       	std	Z+16, r24	; 0x10
    7944:	e9 81       	ldd	r30, Y+1	; 0x01
    7946:	fa 81       	ldd	r31, Y+2	; 0x02
    7948:	04 80       	ldd	r0, Z+4	; 0x04
    794a:	f5 81       	ldd	r31, Z+5	; 0x05
    794c:	e0 2d       	mov	r30, r0
    794e:	89 85       	ldd	r24, Y+9	; 0x09
    7950:	9a 85       	ldd	r25, Y+10	; 0x0a
    7952:	0c 96       	adiw	r24, 0x0c	; 12
    7954:	93 83       	std	Z+3, r25	; 0x03
    7956:	82 83       	std	Z+2, r24	; 0x02
    7958:	89 85       	ldd	r24, Y+9	; 0x09
    795a:	9a 85       	ldd	r25, Y+10	; 0x0a
    795c:	0c 96       	adiw	r24, 0x0c	; 12
    795e:	e9 81       	ldd	r30, Y+1	; 0x01
    7960:	fa 81       	ldd	r31, Y+2	; 0x02
    7962:	95 83       	std	Z+5, r25	; 0x05
    7964:	84 83       	std	Z+4, r24	; 0x04
    7966:	e9 85       	ldd	r30, Y+9	; 0x09
    7968:	fa 85       	ldd	r31, Y+10	; 0x0a
    796a:	8d ed       	ldi	r24, 0xDD	; 221
    796c:	96 e0       	ldi	r25, 0x06	; 6
    796e:	95 8b       	std	Z+21, r25	; 0x15
    7970:	84 8b       	std	Z+20, r24	; 0x14
    7972:	80 91 dd 06 	lds	r24, 0x06DD
    7976:	8f 5f       	subi	r24, 0xFF	; 255
    7978:	80 93 dd 06 	sts	0x06DD, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    797c:	e9 85       	ldd	r30, Y+9	; 0x09
    797e:	fa 85       	ldd	r31, Y+10	; 0x0a
    7980:	96 89       	ldd	r25, Z+22	; 0x16
    7982:	e0 91 91 06 	lds	r30, 0x0691
    7986:	f0 91 92 06 	lds	r31, 0x0692
    798a:	86 89       	ldd	r24, Z+22	; 0x16
    798c:	89 17       	cp	r24, r25
    798e:	58 f4       	brcc	.+22     	; 0x79a6 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    7990:	8e 85       	ldd	r24, Y+14	; 0x0e
    7992:	9f 85       	ldd	r25, Y+15	; 0x0f
    7994:	00 97       	sbiw	r24, 0x00	; 0
    7996:	21 f0       	breq	.+8      	; 0x79a0 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    7998:	ee 85       	ldd	r30, Y+14	; 0x0e
    799a:	ff 85       	ldd	r31, Y+15	; 0x0f
    799c:	81 e0       	ldi	r24, 0x01	; 1
    799e:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    79a0:	81 e0       	ldi	r24, 0x01	; 1
    79a2:	80 93 9b 06 	sts	0x069B, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    79a6:	2f 96       	adiw	r28, 0x0f	; 15
    79a8:	0f b6       	in	r0, 0x3f	; 63
    79aa:	f8 94       	cli
    79ac:	de bf       	out	0x3e, r29	; 62
    79ae:	0f be       	out	0x3f, r0	; 63
    79b0:	cd bf       	out	0x3d, r28	; 61
    79b2:	cf 91       	pop	r28
    79b4:	df 91       	pop	r29
    79b6:	1f 91       	pop	r17
    79b8:	0f 91       	pop	r16
    79ba:	08 95       	ret

000079bc <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    79bc:	df 93       	push	r29
    79be:	cf 93       	push	r28
    79c0:	cd b7       	in	r28, 0x3d	; 61
    79c2:	de b7       	in	r29, 0x3e	; 62
    79c4:	28 97       	sbiw	r28, 0x08	; 8
    79c6:	0f b6       	in	r0, 0x3f	; 63
    79c8:	f8 94       	cli
    79ca:	de bf       	out	0x3e, r29	; 62
    79cc:	0f be       	out	0x3f, r0	; 63
    79ce:	cd bf       	out	0x3d, r28	; 61
    79d0:	9d 83       	std	Y+5, r25	; 0x05
    79d2:	8c 83       	std	Y+4, r24	; 0x04
    79d4:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    79d6:	8c 81       	ldd	r24, Y+4	; 0x04
    79d8:	9d 81       	ldd	r25, Y+5	; 0x05
    79da:	00 97       	sbiw	r24, 0x00	; 0
    79dc:	39 f4       	brne	.+14     	; 0x79ec <xTaskGenericNotifyStateClear+0x30>
    79de:	80 91 91 06 	lds	r24, 0x0691
    79e2:	90 91 92 06 	lds	r25, 0x0692
    79e6:	98 87       	std	Y+8, r25	; 0x08
    79e8:	8f 83       	std	Y+7, r24	; 0x07
    79ea:	04 c0       	rjmp	.+8      	; 0x79f4 <xTaskGenericNotifyStateClear+0x38>
    79ec:	8c 81       	ldd	r24, Y+4	; 0x04
    79ee:	9d 81       	ldd	r25, Y+5	; 0x05
    79f0:	98 87       	std	Y+8, r25	; 0x08
    79f2:	8f 83       	std	Y+7, r24	; 0x07
    79f4:	8f 81       	ldd	r24, Y+7	; 0x07
    79f6:	98 85       	ldd	r25, Y+8	; 0x08
    79f8:	9b 83       	std	Y+3, r25	; 0x03
    79fa:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    79fc:	0f b6       	in	r0, 0x3f	; 63
    79fe:	f8 94       	cli
    7a00:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    7a02:	8e 81       	ldd	r24, Y+6	; 0x06
    7a04:	28 2f       	mov	r18, r24
    7a06:	30 e0       	ldi	r19, 0x00	; 0
    7a08:	8a 81       	ldd	r24, Y+2	; 0x02
    7a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    7a0c:	82 0f       	add	r24, r18
    7a0e:	93 1f       	adc	r25, r19
    7a10:	fc 01       	movw	r30, r24
    7a12:	bd 96       	adiw	r30, 0x2d	; 45
    7a14:	80 81       	ld	r24, Z
    7a16:	82 30       	cpi	r24, 0x02	; 2
    7a18:	69 f4       	brne	.+26     	; 0x7a34 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    7a1a:	8e 81       	ldd	r24, Y+6	; 0x06
    7a1c:	28 2f       	mov	r18, r24
    7a1e:	30 e0       	ldi	r19, 0x00	; 0
    7a20:	8a 81       	ldd	r24, Y+2	; 0x02
    7a22:	9b 81       	ldd	r25, Y+3	; 0x03
    7a24:	82 0f       	add	r24, r18
    7a26:	93 1f       	adc	r25, r19
    7a28:	fc 01       	movw	r30, r24
    7a2a:	bd 96       	adiw	r30, 0x2d	; 45
    7a2c:	10 82       	st	Z, r1
                xReturn = pdPASS;
    7a2e:	81 e0       	ldi	r24, 0x01	; 1
    7a30:	89 83       	std	Y+1, r24	; 0x01
    7a32:	01 c0       	rjmp	.+2      	; 0x7a36 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    7a34:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    7a36:	0f 90       	pop	r0
    7a38:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    7a3a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    7a3c:	28 96       	adiw	r28, 0x08	; 8
    7a3e:	0f b6       	in	r0, 0x3f	; 63
    7a40:	f8 94       	cli
    7a42:	de bf       	out	0x3e, r29	; 62
    7a44:	0f be       	out	0x3f, r0	; 63
    7a46:	cd bf       	out	0x3d, r28	; 61
    7a48:	cf 91       	pop	r28
    7a4a:	df 91       	pop	r29
    7a4c:	08 95       	ret

00007a4e <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    7a4e:	0f 93       	push	r16
    7a50:	1f 93       	push	r17
    7a52:	df 93       	push	r29
    7a54:	cf 93       	push	r28
    7a56:	cd b7       	in	r28, 0x3d	; 61
    7a58:	de b7       	in	r29, 0x3e	; 62
    7a5a:	2f 97       	sbiw	r28, 0x0f	; 15
    7a5c:	0f b6       	in	r0, 0x3f	; 63
    7a5e:	f8 94       	cli
    7a60:	de bf       	out	0x3e, r29	; 62
    7a62:	0f be       	out	0x3f, r0	; 63
    7a64:	cd bf       	out	0x3d, r28	; 61
    7a66:	98 87       	std	Y+8, r25	; 0x08
    7a68:	8f 83       	std	Y+7, r24	; 0x07
    7a6a:	69 87       	std	Y+9, r22	; 0x09
    7a6c:	2a 87       	std	Y+10, r18	; 0x0a
    7a6e:	3b 87       	std	Y+11, r19	; 0x0b
    7a70:	4c 87       	std	Y+12, r20	; 0x0c
    7a72:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    7a74:	8f 81       	ldd	r24, Y+7	; 0x07
    7a76:	98 85       	ldd	r25, Y+8	; 0x08
    7a78:	00 97       	sbiw	r24, 0x00	; 0
    7a7a:	39 f4       	brne	.+14     	; 0x7a8a <ulTaskGenericNotifyValueClear+0x3c>
    7a7c:	80 91 91 06 	lds	r24, 0x0691
    7a80:	90 91 92 06 	lds	r25, 0x0692
    7a84:	9f 87       	std	Y+15, r25	; 0x0f
    7a86:	8e 87       	std	Y+14, r24	; 0x0e
    7a88:	04 c0       	rjmp	.+8      	; 0x7a92 <ulTaskGenericNotifyValueClear+0x44>
    7a8a:	8f 81       	ldd	r24, Y+7	; 0x07
    7a8c:	98 85       	ldd	r25, Y+8	; 0x08
    7a8e:	9f 87       	std	Y+15, r25	; 0x0f
    7a90:	8e 87       	std	Y+14, r24	; 0x0e
    7a92:	8e 85       	ldd	r24, Y+14	; 0x0e
    7a94:	9f 85       	ldd	r25, Y+15	; 0x0f
    7a96:	9e 83       	std	Y+6, r25	; 0x06
    7a98:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    7a9a:	0f b6       	in	r0, 0x3f	; 63
    7a9c:	f8 94       	cli
    7a9e:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    7aa0:	89 85       	ldd	r24, Y+9	; 0x09
    7aa2:	88 2f       	mov	r24, r24
    7aa4:	90 e0       	ldi	r25, 0x00	; 0
    7aa6:	2d 81       	ldd	r18, Y+5	; 0x05
    7aa8:	3e 81       	ldd	r19, Y+6	; 0x06
    7aaa:	88 0f       	add	r24, r24
    7aac:	99 1f       	adc	r25, r25
    7aae:	88 0f       	add	r24, r24
    7ab0:	99 1f       	adc	r25, r25
    7ab2:	82 0f       	add	r24, r18
    7ab4:	93 1f       	adc	r25, r19
    7ab6:	fc 01       	movw	r30, r24
    7ab8:	b9 96       	adiw	r30, 0x29	; 41
    7aba:	80 81       	ld	r24, Z
    7abc:	91 81       	ldd	r25, Z+1	; 0x01
    7abe:	a2 81       	ldd	r26, Z+2	; 0x02
    7ac0:	b3 81       	ldd	r27, Z+3	; 0x03
    7ac2:	89 83       	std	Y+1, r24	; 0x01
    7ac4:	9a 83       	std	Y+2, r25	; 0x02
    7ac6:	ab 83       	std	Y+3, r26	; 0x03
    7ac8:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    7aca:	89 85       	ldd	r24, Y+9	; 0x09
    7acc:	08 2f       	mov	r16, r24
    7ace:	10 e0       	ldi	r17, 0x00	; 0
    7ad0:	89 85       	ldd	r24, Y+9	; 0x09
    7ad2:	88 2f       	mov	r24, r24
    7ad4:	90 e0       	ldi	r25, 0x00	; 0
    7ad6:	2d 81       	ldd	r18, Y+5	; 0x05
    7ad8:	3e 81       	ldd	r19, Y+6	; 0x06
    7ada:	88 0f       	add	r24, r24
    7adc:	99 1f       	adc	r25, r25
    7ade:	88 0f       	add	r24, r24
    7ae0:	99 1f       	adc	r25, r25
    7ae2:	82 0f       	add	r24, r18
    7ae4:	93 1f       	adc	r25, r19
    7ae6:	fc 01       	movw	r30, r24
    7ae8:	b9 96       	adiw	r30, 0x29	; 41
    7aea:	20 81       	ld	r18, Z
    7aec:	31 81       	ldd	r19, Z+1	; 0x01
    7aee:	42 81       	ldd	r20, Z+2	; 0x02
    7af0:	53 81       	ldd	r21, Z+3	; 0x03
    7af2:	8a 85       	ldd	r24, Y+10	; 0x0a
    7af4:	9b 85       	ldd	r25, Y+11	; 0x0b
    7af6:	ac 85       	ldd	r26, Y+12	; 0x0c
    7af8:	bd 85       	ldd	r27, Y+13	; 0x0d
    7afa:	80 95       	com	r24
    7afc:	90 95       	com	r25
    7afe:	a0 95       	com	r26
    7b00:	b0 95       	com	r27
    7b02:	ba 01       	movw	r22, r20
    7b04:	a9 01       	movw	r20, r18
    7b06:	48 23       	and	r20, r24
    7b08:	59 23       	and	r21, r25
    7b0a:	6a 23       	and	r22, r26
    7b0c:	7b 23       	and	r23, r27
    7b0e:	2d 81       	ldd	r18, Y+5	; 0x05
    7b10:	3e 81       	ldd	r19, Y+6	; 0x06
    7b12:	c8 01       	movw	r24, r16
    7b14:	88 0f       	add	r24, r24
    7b16:	99 1f       	adc	r25, r25
    7b18:	88 0f       	add	r24, r24
    7b1a:	99 1f       	adc	r25, r25
    7b1c:	82 0f       	add	r24, r18
    7b1e:	93 1f       	adc	r25, r19
    7b20:	fc 01       	movw	r30, r24
    7b22:	b9 96       	adiw	r30, 0x29	; 41
    7b24:	40 83       	st	Z, r20
    7b26:	51 83       	std	Z+1, r21	; 0x01
    7b28:	62 83       	std	Z+2, r22	; 0x02
    7b2a:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    7b2c:	0f 90       	pop	r0
    7b2e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    7b30:	89 81       	ldd	r24, Y+1	; 0x01
    7b32:	9a 81       	ldd	r25, Y+2	; 0x02
    7b34:	ab 81       	ldd	r26, Y+3	; 0x03
    7b36:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    7b38:	bc 01       	movw	r22, r24
    7b3a:	cd 01       	movw	r24, r26
    7b3c:	2f 96       	adiw	r28, 0x0f	; 15
    7b3e:	0f b6       	in	r0, 0x3f	; 63
    7b40:	f8 94       	cli
    7b42:	de bf       	out	0x3e, r29	; 62
    7b44:	0f be       	out	0x3f, r0	; 63
    7b46:	cd bf       	out	0x3d, r28	; 61
    7b48:	cf 91       	pop	r28
    7b4a:	df 91       	pop	r29
    7b4c:	1f 91       	pop	r17
    7b4e:	0f 91       	pop	r16
    7b50:	08 95       	ret

00007b52 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    7b52:	df 93       	push	r29
    7b54:	cf 93       	push	r28
    7b56:	cd b7       	in	r28, 0x3d	; 61
    7b58:	de b7       	in	r29, 0x3e	; 62
    7b5a:	29 97       	sbiw	r28, 0x09	; 9
    7b5c:	0f b6       	in	r0, 0x3f	; 63
    7b5e:	f8 94       	cli
    7b60:	de bf       	out	0x3e, r29	; 62
    7b62:	0f be       	out	0x3f, r0	; 63
    7b64:	cd bf       	out	0x3d, r28	; 61
    7b66:	98 87       	std	Y+8, r25	; 0x08
    7b68:	8f 83       	std	Y+7, r24	; 0x07
    7b6a:	69 87       	std	Y+9, r22	; 0x09
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    7b6c:	80 91 95 06 	lds	r24, 0x0695
    7b70:	90 91 96 06 	lds	r25, 0x0696
    7b74:	9c 83       	std	Y+4, r25	; 0x04
    7b76:	8b 83       	std	Y+3, r24	; 0x03
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7b78:	80 91 91 06 	lds	r24, 0x0691
    7b7c:	90 91 92 06 	lds	r25, 0x0692
    7b80:	02 96       	adiw	r24, 0x02	; 2
    7b82:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    7b86:	8f 81       	ldd	r24, Y+7	; 0x07
    7b88:	98 85       	ldd	r25, Y+8	; 0x08
    7b8a:	2f ef       	ldi	r18, 0xFF	; 255
    7b8c:	8f 3f       	cpi	r24, 0xFF	; 255
    7b8e:	92 07       	cpc	r25, r18
    7b90:	09 f0       	breq	.+2      	; 0x7b94 <prvAddCurrentTaskToDelayedList+0x42>
    7b92:	40 c0       	rjmp	.+128    	; 0x7c14 <prvAddCurrentTaskToDelayedList+0xc2>
    7b94:	89 85       	ldd	r24, Y+9	; 0x09
    7b96:	88 23       	and	r24, r24
    7b98:	e9 f1       	breq	.+122    	; 0x7c14 <prvAddCurrentTaskToDelayedList+0xc2>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7b9a:	80 91 f0 06 	lds	r24, 0x06F0
    7b9e:	90 91 f1 06 	lds	r25, 0x06F1
    7ba2:	9a 83       	std	Y+2, r25	; 0x02
    7ba4:	89 83       	std	Y+1, r24	; 0x01
    7ba6:	e0 91 91 06 	lds	r30, 0x0691
    7baa:	f0 91 92 06 	lds	r31, 0x0692
    7bae:	89 81       	ldd	r24, Y+1	; 0x01
    7bb0:	9a 81       	ldd	r25, Y+2	; 0x02
    7bb2:	95 83       	std	Z+5, r25	; 0x05
    7bb4:	84 83       	std	Z+4, r24	; 0x04
    7bb6:	a0 91 91 06 	lds	r26, 0x0691
    7bba:	b0 91 92 06 	lds	r27, 0x0692
    7bbe:	e9 81       	ldd	r30, Y+1	; 0x01
    7bc0:	fa 81       	ldd	r31, Y+2	; 0x02
    7bc2:	84 81       	ldd	r24, Z+4	; 0x04
    7bc4:	95 81       	ldd	r25, Z+5	; 0x05
    7bc6:	17 96       	adiw	r26, 0x07	; 7
    7bc8:	9c 93       	st	X, r25
    7bca:	8e 93       	st	-X, r24
    7bcc:	16 97       	sbiw	r26, 0x06	; 6
    7bce:	e9 81       	ldd	r30, Y+1	; 0x01
    7bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    7bd2:	04 80       	ldd	r0, Z+4	; 0x04
    7bd4:	f5 81       	ldd	r31, Z+5	; 0x05
    7bd6:	e0 2d       	mov	r30, r0
    7bd8:	80 91 91 06 	lds	r24, 0x0691
    7bdc:	90 91 92 06 	lds	r25, 0x0692
    7be0:	02 96       	adiw	r24, 0x02	; 2
    7be2:	93 83       	std	Z+3, r25	; 0x03
    7be4:	82 83       	std	Z+2, r24	; 0x02
    7be6:	80 91 91 06 	lds	r24, 0x0691
    7bea:	90 91 92 06 	lds	r25, 0x0692
    7bee:	02 96       	adiw	r24, 0x02	; 2
    7bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    7bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    7bf4:	95 83       	std	Z+5, r25	; 0x05
    7bf6:	84 83       	std	Z+4, r24	; 0x04
    7bf8:	e0 91 91 06 	lds	r30, 0x0691
    7bfc:	f0 91 92 06 	lds	r31, 0x0692
    7c00:	8f ee       	ldi	r24, 0xEF	; 239
    7c02:	96 e0       	ldi	r25, 0x06	; 6
    7c04:	93 87       	std	Z+11, r25	; 0x0b
    7c06:	82 87       	std	Z+10, r24	; 0x0a
    7c08:	80 91 ef 06 	lds	r24, 0x06EF
    7c0c:	8f 5f       	subi	r24, 0xFF	; 255
    7c0e:	80 93 ef 06 	sts	0x06EF, r24
    7c12:	43 c0       	rjmp	.+134    	; 0x7c9a <prvAddCurrentTaskToDelayedList+0x148>
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    7c14:	2b 81       	ldd	r18, Y+3	; 0x03
    7c16:	3c 81       	ldd	r19, Y+4	; 0x04
    7c18:	8f 81       	ldd	r24, Y+7	; 0x07
    7c1a:	98 85       	ldd	r25, Y+8	; 0x08
    7c1c:	82 0f       	add	r24, r18
    7c1e:	93 1f       	adc	r25, r19
    7c20:	9e 83       	std	Y+6, r25	; 0x06
    7c22:	8d 83       	std	Y+5, r24	; 0x05

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    7c24:	e0 91 91 06 	lds	r30, 0x0691
    7c28:	f0 91 92 06 	lds	r31, 0x0692
    7c2c:	8d 81       	ldd	r24, Y+5	; 0x05
    7c2e:	9e 81       	ldd	r25, Y+6	; 0x06
    7c30:	93 83       	std	Z+3, r25	; 0x03
    7c32:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    7c34:	2d 81       	ldd	r18, Y+5	; 0x05
    7c36:	3e 81       	ldd	r19, Y+6	; 0x06
    7c38:	8b 81       	ldd	r24, Y+3	; 0x03
    7c3a:	9c 81       	ldd	r25, Y+4	; 0x04
    7c3c:	28 17       	cp	r18, r24
    7c3e:	39 07       	cpc	r19, r25
    7c40:	70 f4       	brcc	.+28     	; 0x7c5e <prvAddCurrentTaskToDelayedList+0x10c>
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7c42:	80 91 db 06 	lds	r24, 0x06DB
    7c46:	90 91 dc 06 	lds	r25, 0x06DC
    7c4a:	20 91 91 06 	lds	r18, 0x0691
    7c4e:	30 91 92 06 	lds	r19, 0x0692
    7c52:	2e 5f       	subi	r18, 0xFE	; 254
    7c54:	3f 4f       	sbci	r19, 0xFF	; 255
    7c56:	b9 01       	movw	r22, r18
    7c58:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vListInsert>
    7c5c:	1e c0       	rjmp	.+60     	; 0x7c9a <prvAddCurrentTaskToDelayedList+0x148>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7c5e:	40 91 d9 06 	lds	r20, 0x06D9
    7c62:	50 91 da 06 	lds	r21, 0x06DA
    7c66:	80 91 91 06 	lds	r24, 0x0691
    7c6a:	90 91 92 06 	lds	r25, 0x0692
    7c6e:	9c 01       	movw	r18, r24
    7c70:	2e 5f       	subi	r18, 0xFE	; 254
    7c72:	3f 4f       	sbci	r19, 0xFF	; 255
    7c74:	ca 01       	movw	r24, r20
    7c76:	b9 01       	movw	r22, r18
    7c78:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    7c7c:	20 91 9e 06 	lds	r18, 0x069E
    7c80:	30 91 9f 06 	lds	r19, 0x069F
    7c84:	8d 81       	ldd	r24, Y+5	; 0x05
    7c86:	9e 81       	ldd	r25, Y+6	; 0x06
    7c88:	82 17       	cp	r24, r18
    7c8a:	93 07       	cpc	r25, r19
    7c8c:	30 f4       	brcc	.+12     	; 0x7c9a <prvAddCurrentTaskToDelayedList+0x148>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    7c8e:	8d 81       	ldd	r24, Y+5	; 0x05
    7c90:	9e 81       	ldd	r25, Y+6	; 0x06
    7c92:	90 93 9f 06 	sts	0x069F, r25
    7c96:	80 93 9e 06 	sts	0x069E, r24

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    7c9a:	29 96       	adiw	r28, 0x09	; 9
    7c9c:	0f b6       	in	r0, 0x3f	; 63
    7c9e:	f8 94       	cli
    7ca0:	de bf       	out	0x3e, r29	; 62
    7ca2:	0f be       	out	0x3f, r0	; 63
    7ca4:	cd bf       	out	0x3d, r28	; 61
    7ca6:	cf 91       	pop	r28
    7ca8:	df 91       	pop	r29
    7caa:	08 95       	ret

00007cac <vTask0_Init>:
TaskHandle_t* BTN_Press_Task = NULL;
/********************************************************************************************************/



void vTask0_Init(void *ptr){
    7cac:	df 93       	push	r29
    7cae:	cf 93       	push	r28
    7cb0:	00 d0       	rcall	.+0      	; 0x7cb2 <vTask0_Init+0x6>
    7cb2:	cd b7       	in	r28, 0x3d	; 61
    7cb4:	de b7       	in	r29, 0x3e	; 62
    7cb6:	9a 83       	std	Y+2, r25	; 0x02
    7cb8:	89 83       	std	Y+1, r24	; 0x01
	while(1){

		LED_voidInit(DIO_u8PortC, DIO_u8PIN2);
    7cba:	82 e0       	ldi	r24, 0x02	; 2
    7cbc:	62 e0       	ldi	r22, 0x02	; 2
    7cbe:	41 e0       	ldi	r20, 0x01	; 1
    7cc0:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
		LED_voidInit(DIO_u8PortC, DIO_u8PIN7);
    7cc4:	82 e0       	ldi	r24, 0x02	; 2
    7cc6:	67 e0       	ldi	r22, 0x07	; 7
    7cc8:	41 e0       	ldi	r20, 0x01	; 1
    7cca:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
		LED_voidInit(DIO_u8PortD, DIO_u8PIN3);
    7cce:	83 e0       	ldi	r24, 0x03	; 3
    7cd0:	63 e0       	ldi	r22, 0x03	; 3
    7cd2:	41 e0       	ldi	r20, 0x01	; 1
    7cd4:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>
		LCD_enuInit();
    7cd8:	0e 94 da 09 	call	0x13b4	; 0x13b4 <LCD_enuInit>
		BTN_voidInit(DIO_u8PortB, DIO_u8PIN0);
    7cdc:	81 e0       	ldi	r24, 0x01	; 1
    7cde:	60 e0       	ldi	r22, 0x00	; 0
    7ce0:	40 e0       	ldi	r20, 0x00	; 0
    7ce2:	0e 94 ce 05 	call	0xb9c	; 0xb9c <DIO_enuSetPinDirection>

		LED_voidON(DIO_u8PortC, DIO_u8PIN2);
    7ce6:	82 e0       	ldi	r24, 0x02	; 2
    7ce8:	62 e0       	ldi	r22, 0x02	; 2
    7cea:	41 e0       	ldi	r20, 0x01	; 1
    7cec:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
		LED_voidON(DIO_u8PortC, DIO_u8PIN7);
    7cf0:	82 e0       	ldi	r24, 0x02	; 2
    7cf2:	67 e0       	ldi	r22, 0x07	; 7
    7cf4:	41 e0       	ldi	r20, 0x01	; 1
    7cf6:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>
		LED_voidON(DIO_u8PortD, DIO_u8PIN3);
    7cfa:	83 e0       	ldi	r24, 0x03	; 3
    7cfc:	63 e0       	ldi	r22, 0x03	; 3
    7cfe:	41 e0       	ldi	r20, 0x01	; 1
    7d00:	0e 94 ca 06 	call	0xd94	; 0xd94 <DIO_enuSetPinValue>



		vSemaphoreCreateBinary(LCD_Key);
    7d04:	81 e0       	ldi	r24, 0x01	; 1
    7d06:	60 e0       	ldi	r22, 0x00	; 0
    7d08:	43 e0       	ldi	r20, 0x03	; 3
    7d0a:	0e 94 11 1a 	call	0x3422	; 0x3422 <xQueueGenericCreate>
    7d0e:	90 93 13 07 	sts	0x0713, r25
    7d12:	80 93 12 07 	sts	0x0712, r24
    7d16:	80 91 12 07 	lds	r24, 0x0712
    7d1a:	90 91 13 07 	lds	r25, 0x0713
    7d1e:	00 97       	sbiw	r24, 0x00	; 0
    7d20:	59 f0       	breq	.+22     	; 0x7d38 <vTask0_Init+0x8c>
    7d22:	80 91 12 07 	lds	r24, 0x0712
    7d26:	90 91 13 07 	lds	r25, 0x0713
    7d2a:	60 e0       	ldi	r22, 0x00	; 0
    7d2c:	70 e0       	ldi	r23, 0x00	; 0
    7d2e:	40 e0       	ldi	r20, 0x00	; 0
    7d30:	50 e0       	ldi	r21, 0x00	; 0
    7d32:	20 e0       	ldi	r18, 0x00	; 0
    7d34:	0e 94 c0 1a 	call	0x3580	; 0x3580 <xQueueGenericSend>
		vTaskSuspend( (TaskHandle_t*) Initialize_Task );
    7d38:	80 91 f8 06 	lds	r24, 0x06F8
    7d3c:	90 91 f9 06 	lds	r25, 0x06F9
    7d40:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <vTaskSuspend>
    7d44:	ba cf       	rjmp	.-140    	; 0x7cba <vTask0_Init+0xe>

00007d46 <vTask1_LED0_ON>:
	}
}

/************************************************* LED0 *************************************************/
void vTask1_LED0_ON(void *ptr){
    7d46:	df 93       	push	r29
    7d48:	cf 93       	push	r28
    7d4a:	00 d0       	rcall	.+0      	; 0x7d4c <vTask1_LED0_ON+0x6>
    7d4c:	cd b7       	in	r28, 0x3d	; 61
    7d4e:	de b7       	in	r29, 0x3e	; 62
    7d50:	9a 83       	std	Y+2, r25	; 0x02
    7d52:	89 83       	std	Y+1, r24	; 0x01
    7d54:	ff cf       	rjmp	.-2      	; 0x7d54 <vTask1_LED0_ON+0xe>

00007d56 <vTask2_LED0_OFF>:
	while(1){

	}
}

void vTask2_LED0_OFF(void *ptr){
    7d56:	df 93       	push	r29
    7d58:	cf 93       	push	r28
    7d5a:	00 d0       	rcall	.+0      	; 0x7d5c <vTask2_LED0_OFF+0x6>
    7d5c:	cd b7       	in	r28, 0x3d	; 61
    7d5e:	de b7       	in	r29, 0x3e	; 62
    7d60:	9a 83       	std	Y+2, r25	; 0x02
    7d62:	89 83       	std	Y+1, r24	; 0x01
    7d64:	ff cf       	rjmp	.-2      	; 0x7d64 <vTask2_LED0_OFF+0xe>

00007d66 <vTask3_LED0_TOGGLE>:

	}
}


void vTask3_LED0_TOGGLE(void *ptr){
    7d66:	df 93       	push	r29
    7d68:	cf 93       	push	r28
    7d6a:	00 d0       	rcall	.+0      	; 0x7d6c <vTask3_LED0_TOGGLE+0x6>
    7d6c:	cd b7       	in	r28, 0x3d	; 61
    7d6e:	de b7       	in	r29, 0x3e	; 62
    7d70:	9a 83       	std	Y+2, r25	; 0x02
    7d72:	89 83       	std	Y+1, r24	; 0x01
	while(1){
		LED_voidTOGGLE(DIO_u8PortC, DIO_u8PIN2);
    7d74:	82 e0       	ldi	r24, 0x02	; 2
    7d76:	62 e0       	ldi	r22, 0x02	; 2
    7d78:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO_enuTogglePinValue>
		vTaskDelay(1000);
    7d7c:	88 ee       	ldi	r24, 0xE8	; 232
    7d7e:	93 e0       	ldi	r25, 0x03	; 3
    7d80:	0e 94 50 2b 	call	0x56a0	; 0x56a0 <vTaskDelay>
    7d84:	f7 cf       	rjmp	.-18     	; 0x7d74 <vTask3_LED0_TOGGLE+0xe>

00007d86 <vTask4_LED1_ON>:
/********************************************************************************************************/



/************************************************* LED1 *************************************************/
void vTask4_LED1_ON(void *ptr){
    7d86:	df 93       	push	r29
    7d88:	cf 93       	push	r28
    7d8a:	00 d0       	rcall	.+0      	; 0x7d8c <vTask4_LED1_ON+0x6>
    7d8c:	cd b7       	in	r28, 0x3d	; 61
    7d8e:	de b7       	in	r29, 0x3e	; 62
    7d90:	9a 83       	std	Y+2, r25	; 0x02
    7d92:	89 83       	std	Y+1, r24	; 0x01
    7d94:	ff cf       	rjmp	.-2      	; 0x7d94 <vTask4_LED1_ON+0xe>

00007d96 <vTask5_LED1_OFF>:
	while(1){

	}
}

void vTask5_LED1_OFF(void *ptr){
    7d96:	df 93       	push	r29
    7d98:	cf 93       	push	r28
    7d9a:	00 d0       	rcall	.+0      	; 0x7d9c <vTask5_LED1_OFF+0x6>
    7d9c:	cd b7       	in	r28, 0x3d	; 61
    7d9e:	de b7       	in	r29, 0x3e	; 62
    7da0:	9a 83       	std	Y+2, r25	; 0x02
    7da2:	89 83       	std	Y+1, r24	; 0x01
    7da4:	ff cf       	rjmp	.-2      	; 0x7da4 <vTask5_LED1_OFF+0xe>

00007da6 <vTask6_LED1_TOGGLE>:

	}
}


void vTask6_LED1_TOGGLE(void *ptr){
    7da6:	df 93       	push	r29
    7da8:	cf 93       	push	r28
    7daa:	00 d0       	rcall	.+0      	; 0x7dac <vTask6_LED1_TOGGLE+0x6>
    7dac:	cd b7       	in	r28, 0x3d	; 61
    7dae:	de b7       	in	r29, 0x3e	; 62
    7db0:	9a 83       	std	Y+2, r25	; 0x02
    7db2:	89 83       	std	Y+1, r24	; 0x01
	while(1){
		LED_voidTOGGLE(DIO_u8PortC, DIO_u8PIN7);
    7db4:	82 e0       	ldi	r24, 0x02	; 2
    7db6:	67 e0       	ldi	r22, 0x07	; 7
    7db8:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO_enuTogglePinValue>
		 *
		 * If configTICK_RATE_HZ is 1000, then vTaskDelay(2000) equals 2000 ms (2 seconds).
		 * If configTICK_RATE_HZ is 2000, then vTaskDelay(2000) equals 1000 ms (1 second).
		 */

		vTaskDelay(1000);
    7dbc:	88 ee       	ldi	r24, 0xE8	; 232
    7dbe:	93 e0       	ldi	r25, 0x03	; 3
    7dc0:	0e 94 50 2b 	call	0x56a0	; 0x56a0 <vTaskDelay>
    7dc4:	f7 cf       	rjmp	.-18     	; 0x7db4 <vTask6_LED1_TOGGLE+0xe>

00007dc6 <vTask7_LED2_ON>:
}
/********************************************************************************************************/


/************************************************* LED2 *************************************************/
void vTask7_LED2_ON(void *ptr){
    7dc6:	df 93       	push	r29
    7dc8:	cf 93       	push	r28
    7dca:	00 d0       	rcall	.+0      	; 0x7dcc <vTask7_LED2_ON+0x6>
    7dcc:	cd b7       	in	r28, 0x3d	; 61
    7dce:	de b7       	in	r29, 0x3e	; 62
    7dd0:	9a 83       	std	Y+2, r25	; 0x02
    7dd2:	89 83       	std	Y+1, r24	; 0x01
    7dd4:	ff cf       	rjmp	.-2      	; 0x7dd4 <vTask7_LED2_ON+0xe>

00007dd6 <vTask8_LED2_OFF>:
	while(1){

	}
}

void vTask8_LED2_OFF(void *ptr){
    7dd6:	df 93       	push	r29
    7dd8:	cf 93       	push	r28
    7dda:	00 d0       	rcall	.+0      	; 0x7ddc <vTask8_LED2_OFF+0x6>
    7ddc:	cd b7       	in	r28, 0x3d	; 61
    7dde:	de b7       	in	r29, 0x3e	; 62
    7de0:	9a 83       	std	Y+2, r25	; 0x02
    7de2:	89 83       	std	Y+1, r24	; 0x01
    7de4:	ff cf       	rjmp	.-2      	; 0x7de4 <vTask8_LED2_OFF+0xe>

00007de6 <vTask9_LED2_TOGGLE>:

	}
}


void vTask9_LED2_TOGGLE(void *ptr){
    7de6:	df 93       	push	r29
    7de8:	cf 93       	push	r28
    7dea:	00 d0       	rcall	.+0      	; 0x7dec <vTask9_LED2_TOGGLE+0x6>
    7dec:	cd b7       	in	r28, 0x3d	; 61
    7dee:	de b7       	in	r29, 0x3e	; 62
    7df0:	9a 83       	std	Y+2, r25	; 0x02
    7df2:	89 83       	std	Y+1, r24	; 0x01
	while(1){
		LED_voidTOGGLE(DIO_u8PortD, DIO_u8PIN3);
    7df4:	83 e0       	ldi	r24, 0x03	; 3
    7df6:	63 e0       	ldi	r22, 0x03	; 3
    7df8:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO_enuTogglePinValue>
		vTaskDelay(1000);
    7dfc:	88 ee       	ldi	r24, 0xE8	; 232
    7dfe:	93 e0       	ldi	r25, 0x03	; 3
    7e00:	0e 94 50 2b 	call	0x56a0	; 0x56a0 <vTaskDelay>
    7e04:	f7 cf       	rjmp	.-18     	; 0x7df4 <vTask9_LED2_TOGGLE+0xe>

00007e06 <vTask10_LCD_Write_1>:
	}
}
/********************************************************************************************************/
void vTask10_LCD_Write_1(void* ptr){
    7e06:	df 93       	push	r29
    7e08:	cf 93       	push	r28
    7e0a:	00 d0       	rcall	.+0      	; 0x7e0c <vTask10_LCD_Write_1+0x6>
    7e0c:	cd b7       	in	r28, 0x3d	; 61
    7e0e:	de b7       	in	r29, 0x3e	; 62
    7e10:	9a 83       	std	Y+2, r25	; 0x02
    7e12:	89 83       	std	Y+1, r24	; 0x01
	while(1){



		if(pdTRUE == xSemaphoreTake(LCD_Key, 0)){
    7e14:	80 91 12 07 	lds	r24, 0x0712
    7e18:	90 91 13 07 	lds	r25, 0x0713
    7e1c:	60 e0       	ldi	r22, 0x00	; 0
    7e1e:	70 e0       	ldi	r23, 0x00	; 0
    7e20:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <xQueueSemaphoreTake>
    7e24:	81 30       	cpi	r24, 0x01	; 1
    7e26:	91 f4       	brne	.+36     	; 0x7e4c <vTask10_LCD_Write_1+0x46>

			LCD_enuClearDisplay();
    7e28:	81 e0       	ldi	r24, 0x01	; 1
    7e2a:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
			LCD_u8SendString((uint8_t*)"LCD Task 1");
    7e2e:	85 e6       	ldi	r24, 0x65	; 101
    7e30:	90 e0       	ldi	r25, 0x00	; 0
    7e32:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <LCD_u8SendString>
			xSemaphoreGive(LCD_Key);
    7e36:	80 91 12 07 	lds	r24, 0x0712
    7e3a:	90 91 13 07 	lds	r25, 0x0713
    7e3e:	60 e0       	ldi	r22, 0x00	; 0
    7e40:	70 e0       	ldi	r23, 0x00	; 0
    7e42:	40 e0       	ldi	r20, 0x00	; 0
    7e44:	50 e0       	ldi	r21, 0x00	; 0
    7e46:	20 e0       	ldi	r18, 0x00	; 0
    7e48:	0e 94 c0 1a 	call	0x3580	; 0x3580 <xQueueGenericSend>
		}
		vTaskDelay(1000);
    7e4c:	88 ee       	ldi	r24, 0xE8	; 232
    7e4e:	93 e0       	ldi	r25, 0x03	; 3
    7e50:	0e 94 50 2b 	call	0x56a0	; 0x56a0 <vTaskDelay>
    7e54:	df cf       	rjmp	.-66     	; 0x7e14 <vTask10_LCD_Write_1+0xe>

00007e56 <vTask11_LCD_Write_2>:
	}

}

void vTask11_LCD_Write_2(void* ptr){
    7e56:	df 93       	push	r29
    7e58:	cf 93       	push	r28
    7e5a:	00 d0       	rcall	.+0      	; 0x7e5c <vTask11_LCD_Write_2+0x6>
    7e5c:	cd b7       	in	r28, 0x3d	; 61
    7e5e:	de b7       	in	r29, 0x3e	; 62
    7e60:	9a 83       	std	Y+2, r25	; 0x02
    7e62:	89 83       	std	Y+1, r24	; 0x01
	while(1){

		if(pdTRUE == xSemaphoreTake(LCD_Key, 0)){
    7e64:	80 91 12 07 	lds	r24, 0x0712
    7e68:	90 91 13 07 	lds	r25, 0x0713
    7e6c:	60 e0       	ldi	r22, 0x00	; 0
    7e6e:	70 e0       	ldi	r23, 0x00	; 0
    7e70:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <xQueueSemaphoreTake>
    7e74:	81 30       	cpi	r24, 0x01	; 1
    7e76:	91 f4       	brne	.+36     	; 0x7e9c <vTask11_LCD_Write_2+0x46>

			LCD_enuClearDisplay();
    7e78:	81 e0       	ldi	r24, 0x01	; 1
    7e7a:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <LCD_enuSendCommand>
			LCD_u8SendString((uint8_t*)"LCD Task 2");
    7e7e:	80 e7       	ldi	r24, 0x70	; 112
    7e80:	90 e0       	ldi	r25, 0x00	; 0
    7e82:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <LCD_u8SendString>
			xSemaphoreGive(LCD_Key);
    7e86:	80 91 12 07 	lds	r24, 0x0712
    7e8a:	90 91 13 07 	lds	r25, 0x0713
    7e8e:	60 e0       	ldi	r22, 0x00	; 0
    7e90:	70 e0       	ldi	r23, 0x00	; 0
    7e92:	40 e0       	ldi	r20, 0x00	; 0
    7e94:	50 e0       	ldi	r21, 0x00	; 0
    7e96:	20 e0       	ldi	r18, 0x00	; 0
    7e98:	0e 94 c0 1a 	call	0x3580	; 0x3580 <xQueueGenericSend>
		}
		vTaskDelay(1000);
    7e9c:	88 ee       	ldi	r24, 0xE8	; 232
    7e9e:	93 e0       	ldi	r25, 0x03	; 3
    7ea0:	0e 94 50 2b 	call	0x56a0	; 0x56a0 <vTaskDelay>
    7ea4:	df cf       	rjmp	.-66     	; 0x7e64 <vTask11_LCD_Write_2+0xe>

00007ea6 <main>:





int main(){
    7ea6:	ef 92       	push	r14
    7ea8:	ff 92       	push	r15
    7eaa:	0f 93       	push	r16
    7eac:	df 93       	push	r29
    7eae:	cf 93       	push	r28
    7eb0:	cd b7       	in	r28, 0x3d	; 61
    7eb2:	de b7       	in	r29, 0x3e	; 62
	 *
	 *	stack size per task 1536/{number of tasks} = 384
	 *
	 * */

	xTaskCreate(vTask0_Init, "Initialize Task", configMINIMAL_STACK_SIZE, NULL, 4, &Initialize_Task);
    7eb4:	e8 ef       	ldi	r30, 0xF8	; 248
    7eb6:	f6 e0       	ldi	r31, 0x06	; 6
    7eb8:	86 e5       	ldi	r24, 0x56	; 86
    7eba:	9e e3       	ldi	r25, 0x3E	; 62
    7ebc:	2b e7       	ldi	r18, 0x7B	; 123
    7ebe:	30 e0       	ldi	r19, 0x00	; 0
    7ec0:	b9 01       	movw	r22, r18
    7ec2:	45 e5       	ldi	r20, 0x55	; 85
    7ec4:	50 e0       	ldi	r21, 0x00	; 0
    7ec6:	20 e0       	ldi	r18, 0x00	; 0
    7ec8:	30 e0       	ldi	r19, 0x00	; 0
    7eca:	04 e0       	ldi	r16, 0x04	; 4
    7ecc:	7f 01       	movw	r14, r30
    7ece:	0e 94 e9 28 	call	0x51d2	; 0x51d2 <xTaskCreate>
//	xTaskCreate(vTask3_LED0_TOGGLE, "LED0 Toggle", configMINIMAL_STACK_SIZE, NULL, 3, &LED0_Toggle_Task);
//	xTaskCreate(vTask6_LED1_TOGGLE, "LED1 Toggle", configMINIMAL_STACK_SIZE, NULL, 2, &LED1_Toggle_Task);
//	xTaskCreate(vTask9_LED2_TOGGLE, "LED2 Toggle", configMINIMAL_STACK_SIZE, NULL, 1, &LED2_Toggle_Task);

	xTaskCreate(vTask10_LCD_Write_1, "LCD Write Task 1", configMINIMAL_STACK_SIZE, NULL, 3, &LCD_Write_Task1);
    7ed2:	ec e0       	ldi	r30, 0x0C	; 12
    7ed4:	f7 e0       	ldi	r31, 0x07	; 7
    7ed6:	83 e0       	ldi	r24, 0x03	; 3
    7ed8:	9f e3       	ldi	r25, 0x3F	; 63
    7eda:	2b e8       	ldi	r18, 0x8B	; 139
    7edc:	30 e0       	ldi	r19, 0x00	; 0
    7ede:	b9 01       	movw	r22, r18
    7ee0:	45 e5       	ldi	r20, 0x55	; 85
    7ee2:	50 e0       	ldi	r21, 0x00	; 0
    7ee4:	20 e0       	ldi	r18, 0x00	; 0
    7ee6:	30 e0       	ldi	r19, 0x00	; 0
    7ee8:	03 e0       	ldi	r16, 0x03	; 3
    7eea:	7f 01       	movw	r14, r30
    7eec:	0e 94 e9 28 	call	0x51d2	; 0x51d2 <xTaskCreate>
//	xTaskCreate(vTask11_LCD_Write_2, "LCD Write Task 2", configMINIMAL_STACK_SIZE, NULL, 3, &LCD_Write_Task2);
	// Uncomment these one at a time to test memory usage

	vTaskStartScheduler();
    7ef0:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <vTaskStartScheduler>
    7ef4:	ff cf       	rjmp	.-2      	; 0x7ef4 <main+0x4e>

00007ef6 <__udivmodhi4>:
    7ef6:	aa 1b       	sub	r26, r26
    7ef8:	bb 1b       	sub	r27, r27
    7efa:	51 e1       	ldi	r21, 0x11	; 17
    7efc:	07 c0       	rjmp	.+14     	; 0x7f0c <__udivmodhi4_ep>

00007efe <__udivmodhi4_loop>:
    7efe:	aa 1f       	adc	r26, r26
    7f00:	bb 1f       	adc	r27, r27
    7f02:	a6 17       	cp	r26, r22
    7f04:	b7 07       	cpc	r27, r23
    7f06:	10 f0       	brcs	.+4      	; 0x7f0c <__udivmodhi4_ep>
    7f08:	a6 1b       	sub	r26, r22
    7f0a:	b7 0b       	sbc	r27, r23

00007f0c <__udivmodhi4_ep>:
    7f0c:	88 1f       	adc	r24, r24
    7f0e:	99 1f       	adc	r25, r25
    7f10:	5a 95       	dec	r21
    7f12:	a9 f7       	brne	.-22     	; 0x7efe <__udivmodhi4_loop>
    7f14:	80 95       	com	r24
    7f16:	90 95       	com	r25
    7f18:	bc 01       	movw	r22, r24
    7f1a:	cd 01       	movw	r24, r26
    7f1c:	08 95       	ret

00007f1e <__divmodsi4>:
    7f1e:	97 fb       	bst	r25, 7
    7f20:	09 2e       	mov	r0, r25
    7f22:	05 26       	eor	r0, r21
    7f24:	0e d0       	rcall	.+28     	; 0x7f42 <__divmodsi4_neg1>
    7f26:	57 fd       	sbrc	r21, 7
    7f28:	04 d0       	rcall	.+8      	; 0x7f32 <__divmodsi4_neg2>
    7f2a:	14 d0       	rcall	.+40     	; 0x7f54 <__udivmodsi4>
    7f2c:	0a d0       	rcall	.+20     	; 0x7f42 <__divmodsi4_neg1>
    7f2e:	00 1c       	adc	r0, r0
    7f30:	38 f4       	brcc	.+14     	; 0x7f40 <__divmodsi4_exit>

00007f32 <__divmodsi4_neg2>:
    7f32:	50 95       	com	r21
    7f34:	40 95       	com	r20
    7f36:	30 95       	com	r19
    7f38:	21 95       	neg	r18
    7f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    7f3c:	4f 4f       	sbci	r20, 0xFF	; 255
    7f3e:	5f 4f       	sbci	r21, 0xFF	; 255

00007f40 <__divmodsi4_exit>:
    7f40:	08 95       	ret

00007f42 <__divmodsi4_neg1>:
    7f42:	f6 f7       	brtc	.-4      	; 0x7f40 <__divmodsi4_exit>
    7f44:	90 95       	com	r25
    7f46:	80 95       	com	r24
    7f48:	70 95       	com	r23
    7f4a:	61 95       	neg	r22
    7f4c:	7f 4f       	sbci	r23, 0xFF	; 255
    7f4e:	8f 4f       	sbci	r24, 0xFF	; 255
    7f50:	9f 4f       	sbci	r25, 0xFF	; 255
    7f52:	08 95       	ret

00007f54 <__udivmodsi4>:
    7f54:	a1 e2       	ldi	r26, 0x21	; 33
    7f56:	1a 2e       	mov	r1, r26
    7f58:	aa 1b       	sub	r26, r26
    7f5a:	bb 1b       	sub	r27, r27
    7f5c:	fd 01       	movw	r30, r26
    7f5e:	0d c0       	rjmp	.+26     	; 0x7f7a <__udivmodsi4_ep>

00007f60 <__udivmodsi4_loop>:
    7f60:	aa 1f       	adc	r26, r26
    7f62:	bb 1f       	adc	r27, r27
    7f64:	ee 1f       	adc	r30, r30
    7f66:	ff 1f       	adc	r31, r31
    7f68:	a2 17       	cp	r26, r18
    7f6a:	b3 07       	cpc	r27, r19
    7f6c:	e4 07       	cpc	r30, r20
    7f6e:	f5 07       	cpc	r31, r21
    7f70:	20 f0       	brcs	.+8      	; 0x7f7a <__udivmodsi4_ep>
    7f72:	a2 1b       	sub	r26, r18
    7f74:	b3 0b       	sbc	r27, r19
    7f76:	e4 0b       	sbc	r30, r20
    7f78:	f5 0b       	sbc	r31, r21

00007f7a <__udivmodsi4_ep>:
    7f7a:	66 1f       	adc	r22, r22
    7f7c:	77 1f       	adc	r23, r23
    7f7e:	88 1f       	adc	r24, r24
    7f80:	99 1f       	adc	r25, r25
    7f82:	1a 94       	dec	r1
    7f84:	69 f7       	brne	.-38     	; 0x7f60 <__udivmodsi4_loop>
    7f86:	60 95       	com	r22
    7f88:	70 95       	com	r23
    7f8a:	80 95       	com	r24
    7f8c:	90 95       	com	r25
    7f8e:	9b 01       	movw	r18, r22
    7f90:	ac 01       	movw	r20, r24
    7f92:	bd 01       	movw	r22, r26
    7f94:	cf 01       	movw	r24, r30
    7f96:	08 95       	ret

00007f98 <__prologue_saves__>:
    7f98:	2f 92       	push	r2
    7f9a:	3f 92       	push	r3
    7f9c:	4f 92       	push	r4
    7f9e:	5f 92       	push	r5
    7fa0:	6f 92       	push	r6
    7fa2:	7f 92       	push	r7
    7fa4:	8f 92       	push	r8
    7fa6:	9f 92       	push	r9
    7fa8:	af 92       	push	r10
    7faa:	bf 92       	push	r11
    7fac:	cf 92       	push	r12
    7fae:	df 92       	push	r13
    7fb0:	ef 92       	push	r14
    7fb2:	ff 92       	push	r15
    7fb4:	0f 93       	push	r16
    7fb6:	1f 93       	push	r17
    7fb8:	cf 93       	push	r28
    7fba:	df 93       	push	r29
    7fbc:	cd b7       	in	r28, 0x3d	; 61
    7fbe:	de b7       	in	r29, 0x3e	; 62
    7fc0:	ca 1b       	sub	r28, r26
    7fc2:	db 0b       	sbc	r29, r27
    7fc4:	0f b6       	in	r0, 0x3f	; 63
    7fc6:	f8 94       	cli
    7fc8:	de bf       	out	0x3e, r29	; 62
    7fca:	0f be       	out	0x3f, r0	; 63
    7fcc:	cd bf       	out	0x3d, r28	; 61
    7fce:	09 94       	ijmp

00007fd0 <__epilogue_restores__>:
    7fd0:	2a 88       	ldd	r2, Y+18	; 0x12
    7fd2:	39 88       	ldd	r3, Y+17	; 0x11
    7fd4:	48 88       	ldd	r4, Y+16	; 0x10
    7fd6:	5f 84       	ldd	r5, Y+15	; 0x0f
    7fd8:	6e 84       	ldd	r6, Y+14	; 0x0e
    7fda:	7d 84       	ldd	r7, Y+13	; 0x0d
    7fdc:	8c 84       	ldd	r8, Y+12	; 0x0c
    7fde:	9b 84       	ldd	r9, Y+11	; 0x0b
    7fe0:	aa 84       	ldd	r10, Y+10	; 0x0a
    7fe2:	b9 84       	ldd	r11, Y+9	; 0x09
    7fe4:	c8 84       	ldd	r12, Y+8	; 0x08
    7fe6:	df 80       	ldd	r13, Y+7	; 0x07
    7fe8:	ee 80       	ldd	r14, Y+6	; 0x06
    7fea:	fd 80       	ldd	r15, Y+5	; 0x05
    7fec:	0c 81       	ldd	r16, Y+4	; 0x04
    7fee:	1b 81       	ldd	r17, Y+3	; 0x03
    7ff0:	aa 81       	ldd	r26, Y+2	; 0x02
    7ff2:	b9 81       	ldd	r27, Y+1	; 0x01
    7ff4:	ce 0f       	add	r28, r30
    7ff6:	d1 1d       	adc	r29, r1
    7ff8:	0f b6       	in	r0, 0x3f	; 63
    7ffa:	f8 94       	cli
    7ffc:	de bf       	out	0x3e, r29	; 62
    7ffe:	0f be       	out	0x3f, r0	; 63
    8000:	cd bf       	out	0x3d, r28	; 61
    8002:	ed 01       	movw	r28, r26
    8004:	08 95       	ret

00008006 <memcpy>:
    8006:	fb 01       	movw	r30, r22
    8008:	dc 01       	movw	r26, r24
    800a:	02 c0       	rjmp	.+4      	; 0x8010 <memcpy+0xa>
    800c:	01 90       	ld	r0, Z+
    800e:	0d 92       	st	X+, r0
    8010:	41 50       	subi	r20, 0x01	; 1
    8012:	50 40       	sbci	r21, 0x00	; 0
    8014:	d8 f7       	brcc	.-10     	; 0x800c <memcpy+0x6>
    8016:	08 95       	ret

00008018 <memset>:
    8018:	dc 01       	movw	r26, r24
    801a:	01 c0       	rjmp	.+2      	; 0x801e <memset+0x6>
    801c:	6d 93       	st	X+, r22
    801e:	41 50       	subi	r20, 0x01	; 1
    8020:	50 40       	sbci	r21, 0x00	; 0
    8022:	e0 f7       	brcc	.-8      	; 0x801c <memset+0x4>
    8024:	08 95       	ret

00008026 <_exit>:
    8026:	f8 94       	cli

00008028 <__stop_program>:
    8028:	ff cf       	rjmp	.-2      	; 0x8028 <__stop_program>
